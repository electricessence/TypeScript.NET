{"version":3,"sources":["System/Observable/ObservableBase.js","System/Observable/ObservableBase.ts"],"names":[],"mappings":";;;;;;AAMA;;;;;;;;;;ACEA,IAAA,qBAAA,QAA+B,oBAA/B,CAAA;;IAMA;;;;;;;;;;;gCAImB,OAAO;AAExB,0BACC,KAAK,eAAL,EADD,EAEC,aAAC;AAAM,kBAAE,MAAF,IAAY,EAAE,MAAF,CAAS,KAAT,CAAZ,CAAN;aAAD,CAFD,CAFwB;;;;iCAQN,OAAW;AAE7B,0BACC,KAAK,eAAL,EADD,EAEC,aAAC;AAAM,kBAAE,OAAF,IAAa,EAAE,OAAF,CAAU,KAAV,CAAb,CAAN;aAAD,CAFD,CAF6B;;;;uCAQR;AAErB,0BACC,KAAK,eAAL,CAAqB,IAArB,CADD,EAEC,aAAC;AAAM,kBAAE,WAAF,IAAiB,EAAE,WAAF,EAAjB,CAAN;aAAD,CAFD,CAFqB;;;;WApBvB;EACQ,mBAAA,gBAAA;;AADc,QAAA,cAAA,GAAc,cAAd;AA6BtB,IAAM,yBAAgC,uEAAhC;AAEN,SAAA,aAAA,CACC,SADD,EAEC,OAFD,EAE+B;AAE9B,QAAI,kBAAmD,IAAnD,CAF0B;;;;;;AAI9B,6BAAa,mCAAb,oGACA;gBADQ,gBACR;;AACC,gBACA;AACC,wBAAQ,CAAR,EADD;aADA,CAIA,OAAM,EAAN,EACA;AACC,kCAAkB,mBAAmB,EAAnB,CADnB;AAGC,gCAAgB,IAAhB,CAAqB,EAAC,UAAU,CAAV,EAAa,IAAI,EAAJ,EAAnC,EAHD;aADA;SAND;;;;;;;;;;;;;;KAJ8B;;AAkB9B,cAAU,MAAV,GAAmB,CAAnB,CAlB8B;AAoB9B,QAAG,mBAAmB,gBAAgB,MAAhB,EACtB;AACC,YAAG,WAAW,QAAQ,KAAR,EACb,QAAQ,KAAR,CAAc,sBAAd,EAAsC,eAAtC,EADD,KAEK,MAAM;AACV,qBAAS,sBAAT;AACA,oBAAQ,eAAR;SAFI,CAFL;KAFD;CAtBD;AAkCA,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADnCA,QAAQ,OAAR,GCmCe,cDnCf","file":"System/Observable/ObservableBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Based upon .NET source.\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Source: http://referencesource.microsoft.com/#mscorlib/system/IObserver.cs\n */\n\"use strict\";\nconst SubscribableBase_1 = require(\"./SubscribableBase\");\nclass ObservableBase extends SubscribableBase_1.SubscribableBase {\n    _onNext(value) {\n        processAction(this._getSubscribers(), s => { s.onNext && s.onNext(value); });\n    }\n    _onError(error) {\n        processAction(this._getSubscribers(), s => { s.onError && s.onError(error); });\n    }\n    _onCompleted() {\n        processAction(this._unsubscribeAll(true), s => { s.onCompleted && s.onCompleted(); });\n    }\n}\nexports.ObservableBase = ObservableBase;\nconst OBSERVER_ERROR_MESSAGE = 'One or more observers had errors when attempting to pass information.';\nfunction processAction(observers, handler) {\n    var observersErrors = null;\n    for (let s of observers) {\n        try {\n            handler(s);\n        }\n        catch (ex) {\n            observersErrors = observersErrors || [];\n            observersErrors.push({ observer: s, ex: ex });\n        }\n    }\n    observers.length = 0;\n    if (observersErrors && observersErrors.length) {\n        if (console && console.error)\n            console.error(OBSERVER_ERROR_MESSAGE, observersErrors);\n        else\n            throw {\n                message: OBSERVER_ERROR_MESSAGE,\n                errors: observersErrors\n            };\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = ObservableBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based upon .NET source.\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Source: http://referencesource.microsoft.com/#mscorlib/system/IObserver.cs\r\n */\r\n\r\n\r\nimport {SubscribableBase} from \"./SubscribableBase\";\r\nimport {IObservable} from \"./IObservable\";\r\nimport {IObserver} from \"./IObserver\";\r\n\r\n// Can be used as a base class, mixin, or simply reference on how to implement the pattern.\r\n\r\nexport abstract class ObservableBase<T>\r\nextends SubscribableBase<IObserver<T>> implements IObservable<T>\r\n{\r\n\r\n\tprotected _onNext(value:T):void\r\n\t{\r\n\t\tprocessAction(\r\n\t\t\tthis._getSubscribers(),\r\n\t\t\ts => { s.onNext && s.onNext(value); }\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _onError(error:Error):void\r\n\t{\r\n\t\tprocessAction(\r\n\t\t\tthis._getSubscribers(),\r\n\t\t\ts => { s.onError && s.onError(error); }\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _onCompleted():void\r\n\t{\r\n\t\tprocessAction(\r\n\t\t\tthis._unsubscribeAll(true),\r\n\t\t\ts => { s.onCompleted && s.onCompleted(); }\r\n\t\t);\r\n\t}\r\n}\r\n\r\nconst OBSERVER_ERROR_MESSAGE:string = 'One or more observers had errors when attempting to pass information.';\r\n\r\nfunction processAction<T>(\r\n\tobservers:IObserver<T>[],\r\n\thandler:(s:IObserver<T>)=>void)\r\n{\r\n\tvar observersErrors:{observer:IObserver<T>,ex:any}[] = null;\r\n\r\n\tfor(let s of observers)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\thandler(s);\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\tobserversErrors = observersErrors || [];\r\n\t\t\t// Don't let one error prevent others from recieving information.\r\n\t\t\tobserversErrors.push({observer: s, ex: ex});\r\n\t\t}\r\n\t}\r\n\r\n\tobservers.length = 0;\r\n\r\n\tif(observersErrors && observersErrors.length)\r\n\t{\r\n\t\tif(console && console.error)\r\n\t\t\tconsole.error(OBSERVER_ERROR_MESSAGE, observersErrors);\r\n\t\telse throw {\r\n\t\t\tmessage: OBSERVER_ERROR_MESSAGE,\r\n\t\t\terrors: observersErrors\r\n\t\t};\r\n\t}\r\n\r\n}\r\n\r\nexport default ObservableBase;"]}