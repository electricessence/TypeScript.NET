{"version":3,"sources":["System/Events/EventDispatcherBase.js","System/Events/EventDispatcherBase.ts"],"names":[],"mappings":"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","file":"System/Events/EventDispatcherBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst AU = require(\"../Collections/Array/Utility\");\nconst shallowCopy_1 = require(\"../Utility/shallowCopy\");\nconst DisposableBase_1 = require(\"../Disposable/DisposableBase\");\nconst dispose_1 = require(\"../Disposable/dispose\");\nconst EventDispatcherEntry_1 = require(\"./EventDispatcherEntry\");\nconst extends_1 = require(\"../../extends\");\nconst __extends = extends_1.default;\nconst DISPOSING = 'disposing', DISPOSED = 'disposed';\nfunction entryFinalizer() {\n    var p = this.params;\n    p.dispatcher.removeEntry(this);\n    p.dispatcher = null;\n}\nclass EventDispatcherBase extends DisposableBase_1.DisposableBase {\n    constructor(...args) {\n        super(...args);\n        this._isDisposing = false;\n    }\n    addEventListener(type, listener, priority = 0) {\n        var e = this._entries;\n        if (!e)\n            this._entries = e = [];\n        e.push(new EventDispatcherEntry_1.EventDispatcherEntry(type, listener, {\n            priority: priority || 0,\n            dispatcher: this\n        }, entryFinalizer));\n    }\n    removeEntry(entry) {\n        return !!this._entries && AU.remove(this._entries, entry) != 0;\n    }\n    registerEventListener(type, listener, priority = 0) {\n        if (!this.hasEventListener(type, listener))\n            this.addEventListener(type, listener, priority);\n    }\n    hasEventListener(type, listener) {\n        var e = this._entries;\n        return e && e.some((value) => type == value.type && (!listener || listener == value.listener));\n    }\n    removeEventListener(type, listener) {\n        dispose_1.dispose.these(this._entries.filter(entry => entry.matches(type, listener)));\n    }\n    dispatchEvent(e, params) {\n        var _ = this, l = _._entries;\n        if (!l || !l.length)\n            return false;\n        var event;\n        if (typeof e == \"string\") {\n            event = Event && Object.create(Event) || {};\n            if (!params)\n                params = {};\n            if (params['cancellable'])\n                event.cancellable = true;\n            event.target = _;\n            event.type = e;\n        }\n        else\n            event = e;\n        var type = event.type;\n        var entries = l.filter(e => e.type == type);\n        if (!entries.length)\n            return false;\n        entries.sort((a, b) => b.params.priority - a.params.priority);\n        entries.forEach(entry => {\n            var newEvent = Object.create(Event);\n            shallowCopy_1.shallowCopy(event, newEvent);\n            newEvent.target = this;\n            entry.dispatch(newEvent);\n        });\n        return true;\n    }\n    static get DISPOSING() { return DISPOSING; }\n    static get DISPOSED() { return DISPOSED; }\n    get isDisposing() {\n        return this._isDisposing;\n    }\n    dispose() {\n        var _ = this;\n        if (!_.wasDisposed && !_._isDisposing) {\n            _._isDisposing = true;\n            _.dispatchEvent(DISPOSING);\n            super.dispose();\n            _.dispatchEvent(DISPOSED);\n            var l = _._entries;\n            if (l) {\n                this._entries = null;\n                l.forEach(e => e.dispose());\n            }\n        }\n    }\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = EventDispatcherBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport {shallowCopy} from \"../Utility/shallowCopy\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {dispose} from \"../Disposable/dispose\";\r\nimport {IEventListener} from \"./IEventListener\";\r\nimport {EventDispatcherEntry} from \"./EventDispatcherEntry\";\r\nimport {IEventDispatcher} from \"./IEventDispatcher\";\r\nimport __extendsImport from \"../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget>\r\n{\r\n\ttype:string;\r\n\ttarget:TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any>\r\n{\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\tvar p:IEntryParams = this.params;\r\n\tp.dispatcher.removeEntry(this);\r\n\tp.dispatcher = null;\r\n}\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tvar e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tvar e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t);\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tdispose.these(this._entries.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tvar _ = this, l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tvar event:IEventBase<any>;\r\n\r\n\t\tif(typeof e==\"string\")\r\n\t\t{\r\n\t\t\tevent = Event && Object.create(Event) || {};\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tvar type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tvar entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e=>e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=> b.params.priority - a.params.priority);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tvar newEvent = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tvar _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tvar l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}