{"version":3,"sources":["System/Events/EventDispatcherBase.ts"],"names":[],"mappings":"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","file":"EventDispatcherBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport {shallowCopy} from \"../Utility/shallowCopy\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {dispose} from \"../Disposable/dispose\";\r\nimport {IEventListener} from \"./IEventListener\";\r\nimport {EventDispatcherEntry} from \"./EventDispatcherEntry\";\r\nimport {IEventDispatcher} from \"./IEventDispatcher\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget>\r\n{\r\n\ttype:string;\r\n\ttarget:TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any>\r\n{\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\tconst p:IEntryParams = this.params;\r\n\tp.dispatcher.removeEntry(this);\r\n\t(<any>p).dispatcher = null;\r\n}\r\n\r\nconst NAME = \"EventDispatcherBase\";\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = NAME;\r\n\t}\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tlet e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t);\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tdispose.these(this._entries.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\r\n\r\n\t\tlet l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tlet event:IEventBase<any>;\r\n\r\n\t\tif(typeof e==\"string\")\r\n\t\t{\r\n\t\t\tevent = <any>(Event && Object.create(Event) || {});\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tconst type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tconst entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e => e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=>\r\n\t\t\t(b.params ? b.params.priority : 0)\r\n\t\t\t- (a.params ? a.params.priority : 0)\r\n\t\t);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tconst newEvent:any = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tconst _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tconst l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = <any>null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}