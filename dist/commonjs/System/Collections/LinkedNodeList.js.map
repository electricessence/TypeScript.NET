{"version":3,"sources":["System/Collections/LinkedNodeList.js","System/Collections/LinkedNodeList.ts"],"names":[],"mappings":"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","file":"System/Collections/LinkedNodeList.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst TextUtility = require(\"../Text/Utility\");\nconst InvalidOperationException_1 = require(\"../Exceptions/InvalidOperationException\");\nconst ArgumentException_1 = require(\"../Exceptions/ArgumentException\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst EnumeratorBase_1 = require(\"./Enumeration/EnumeratorBase\");\nconst extends_1 = require(\"../../extends\");\nconst __extends = extends_1.default;\nclass LinkedNodeList {\n    constructor() {\n        this._first = null;\n        this._last = null;\n        this.unsafeCount = 0;\n    }\n    get first() {\n        return this._first;\n    }\n    get last() {\n        return this._last;\n    }\n    get count() {\n        var next = this._first, i = 0;\n        while (next) {\n            i++;\n            next = next.next;\n        }\n        return i;\n    }\n    forEach(action) {\n        var current = null, next = this.first, index = 0;\n        do {\n            current = next;\n            next = current && current.next;\n        } while (current\n            && action(current, index++) !== false);\n        return index;\n    }\n    map(selector) {\n        if (!selector)\n            throw new ArgumentNullException_1.ArgumentNullException('selector');\n        var result = [];\n        this.forEach(node => {\n            result.push(selector(node));\n        });\n        return result;\n    }\n    clear() {\n        var _ = this, n, cF = 0, cL = 0;\n        n = _._first;\n        _._first = null;\n        while (n) {\n            cF++;\n            let current = n;\n            n = n.next;\n            current.next = null;\n        }\n        n = _._last;\n        _._last = null;\n        while (n) {\n            cL++;\n            let current = n;\n            n = n.previous;\n            current.previous = null;\n        }\n        if (cF !== cL)\n            console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\n        _.unsafeCount = 0;\n        return cF;\n    }\n    dispose() {\n        this.clear();\n    }\n    contains(node) {\n        return this.indexOf(node) != -1;\n    }\n    getNodeAt(index) {\n        if (index < 0)\n            return null;\n        var next = this._first, i = 0;\n        while (next && index < i++) {\n            next = next.next;\n        }\n        return next;\n    }\n    find(condition) {\n        var node = null;\n        this.forEach((n, i) => {\n            if (condition(n, i)) {\n                node = n;\n                return false;\n            }\n        });\n        return node;\n    }\n    indexOf(node) {\n        if (node && (node.previous || node.next)) {\n            var index = 0;\n            var c, n = this._first;\n            do {\n                c = n;\n                if (c === node)\n                    return index;\n                index++;\n            } while ((n = c && c.next));\n        }\n        return -1;\n    }\n    removeFirst() {\n        return this.removeNode(this._first);\n    }\n    removeLast() {\n        return this.removeNode(this._last);\n    }\n    removeNode(node) {\n        if (node == null)\n            throw new ArgumentNullException_1.ArgumentNullException('node');\n        var _ = this;\n        var prev = node.previous, next = node.next, a = false, b = false;\n        if (prev)\n            prev.next = next;\n        else if (_._first == node)\n            _._first = next;\n        else\n            a = true;\n        if (next)\n            next.previous = prev;\n        else if (_._last == node)\n            _._last = prev;\n        else\n            b = true;\n        if (a !== b) {\n            throw new ArgumentException_1.ArgumentException('node', TextUtility.format(\"Provided node is has no {0} reference but is not the {1} node!\", a ? \"previous\" : \"next\", a ? \"first\" : \"last\"));\n        }\n        var removed = !a && !b;\n        if (removed) {\n            _.unsafeCount--;\n            node.previous = null;\n            node.next = null;\n        }\n        return removed;\n    }\n    addNode(node) {\n        this.addNodeAfter(node);\n    }\n    addNodeBefore(node, before) {\n        assertValidDetached(node);\n        var _ = this;\n        if (!before) {\n            before = _._first;\n        }\n        if (before) {\n            let prev = before.previous;\n            node.previous = prev;\n            node.next = before;\n            before.previous = node;\n            if (prev)\n                prev.next = node;\n            if (before == _._first)\n                _._last = node;\n        }\n        else {\n            _._first = _._last = node;\n        }\n        _.unsafeCount++;\n    }\n    addNodeAfter(node, after) {\n        assertValidDetached(node);\n        var _ = this;\n        if (!after) {\n            after = _._last;\n        }\n        if (after) {\n            let next = after.next;\n            node.next = next;\n            node.previous = after;\n            after.next = node;\n            if (next)\n                next.previous = node;\n            if (after == _._last)\n                _._last = node;\n        }\n        else {\n            _._first = _._last = node;\n        }\n        _.unsafeCount++;\n    }\n    replace(node, replacement) {\n        if (node == null)\n            throw new ArgumentNullException_1.ArgumentNullException('node');\n        assertValidDetached(replacement, 'replacement');\n        var _ = this;\n        replacement.previous = node.previous;\n        replacement.next = node.next;\n        if (node.previous)\n            node.previous.next = replacement;\n        if (node.next)\n            node.next.previous = replacement;\n        if (node == _._first)\n            _._first = replacement;\n        if (node == _._last)\n            _._last = replacement;\n    }\n    static valueEnumeratorFrom(list) {\n        if (!list)\n            throw new ArgumentNullException_1.ArgumentNullException('list');\n        var _ = this, current, next;\n        return new EnumeratorBase_1.EnumeratorBase(() => {\n            current = null;\n            next = list.first;\n        }, (yielder) => {\n            if (next) {\n                current = next;\n                next = current && current.next;\n                return yielder.yieldReturn(current.value);\n            }\n            return yielder.yieldBreak();\n        });\n    }\n    static copyValues(list, array, index = 0) {\n        if (list && list.first) {\n            if (!array)\n                throw new ArgumentNullException_1.ArgumentNullException('array');\n            list.forEach((node, i) => {\n                array[index + i] = node.value;\n            });\n        }\n        return array;\n    }\n}\nexports.LinkedNodeList = LinkedNodeList;\nfunction assertValidDetached(node, propName = 'node') {\n    if (node == null)\n        throw new ArgumentNullException_1.ArgumentNullException(propName);\n    if (node.next || node.previous)\n        throw new InvalidOperationException_1.InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LinkedNodeList;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as TextUtility from \"../Text/Utility\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {ILinkedNode, ILinkedNodeWithValue} from \"./ILinkedListNode\";\r\nimport {IEnumerateEach} from \"./Enumeration/IEnumerateEach\";\r\nimport {IDisposable} from \"../Disposable/IDisposable\";\r\nimport {ILinkedNodeList} from \"./ILinkedList\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {Predicate, Selector, Action} from \"../FunctionTypes\";\r\nimport {IArray} from \"./Array/IArray\";\r\nimport __extendsImport from \"../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/*****************************\r\n * IMPORTANT NOTES ABOUT PERFORMANCE:\r\n * http://jsperf.com/simulating-a-queue\r\n *\r\n * Adding to an array is very fast, but modifying is slow.\r\n * LinkedList wins when modifying contents.\r\n * http://stackoverflow.com/questions/166884/array-versus-linked-list\r\n *****************************/\r\n\r\n/**\r\n * This class is useful for managing a list of linked nodes, but it does not protect against modifying individual links.\r\n * If the consumer modifies a link (sets the previous or next value) it will effectively break the collection.\r\n *\r\n * It is possible to declare a node type of any kind as long as it contains a previous and next value that can reference another node.\r\n * Although not as safe as the included LinkedList, this class has less overhead and is more flexible.\r\n *\r\n * The count (or length) of this LinkedNodeList is not tracked since it could be corrupted at any time.\r\n */\r\nexport class LinkedNodeList<TNode extends ILinkedNode<TNode>>\r\nimplements ILinkedNodeList<TNode>, IEnumerateEach<TNode>, IDisposable\r\n{\r\n\r\n\tprivate _first:TNode;\r\n\tprivate _last:TNode;\r\n\tunsafeCount:number;\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tthis._first = null;\r\n\t\tthis._last = null;\r\n\t\tthis.unsafeCount = 0;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * The first node.  Will be null if the collection is empty.\r\n\t */\r\n\tget first():TNode\r\n\t{\r\n\t\treturn this._first;\r\n\t}\r\n\r\n\t/**\r\n\t * The last node.\r\n\t */\r\n\tget last():TNode\r\n\t{\r\n\t\treturn this._last;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Iteratively counts the number of linked nodes and returns the value.\r\n\t * @returns {number}\r\n\t */\r\n\tget count():number\r\n\t{\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next)\r\n\t\t{\r\n\t\t\ti++;\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn i;\r\n\t}\r\n\r\n\t// Note, no need for 'useCopy' since this avoids any modification conflict.\r\n\t// If iterating over a copy is necessary, a copy should be made manually.\r\n\tforEach(\r\n\t\taction:Predicate<TNode> | Action<TNode>):number\r\n\t{\r\n\t\tvar current:TNode = null,\r\n\t\t    next:TNode    = this.first, // Be sure to track the next node so if current node is removed.\r\n\t\t    index:number  = 0;\r\n\r\n\t\tdo {\r\n\t\t\tcurrent = next;\r\n\t\t\tnext = current && current.next;\r\n\t\t}\r\n\t\twhile(current\r\n\t\t&& <any>action(current, index++)!==false);\r\n\r\n\t\treturn index;\r\n\t}\r\n\r\n\tmap<T>(selector:Selector<TNode,T>):T[]\r\n\t{\r\n\t\tif(!selector) throw new ArgumentNullException('selector');\r\n\r\n\t\tvar result:T[] = [];\r\n\t\tthis.forEach(node=>\r\n\t\t{\r\n\t\t\tresult.push(selector(node));\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Erases the linked node's references to each other and returns the number of nodes.\r\n\t * @returns {number}\r\n\t */\r\n\tclear():number\r\n\t{\r\n\t\tvar _ = this, n:TNode, cF:number = 0, cL:number = 0;\r\n\r\n\t\t// First, clear in the forward direction.\r\n\t\tn = _._first;\r\n\t\t_._first = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcF++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.next;\r\n\t\t\tcurrent.next = null;\r\n\t\t}\r\n\r\n\t\t// Last, clear in the reverse direction.\r\n\t\tn = _._last;\r\n\t\t_._last = null;\r\n\r\n\t\twhile(n)\r\n\t\t{\r\n\t\t\tcL++;\r\n\t\t\tlet current = n;\r\n\t\t\tn = n.previous;\r\n\t\t\tcurrent.previous = null;\r\n\t\t}\r\n\r\n\t\tif(cF!==cL) console.warn('LinkedNodeList: Forward versus reverse count does not match when clearing. Forward: ' + cF + \", Reverse: \" + cL);\r\n\r\n\t\t_.unsafeCount = 0;\r\n\r\n\t\treturn cF;\r\n\t}\r\n\r\n\t/**\r\n\t * Clears the list.\r\n\t */\r\n\tdispose():void\r\n\t{\r\n\t\tthis.clear();\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to see if a node exists.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tcontains(node:TNode):boolean\r\n\t{\r\n\t\treturn this.indexOf(node)!= -1;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Gets the index of a particular node.\r\n\t * @param index\r\n\t */\r\n\tgetNodeAt(index:number):TNode\r\n\t{\r\n\t\tif(index<0)\r\n\t\t\treturn null;\r\n\r\n\t\tvar next = this._first, i:number = 0;\r\n\t\twhile(next && index<i++)\r\n\t\t{\r\n\t\t\tnext = next.next;\r\n\t\t}\r\n\r\n\t\treturn next;\r\n\r\n\t}\r\n\r\n\tfind(condition:Predicate<TNode>):TNode {\r\n\t\tvar node:TNode = null;\r\n\t\tthis.forEach((n,i)=>{\r\n\t\t\tif(condition(n,i)) {\r\n\t\t\t\tnode = n;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Iterates the list to find the specified node and returns its index.\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tindexOf(node:TNode):number\r\n\t{\r\n\t\tif(node && (node.previous || node.next))\r\n\t\t{\r\n\r\n\t\t\tvar index = 0;\r\n\t\t\tvar c:TNode, n:TNode = this._first;\r\n\t\t\tdo {\r\n\t\t\t\tc = n;\r\n\t\t\t\tif(c===node) return index;\r\n\t\t\t\tindex++;\r\n\t\t\t}\r\n\t\t\twhile((n = c && c.next));\r\n\t\t}\r\n\r\n\t\treturn -1;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the first node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveFirst():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._first);\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the last node and returns true if successful.\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveLast():boolean\r\n\t{\r\n\t\treturn this.removeNode(this._last);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Removes the specified node.\r\n\t * Returns true if successful and false if not found (already removed).\r\n\t * @param node\r\n\t * @returns {boolean}\r\n\t */\r\n\tremoveNode(node:TNode):boolean\r\n\t{\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tvar _ = this;\r\n\t\tvar prev = node.previous, next = node.next, a:boolean = false, b:boolean = false;\r\n\r\n\t\tif(prev) prev.next = next;\r\n\t\telse if(_._first==node) _._first = next;\r\n\t\telse a = true;\r\n\r\n\t\tif(next) next.previous = prev;\r\n\t\telse if(_._last==node) _._last = prev;\r\n\t\telse b = true;\r\n\r\n\t\tif(a!==b)\r\n\t\t{\r\n\t\t\tthrow new ArgumentException(\r\n\t\t\t\t'node', TextUtility.format(\r\n\t\t\t\t\t\"Provided node is has no {0} reference but is not the {1} node!\",\r\n\t\t\t\t\ta ? \"previous\" : \"next\", a ? \"first\" : \"last\"\r\n\t\t\t\t)\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\tvar removed = !a && !b;\r\n\t\tif(removed) {\r\n\t\t\t_.unsafeCount--;\r\n\t\t\tnode.previous = null;\r\n\t\t\tnode.next = null;\r\n\t\t}\r\n\t\treturn removed;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a node to the end of the list.\r\n\t * @param node\r\n\t */\r\n\taddNode(node:TNode):void\r\n\t{\r\n\t\tthis.addNodeAfter(node);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Inserts a node before the specified 'before' node.\r\n\t * If no 'before' node is specified, it inserts it as the first node.\r\n\t * @param node\r\n\t * @param before\r\n\t */\r\n\taddNodeBefore(node:TNode, before?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!before)\r\n\t\t{\r\n\t\t\tbefore = _._first;\r\n\t\t}\r\n\r\n\t\tif(before)\r\n\t\t{\r\n\t\t\tlet prev = before.previous;\r\n\t\t\tnode.previous = prev;\r\n\t\t\tnode.next = before;\r\n\r\n\t\t\tbefore.previous = node;\r\n\t\t\tif(prev) prev.next = node;\r\n\t\t\tif(before==_._first) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_.unsafeCount++;\r\n\t}\r\n\r\n\t/**\r\n\t * Inserts a node after the specified 'after' node.\r\n\t * If no 'after' node is specified, it appends it as the last node.\r\n\t * @param node\r\n\t * @param after\r\n\t */\r\n\taddNodeAfter(node:TNode, after?:TNode):void\r\n\t{\r\n\t\tassertValidDetached(node);\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!after)\r\n\t\t{\r\n\t\t\tafter = _._last;\r\n\t\t}\r\n\r\n\t\tif(after)\r\n\t\t{\r\n\t\t\tlet next = after.next;\r\n\t\t\tnode.next = next;\r\n\t\t\tnode.previous = after;\r\n\r\n\t\t\tafter.next = node;\r\n\t\t\tif(next) next.previous = node;\r\n\t\t\tif(after==_._last) _._last = node;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._first = _._last = node;\r\n\t\t}\r\n\r\n\t\t_.unsafeCount++;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Takes and existing node and replaces it.\r\n\t * @param node\r\n\t * @param replacement\r\n\t */\r\n\treplace(node:TNode, replacement:TNode):void\r\n\t{\r\n\r\n\t\tif(node==null)\r\n\t\t\tthrow new ArgumentNullException('node');\r\n\r\n\t\tassertValidDetached(replacement, 'replacement');\r\n\r\n\t\tvar _ = this;\r\n\t\treplacement.previous = node.previous;\r\n\t\treplacement.next = node.next;\r\n\r\n\t\tif(node.previous) node.previous.next = replacement;\r\n\t\tif(node.next) node.next.previous = replacement;\r\n\r\n\t\tif(node==_._first) _._first = replacement;\r\n\t\tif(node==_._last) _._last = replacement;\r\n\t}\r\n\r\n\tstatic valueEnumeratorFrom<T>(list:LinkedNodeList<ILinkedNodeWithValue<T>>):IEnumerator<T> {\r\n\r\n\t\tif(!list) throw new ArgumentNullException('list');\r\n\r\n\t\tvar _ = this,\r\n\t\t    current:ILinkedNodeWithValue<T>,\r\n\t\t    next:ILinkedNodeWithValue<T>;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Initialize anchor...\r\n\t\t\t\tcurrent = null;\r\n\t\t\t\tnext = list.first;\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(next)\r\n\t\t\t\t{\r\n\t\t\t\t\tcurrent = next;\r\n\t\t\t\t\tnext = current && current.next;\r\n\t\t\t\t\treturn yielder.yieldReturn(current.value);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic copyValues<T,TDestination extends IArray<any>>(\r\n\t\tlist:LinkedNodeList<ILinkedNodeWithValue<T>>,\r\n\t\tarray:TDestination,\r\n\t\tindex:number = 0):TDestination\r\n\t{\r\n\t\tif(list && list.first)\r\n\t\t{\r\n\t\t\tif(!array) throw new ArgumentNullException('array');\r\n\r\n\t\t\tlist.forEach(\r\n\t\t\t\t(node, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tarray[index + i] = node.value;\r\n\t\t\t\t}\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn array;\r\n\t}\r\n\r\n}\r\n\r\nfunction assertValidDetached<TNode extends ILinkedNode<TNode>>(node:TNode, propName:string = 'node')\r\n{\r\n\r\n\tif(node==null)\r\n\t\tthrow new ArgumentNullException(propName);\r\n\r\n\tif(node.next || node.previous)\r\n\t\tthrow new InvalidOperationException(\"Cannot add a node to a LinkedNodeList that is already linked.\");\r\n\r\n}\r\n\r\nexport default LinkedNodeList;"]}