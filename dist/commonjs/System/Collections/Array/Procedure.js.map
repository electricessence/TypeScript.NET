{"version":3,"sources":["System/Collections/Array/Procedure.js","System/Collections/Array/Procedure.ts"],"names":[],"mappings":"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","file":"System/Collections/Array/Procedure.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nfunction sum(source, ignoreNaN = false) {\n    if (!source || !source.length)\n        return 0;\n    var result = 0;\n    if (ignoreNaN)\n        source.forEach(n => {\n            if (!isNaN(n))\n                result += n;\n        });\n    else\n        source.every(n => {\n            result += n;\n            return !isNaN(result);\n        });\n    return result;\n}\nexports.sum = sum;\nfunction average(source, ignoreNaN = false) {\n    if (!source || !source.length)\n        return NaN;\n    var result = 0, count;\n    if (ignoreNaN) {\n        count = 0;\n        source.forEach(n => {\n            if (!isNaN(n)) {\n                result += n;\n                count++;\n            }\n        });\n    }\n    else {\n        count = source.length;\n        source.every(n => {\n            result += n;\n            return !isNaN(result);\n        });\n    }\n    return (!count || isNaN(result)) ? NaN : (result / count);\n}\nexports.average = average;\nfunction product(source, ignoreNaN = false) {\n    if (!source || !source.length)\n        return NaN;\n    var result = 1;\n    if (ignoreNaN) {\n        var found = false;\n        source.forEach(n => {\n            if (!isNaN(n)) {\n                result *= n;\n                if (!found)\n                    found = true;\n            }\n        });\n        if (!found)\n            result = NaN;\n    }\n    else {\n        source.every(n => {\n            if (isNaN(n)) {\n                result = NaN;\n                return false;\n            }\n            result *= n;\n            return true;\n        });\n    }\n    return result;\n}\nexports.product = product;\nfunction quotient(source, ignoreNaN = false) {\n    if (!source || source.length < 2)\n        return NaN;\n    var result = source[0];\n    var found = false;\n    source.every((n, i) => {\n        if (i) {\n            if (n === 0) {\n                result = NaN;\n                return false;\n            }\n            if (isNaN(n)) {\n                if (!ignoreNaN) {\n                    result = NaN;\n                    return false;\n                }\n            }\n            else {\n                result /= n;\n                if (!found)\n                    found = true;\n            }\n        }\n        return true;\n    });\n    if (!found)\n        result = NaN;\n    return result;\n}\nexports.quotient = quotient;\nfunction ifSet(source, start, ignoreNaN, predicate) {\n    if (!source || !source.length)\n        return NaN;\n    var result = start;\n    if (ignoreNaN) {\n        var found = false;\n        source.forEach(n => {\n            if (!isNaN(n)) {\n                if (predicate(n, result))\n                    result = n;\n                if (!found)\n                    found = true;\n            }\n        });\n        if (!found)\n            result = NaN;\n    }\n    else {\n        source.every(n => {\n            if (isNaN(n)) {\n                result = NaN;\n                return false;\n            }\n            if (predicate(n, result))\n                result = n;\n            return true;\n        });\n    }\n    return result;\n}\nfunction min(source, ignoreNaN = false) {\n    return ifSet(source, +Infinity, ignoreNaN, (n, result) => n < result);\n}\nexports.min = min;\nfunction max(source, ignoreNaN = false) {\n    return ifSet(source, -Infinity, ignoreNaN, (n, result) => n > result);\n}\nexports.max = max;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nexport function sum(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn 0;\r\n\r\n\tvar result = 0;\r\n\tif(ignoreNaN)\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n)) result += n;\r\n\t\t});\r\n\telse\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tresult += n;\r\n\t\t\treturn !isNaN(result);\r\n\t\t});\r\n\r\n\treturn result;\r\n}\r\n\r\nexport function average(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = 0, count:number;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tcount = 0;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult += n;\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\telse\r\n\t{\r\n\t\tcount = source.length;\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tresult += n;\r\n\t\t\treturn !isNaN(result);\r\n\t\t});\r\n\r\n\t}\r\n\r\n\treturn (!count || isNaN(result)) ? NaN : (result/count);\r\n}\r\n\r\nexport function product(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = 1;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tvar found = false;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult *= n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif(!found)\r\n\t\t\tresult = NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult = NaN;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tresult *= n;\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes the first number and divides it by all following.\r\n * @param source\r\n * @param ignoreNaN Will cause this skip any NaN values.\r\n * @returns {number}\r\n */\r\nexport function quotient(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\tif(!source || source.length<2)\r\n\t\treturn NaN;\r\n\r\n\tvar result = source[0];\r\n\r\n\tvar found = false;\r\n\tsource.every((n,i) =>\r\n\t{\r\n\t\tif(i) {\r\n\t\t\tif(n===0)\r\n\t\t\t{\r\n\t\t\t\tresult = NaN;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t\tif(isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tif(!ignoreNaN)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tresult /= n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn true;\r\n\t});\r\n\r\n\tif(!found)\r\n\t\tresult = NaN;\r\n\r\n\treturn result;\r\n}\r\n\r\n\r\nfunction ifSet(\r\n\tsource:number[],\r\n\tstart:number,\r\n\tignoreNaN:boolean,\r\n\tpredicate:(n:number, result:number) => boolean)\r\n{\r\n\tif(!source || !source.length)\r\n\t\treturn NaN;\r\n\r\n\tvar result = start;\r\n\tif(ignoreNaN)\r\n\t{\r\n\t\tvar found = false;\r\n\t\tsource.forEach(n =>\r\n\t\t{\r\n\t\t\tif(!isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tif(predicate(n, result))\r\n\t\t\t\t\tresult = n;\r\n\t\t\t\tif(!found) found = true;\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\tif(!found)\r\n\t\t\tresult = NaN;\r\n\t}\r\n\telse\r\n\t{\r\n\t\tsource.every(n =>\r\n\t\t{\r\n\t\t\tif(isNaN(n))\r\n\t\t\t{\r\n\t\t\t\tresult = NaN;\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\tif(predicate(n, result))\r\n\t\t\t\tresult = n;\r\n\r\n\t\t\treturn true;\r\n\t\t});\r\n\t}\r\n\treturn result;\r\n\r\n}\r\n\r\nexport function min(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, +Infinity, ignoreNaN, (n, result) => n<result);\r\n}\r\n\r\nexport function max(source:number[], ignoreNaN:boolean = false):number\r\n{\r\n\treturn ifSet(source, -Infinity, ignoreNaN, (n, result) => n>result);\r\n}\r\n"]}