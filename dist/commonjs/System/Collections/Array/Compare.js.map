{"version":3,"sources":["System/Collections/Array/Compare.js","System/Collections/Array/Compare.ts"],"names":[],"mappings":"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","file":"System/Collections/Array/Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Values = require(\"../../Compare\");\nconst Types_1 = require(\"../../Types\");\nfunction validateSize(a, b) {\n    if (a && b && a === b || !a && !b)\n        return true;\n    if (!a || !b)\n        return false;\n    var len = a.length;\n    if (len !== b.length)\n        return false;\n    if (len === 0)\n        return true;\n    return len;\n}\nfunction areAllEqual(arrays, strict, equalityComparer = Values.areEqual) {\n    if (!arrays)\n        throw new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\n    if (arrays.length < 2)\n        throw new Error(\"Cannot compare a set of arrays less than 2.\");\n    var first = arrays[0];\n    for (let i = 0, l = arrays.length; i < l; i++) {\n        if (!areEqual(first, arrays[i], strict, equalityComparer))\n            return false;\n    }\n    return true;\n}\nexports.areAllEqual = areAllEqual;\nfunction areEqual(a, b, strict, equalityComparer = Values.areEqual) {\n    var len = validateSize(a, b);\n    if (Types_1.Type.isBoolean(len))\n        return len;\n    for (let i = 0; i < len; i++) {\n        if (!equalityComparer(a[i], b[i], strict))\n            return false;\n    }\n    return true;\n}\nexports.areEqual = areEqual;\nfunction sort(a, comparer) {\n    if (!a || a.length < 2)\n        return a;\n    var len = a.length, b;\n    if (len > 65536)\n        b = new Array(len);\n    else {\n        b = [];\n        b.length = len;\n    }\n    for (let i = 0; i < len; i++) {\n        b[i] = a[i];\n    }\n    b.sort(comparer);\n    return b;\n}\nfunction areEquivalent(a, b, comparer = Values.compare) {\n    var len = validateSize(a, b);\n    if (Types_1.Type.isBoolean(len))\n        return len;\n    a = sort(a, comparer);\n    b = sort(b, comparer);\n    for (let i = 0; i < len; i++) {\n        if (comparer(a[i], b[i]) !== 0)\n            return false;\n    }\n    return true;\n}\nexports.areEquivalent = areEquivalent;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as Values from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {Primitive} from \"../../Primitive\";\r\nimport {EqualityComparison, Comparison} from \"../../FunctionTypes\";\r\nimport {IArray} from \"./IArray\";\r\nimport {IComparable} from \"../../IComparable\";\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:IArray<any>, b:IArray<any>):any\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tvar len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:any[][],\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\tvar first = arrays[0];\r\n\tfor(let i = 0, l = arrays.length; i<l; i++)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function areEqual<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction sort<T>(a:IArray<T>, comparer:Comparison<T>):IArray<T>\r\n{\r\n\tif(!a || a.length<2) return a;\r\n\r\n\tvar len = a.length, b:T[];\r\n\tif(len>65536)\r\n\t\tb = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tb[i] = a[i];\r\n\t}\r\n\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T extends Primitive>(a:IArray<T>, b:IArray<T>):boolean;\r\nexport function areEquivalent<T>(a:IArray<IComparable<T>>, b:IArray<IComparable<T>>):boolean;\r\nexport function areEquivalent<T>(a:IArray<T>, b:IArray<T>, comparer:Comparison<T>):boolean;\r\nexport function areEquivalent<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = sort(a, comparer);\r\n\tb = sort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n"]}