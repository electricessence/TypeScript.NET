{"version":3,"sources":["System/Collections/Array/Sort.js","System/Collections/Array/Sort.ts"],"names":[],"mappings":";;;;AAIA;;ACEA,IAAA,UAAA,QAAmB,aAAnB,CAAA;AACA,IAAA,YAAA,QAAsB,eAAtB,CAAA;AAMA,SAAA,WAAA,CAAwB,KAAxB,EAAmC;AAElC,WAAO,MAAM,OAAN,CAAc,KAAd,IACC,KADD,GAEJ,CAAI,KAAJ,CAFI,CAF2B;CAAnC;AA8BA,SAAA,cAAA,CACC,QADD,EAG0B;QADzB,8DAAwB,iBACC;QAAzB,wEAAsB,mBAAG;;AAEzB,QAAI,mBAAmB,CAAC,QAAA,IAAA,CAAK,SAAL,CAAe,eAAf,CAAD,CAFE;AAIzB,WAAO,UAAC,CAAD,EAAsB,CAAtB,EAAyC;AAG/C,YAAI,SAAS,YAAY,SAAS,CAAT,CAAZ,CAAT,CAH2C;AAI/C,YAAI,SAAS,YAAY,SAAS,CAAT,CAAZ,CAAT,CAJ2C;AAK/C,YAAI,MAAM,KAAK,GAAL,CAAS,OAAO,MAAP,EAAe,OAAO,MAAP,CAA9B,CAL2C;AAO/C,YAAI,SAAiB,MAAM,OAAN,CAAc,KAAd,IAAuB,KAAvB,GAA+B,IAA/B,CAP0B;AAQ/C,aAAI,IAAI,IAAI,CAAJ,EAAO,IAAE,GAAF,EAAO,GAAtB,EACA;AACC,gBAAI,KAAK,OAAO,CAAP,CAAL;gBAAgB,KAAK,OAAO,CAAP,CAAL;gBAChB,IAAqB,SACjB,IAAE,OAAO,MAAP,GAAgB,OAAO,CAAP,CAAlB,GAA8B,CAA9B,GACM,KAFW,CAF1B;AAMC,gBAAG,gBAAH,EACA;AACC,oBAAG,QAAA,IAAA,CAAK,SAAL,CAAe,EAAf,CAAH,EACC,KAAK,eAAL,CADD;AAEA,oBAAG,QAAA,IAAA,CAAK,SAAL,CAAe,EAAf,CAAH,EACC,KAAK,eAAL,CADD;aAJD;AASA,gBAAI,IAAI,UAAA,OAAA,CAAQ,EAAR,EAAY,EAAZ,CAAJ,CAfL;AAgBC,gBAAG,MAAI,CAAJ,EACF,OAAO,IAAE,CAAF,CADR;SAjBD;AAsBA,eAAO,CAAP,CA9B+C;KAAzC,CAJkB;CAH1B;AAAgB,QAAA,cAAA,GAAc,cAAd;AA0CG,QAAA,OAAA,GAAO,cAAP;AACA,QAAA,EAAA,GAAE,cAAF","file":"System/Collections/Array/Sort.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Types_1 = require(\"../../Types\");\nconst Compare_1 = require(\"../../Compare\");\nfunction ensureArray(value) {\n    return Array.isArray(value)\n        ? value\n        : [value];\n}\nfunction createComparer(selector, order = 1, equivalentToNaN = NaN) {\n    var nanHasEquivalent = !Types_1.Type.isTrueNaN(equivalentToNaN);\n    return (a, b) => {\n        var aValue = ensureArray(selector(a));\n        var bValue = ensureArray(selector(b));\n        var len = Math.min(aValue.length, bValue.length);\n        var oArray = Array.isArray(order) ? order : null;\n        for (let i = 0; i < len; i++) {\n            var vA = aValue[i], vB = bValue[i], o = oArray\n                ? (i < oArray.length ? oArray[i] : 1)\n                : order;\n            if (nanHasEquivalent) {\n                if (Types_1.Type.isTrueNaN(vA))\n                    vA = equivalentToNaN;\n                if (Types_1.Type.isTrueNaN(vB))\n                    vB = equivalentToNaN;\n            }\n            var r = Compare_1.compare(vA, vB);\n            if (r !== 0)\n                return o * r;\n        }\n        return 0;\n    };\n}\nexports.createComparer = createComparer;\nexports.default = createComparer;\nexports.by = createComparer;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport {Type} from \"../../Types\";\r\nimport {compare} from \"../../Compare\";\r\nimport {Primitive} from \"../../Primitive\";\r\nimport {Selector, Comparison} from \"../../FunctionTypes\";\r\nimport {CompareResult} from \"../../CompareResult\";\r\nimport {Order} from \"../Sorting/Order\";\r\n\r\nfunction ensureArray<T>(value:T|T[]):T[]\r\n{\r\n\treturn Array.isArray(value)\r\n\t\t? <T[]>value\r\n\t\t: [<T>value];\r\n}\r\n\r\n/**\r\n * A factory function that creates a comparer to be used in multi-dimensional sorting.\r\n *\r\n * <h4>Example</h4>\r\n * ```typescript\r\n * var myArray = [{a:1:b:2},{a:3,b:4},{a:1,b:3}];\r\n *\r\n * // First sort by a, then by b.\r\n * myArray.sort(\r\n *   createComparer(\r\n *     (e)=> [e.a, e.b],\r\n *     [Order.Ascending, Order.Descending]\r\n *   )\r\n * );\r\n *\r\n * // result: [{a:1,b:3},{a:1:b:2},{a:3,b:4}]\r\n * ```\r\n *\r\n * @param selector\r\n * @param order\r\n * @param equivalentToNaN\r\n * @returns {function((TSource|TSource[]), (TSource|TSource[])): CompareResult}\r\n */\r\nexport function createComparer<TSource,TSelect extends Primitive>(\r\n\tselector:Selector<TSource|TSource[],TSelect>,\r\n\torder:Order | Order[] = Order.Ascending,\r\n\tequivalentToNaN:any = NaN):Comparison<TSource|TSource[]>\r\n{\r\n\tvar nanHasEquivalent = !Type.isTrueNaN(equivalentToNaN);\r\n\r\n\treturn (a:TSource|TSource[], b:TSource|TSource[]):CompareResult=>\r\n\t{\r\n\t\t// Use an array always to ensure a single code path.\r\n\t\tvar aValue = ensureArray(selector(a));\r\n\t\tvar bValue = ensureArray(selector(b));\r\n\t\tvar len = Math.min(aValue.length, bValue.length);\r\n\r\n\t\tvar oArray:Order[] = Array.isArray(order) ? order : null;\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar vA = aValue[i], vB = bValue[i],\r\n\t\t\t    o                  = oArray\r\n\t\t\t\t    ? (i<oArray.length ? oArray[i] : Order.Ascending)\r\n\t\t\t\t    : <Order>order;\r\n\r\n\t\t\tif(nanHasEquivalent)\r\n\t\t\t{\r\n\t\t\t\tif(Type.isTrueNaN(vA))\r\n\t\t\t\t\tvA = equivalentToNaN;\r\n\t\t\t\tif(Type.isTrueNaN(vB))\r\n\t\t\t\t\tvB = equivalentToNaN;\r\n\r\n\t\t\t}\r\n\r\n\t\t\tvar r = compare(vA, vB);\r\n\t\t\tif(r!==CompareResult.Equal)\r\n\t\t\t\treturn o*r;\r\n\r\n\t\t}\r\n\r\n\t\treturn 0;\r\n\t};\r\n}\r\n\r\nexport {\r\n\tcreateComparer as default, // Allow for default import.\r\n\tcreateComparer as by // Alias for Sort.by(...) instead of Sort.createComparer\r\n}\r\n"]}