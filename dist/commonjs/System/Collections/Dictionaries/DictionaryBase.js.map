{"version":3,"sources":["System/Collections/Dictionaries/DictionaryBase.js","System/Collections/Dictionaries/DictionaryBase.ts"],"names":[],"mappings":"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","file":"System/Collections/Dictionaries/DictionaryBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Compare_1 = require(\"../../Compare\");\nconst Enumerator_1 = require(\"../Enumeration/Enumerator\");\nconst CollectionBase_1 = require(\"../CollectionBase\");\nconst EnumeratorBase_1 = require(\"../Enumeration/EnumeratorBase\");\nconst ArgumentNullException_1 = require(\"../../Exceptions/ArgumentNullException\");\nconst InvalidOperationException_1 = require(\"../../Exceptions/InvalidOperationException\");\nconst KeyValueExtract_1 = require(\"../../KeyValueExtract\");\nconst extends_1 = require(\"../../../extends\");\nconst __extends = extends_1.default;\nconst VOID0 = void (0);\nclass DictionaryBase extends CollectionBase_1.CollectionBase {\n    constructor(source) {\n        super(source);\n    }\n    _onValueModified(key, value, old) {\n    }\n    _addInternal(item) {\n        if (!item)\n            throw new ArgumentNullException_1.ArgumentNullException('item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.');\n        return KeyValueExtract_1.extractKeyValue(item, (key, value) => this.addByKeyValue(key, value));\n    }\n    _clearInternal() {\n        var _ = this, count = 0;\n        for (let key of _.keys) {\n            if (_.removeByKey(key))\n                count++;\n        }\n        return count;\n    }\n    contains(item) {\n        if (!item || !this.getCount())\n            return false;\n        return KeyValueExtract_1.extractKeyValue(item, (key, value) => {\n            let v = this.getValue(key);\n            return Compare_1.areEqual(value, v);\n        });\n    }\n    _removeInternal(item) {\n        if (!item)\n            return 0;\n        return KeyValueExtract_1.extractKeyValue(item, (key, value) => {\n            let v = this.getValue(key);\n            return (Compare_1.areEqual(value, v) && this.removeByKey(key))\n                ? 1 : 0;\n        });\n    }\n    get keys() { return this.getKeys(); }\n    get values() { return this.getValues(); }\n    addByKeyValue(key, value) {\n        if (value === VOID0)\n            throw new InvalidOperationException_1.InvalidOperationException(\"Cannot add 'undefined' as a value.\");\n        var _ = this;\n        if (_.containsKey(key)) {\n            var ex = new InvalidOperationException_1.InvalidOperationException(\"Adding a key/value when the key already exists.\");\n            ex.data['key'] = key;\n            ex.data['value'] = value;\n            throw ex;\n        }\n        return _.setValue(key, value);\n    }\n    setValue(key, value) {\n        var _ = this;\n        _.assertModifiable();\n        var changed = false, old = _.getValue(key);\n        if (!Compare_1.areEqual(value, old) && _._setValueInternal(key, value)) {\n            changed = true;\n            _._onValueModified(key, value, old);\n        }\n        _._signalModification(changed);\n        return changed;\n    }\n    containsKey(key) {\n        return !!this._getEntry(key);\n    }\n    containsValue(value) {\n        var e = this.getEnumerator(), equal = Compare_1.areEqual;\n        while (e.moveNext()) {\n            if (equal(e.current, value, true)) {\n                e.dispose();\n                return true;\n            }\n        }\n        return false;\n    }\n    removeByKey(key) {\n        return this.setValue(key, VOID0);\n    }\n    removeByValue(value) {\n        var _ = this, count = 0, equal = Compare_1.areEqual;\n        for (let key of _.getKeys()) {\n            if (equal(_.getValue(key), value, true)) {\n                _.removeByKey(key);\n                count++;\n            }\n        }\n        return count;\n    }\n    importEntries(pairs) {\n        return super.importEntries(pairs);\n    }\n    _importEntries(pairs) {\n        var _ = this;\n        if (!pairs)\n            return 0;\n        let changed = 0;\n        Enumerator_1.forEach(pairs, pair => KeyValueExtract_1.extractKeyValue(pair, (key, value) => {\n            if (_._setValueInternal(key, value))\n                changed++;\n        }));\n        return changed;\n    }\n    getEnumerator() {\n        var _ = this;\n        var ver, keys, len, i = 0;\n        return new EnumeratorBase_1.EnumeratorBase(() => {\n            ver = _._version;\n            keys = _.getKeys();\n            len = keys.length;\n        }, (yielder) => {\n            _.assertVersion(ver);\n            while (i < len) {\n                var key = keys[i++], value = _.getValue(key);\n                if (value !== VOID0)\n                    return yielder.yieldReturn({ key: key, value: value });\n            }\n            return yielder.yieldBreak();\n        });\n    }\n}\nexports.DictionaryBase = DictionaryBase;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = DictionaryBase;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport {areEqual} from \"../../Compare\";\r\nimport {forEach} from \"../Enumeration/Enumerator\";\r\nimport {CollectionBase} from \"../CollectionBase\";\r\nimport {EnumeratorBase} from \"../Enumeration/EnumeratorBase\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {InvalidOperationException} from \"../../Exceptions/InvalidOperationException\";\r\nimport {extractKeyValue} from \"../../KeyValueExtract\";\r\nimport {IKeyValuePair, KeyValuePair} from \"../../KeyValuePair\";\r\nimport {IDictionary} from \"./IDictionary\";\r\nimport {IEnumerator} from \"../Enumeration/IEnumerator\";\r\nimport {IEnumerableOrArray} from \"../IEnumerableOrArray\";\r\nimport __extendsImport from \"../../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void(0);\r\n\r\n// Design Note: Should DictionaryAbstractBase be IDisposable?\r\nexport abstract class DictionaryBase<TKey, TValue>\r\nextends CollectionBase<IKeyValuePair<TKey,TValue>> implements IDictionary<TKey, TValue>\r\n{\r\n\tconstructor(source?:IEnumerableOrArray<IKeyValuePair<TKey,TValue>>)\r\n\t{\r\n\t\tsuper(source);\r\n\t}\r\n\r\n\r\n\tprotected _onValueModified(key:TKey, value:TValue, old:TValue):void\r\n\t{\r\n\t}\r\n\r\n\tprotected _addInternal(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\tif(!item)\r\n\t\t\tthrow new ArgumentNullException(\r\n\t\t\t\t'item', 'Dictionaries must use a valid key/value pair. \\'' + item + '\\' is not allowed.'\r\n\t\t\t);\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>this.addByKeyValue(key, value));\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tvar _ = this, count = 0;\r\n\r\n\t\tfor(let key of _.keys)\r\n\t\t{\r\n\t\t\tif(_.removeByKey(key)) count++;\r\n\t\t}\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\tcontains(item:KeyValuePair<TKey, TValue>):boolean\r\n\t{\r\n\t\t// Should never have a null object in the collection.\r\n\t\tif(!item || !this.getCount()) return false;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn areEqual(value, v);\r\n\t\t\t});\r\n\r\n\t}\r\n\r\n\tprotected _removeInternal(item:IKeyValuePair<TKey, TValue>|[TKey,TValue]):number\r\n\t{\r\n\t\tif(!item) return 0;\r\n\r\n\t\treturn extractKeyValue(item,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\t// Leave as variable for debugging...\r\n\t\t\t\tlet v = this.getValue(key);\r\n\t\t\t\treturn (areEqual(value, v) && this.removeByKey(key))\r\n\t\t\t\t\t? 1 : 0;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/////////////////////////////////////////\r\n\t// IDictionary<TKey,TValue>\r\n\t/////////////////////////////////////////\r\n\r\n\tprotected abstract getKeys():TKey[];\r\n\r\n\tget keys():TKey[] { return this.getKeys(); }\r\n\r\n\tprotected abstract getValues():TValue[];\r\n\r\n\tget values():TValue[] { return this.getValues(); }\r\n\r\n\r\n\taddByKeyValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\tif(value===VOID0)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot add 'undefined' as a value.\");\r\n\r\n\t\tvar _ = this;\r\n\t\tif(_.containsKey(key))\r\n\t\t{\r\n\t\t\tvar ex = new InvalidOperationException(\"Adding a key/value when the key already exists.\");\r\n\t\t\tex.data['key'] = key;\r\n\t\t\tex.data['value'] = value;\r\n\t\t\tthrow ex;\r\n\t\t}\r\n\r\n\t\treturn _.setValue(key, value);\r\n\t}\r\n\r\n\tprotected abstract _getEntry(key:TKey):IKeyValuePair<TKey,TValue>;\r\n\r\n\tabstract getValue(key:TKey):TValue;\r\n\r\n\tprotected abstract _setValueInternal(key:TKey, value:TValue):boolean;\r\n\r\n\tsetValue(key:TKey, value:TValue):boolean\r\n\t{\r\n\t\t// setValue shouldn't need to worry about recursion...\r\n\t\tvar _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tvar changed = false, old = _.getValue(key); // get the old value here and pass to internal.\r\n\t\tif(!areEqual(value, old) && _._setValueInternal(key, value))\r\n\t\t{\r\n\t\t\tchanged = true;\r\n\t\t\t_._onValueModified(key, value, old)\r\n\t\t}\r\n\r\n\t\t_._signalModification(changed);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tcontainsKey(key:TKey):boolean\r\n\t{\r\n\t\treturn !!this._getEntry(key);\r\n\t}\r\n\r\n\tcontainsValue(value:TValue):boolean\r\n\t{\r\n\t\tvar e = this.getEnumerator(), equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\r\n\t\twhile(e.moveNext())\r\n\t\t{\r\n\t\t\tif(equal(e.current, value, true))\r\n\t\t\t{\r\n\t\t\t\te.dispose();\r\n\t\t\t\treturn true;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tremoveByKey(key:TKey):boolean\r\n\t{\r\n\t\treturn this.setValue(key, VOID0);\r\n\t}\r\n\r\n\tremoveByValue(value:TValue):number\r\n\t{\r\n\t\tvar _ = this, count = 0, equal:(a:any, b:any, strict?:boolean) => boolean = areEqual;\r\n\t\tfor(let key of _.getKeys())\r\n\t\t{\r\n\t\t\tif(equal(_.getValue(key), value, true))\r\n\t\t\t{\r\n\t\t\t\t_.removeByKey(key);\r\n\t\t\t\tcount++;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn count;\r\n\t}\r\n\r\n\timportEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>):number\r\n\t{\r\n\t\t// Allow piping through to trigger onModified properly.\r\n\t\treturn super.importEntries(<any>pairs);\r\n\t}\r\n\r\n\tprotected _importEntries(pairs:IEnumerableOrArray<KeyValuePair<TKey, TValue>>):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tif(!pairs) return 0;\r\n\t\tlet changed:number = 0;\r\n\t\tforEach(pairs,\r\n\t\t\tpair=>extractKeyValue(pair, (key, value)=>\r\n\t\t\t{\r\n\t\t\t\tif(_._setValueInternal(key, value))\r\n\t\t\t\t\tchanged++;\r\n\t\t\t})\r\n\t\t);\r\n\t\treturn changed;\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<IKeyValuePair<TKey, TValue>>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar ver:number, keys:TKey[], len:number, i = 0;\r\n\t\treturn new EnumeratorBase<IKeyValuePair<TKey, TValue>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tver = _._version; // Track the version since getKeys is a copy.\r\n\t\t\t\tkeys = _.getKeys();\r\n\t\t\t\tlen = keys.length;\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\t_.assertVersion(ver);\r\n\r\n\t\t\t\twhile(i<len)\r\n\t\t\t\t{\r\n\t\t\t\t\tvar key = keys[i++], value = _.getValue(key);\r\n\t\t\t\t\tif(value!==VOID0) // Still valid?\r\n\t\t\t\t\t\treturn yielder.yieldReturn({key: key, value: value});\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport default DictionaryBase;"]}