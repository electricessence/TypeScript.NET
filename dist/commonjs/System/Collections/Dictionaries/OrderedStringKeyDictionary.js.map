{"version":3,"sources":["System/Collections/Dictionaries/OrderedStringKeyDictionary.js","System/Collections/Dictionaries/OrderedStringKeyDictionary.ts"],"names":[],"mappings":";;;;AAIA;;;;;;;;;;;;ACCA,IAAY,eAAY,QAAM,kBAAN,CAAZ;AACZ,IAAA,wBAAA,QAAkC,uBAAlC,CAAA;AACA,IAAA,gCAAA,QAA0C,8CAA1C,CAAA;AAEA,IAAA,YAAA,QAA4B,kBAA5B,CAAA;AACA,IAAM,YAAY,UAAA,OAAA;AAElB,IAAM,QAAY,KAAK,CAAL;;IAElB;;;AAOC,0CAAA;;;;;AAFQ,cAAA,MAAA,GAAkB,EAAlB,CAER;;KAAA;;;;mCAKW,KAAU;AAEpB,gBAAI,IAAI,KAAK,MAAL,CAFY;AAGpB,mBAAO,EAAE,MAAF,GAAW,EAAE,OAAF,CAAU,GAAV,EAAe,CAAf,CAAX,GAA+B,CAAC,CAAD,CAHlB;;;;wCAML,OAAY;AAE3B,gBAAI,IAAI,KAAK,MAAL,CAFmB;AAG3B,mBAAO,QAAM,EAAE,MAAF,GAAW,KAAK,QAAL,CAAc,EAAE,KAAF,CAAd,CAAjB,GAA2C,KAA3C,CAHoB;;;;iCAOnB,KAAY,OAAc,WAAkB;AAGpD,gBAAI,IAAI,IAAJ;gBAAU,SAAS,EAAE,UAAF,CAAa,GAAb,KAAoB,CAAC,CAAD,CAHS;AAIpD,gBAAG,CAAC,MAAD,KAAY,UAAQ,KAAR,IAAiB,SAAjB,CAAZ,EACF,EAAE,MAAF,CAAS,IAAT,CAAc,GAAd,EADD,KAEK,IAAG,UAAU,UAAQ,KAAR,IAAiB,CAAC,SAAD,EAClC,aAAa,MAAb,CAAoB,EAAE,MAAF,EAAU,GAA9B,EADI;AAGL,kHAAsB,KAAK,MAA3B,CAToD;;;;mCAY1C,OAAc,OAAY;AAEpC,gBAAI,IAAI,IAAJ;gBAAU,QAAQ,EAAE,MAAF,CAFc;AAGpC,gBAAG,QAAM,CAAN,EACF,MAAM,IAAI,8BAAA,2BAAA,CAA4B,OAAhC,EAAyC,KAAzC,EAAgD,oBAAhD,CAAN,CADD;AAEA,gBAAG,SAAO,MAAM,MAAN,EACT,MAAM,IAAI,8BAAA,2BAAA,CAA4B,OAAhC,EAAyC,KAAzC,EAAgD,4BAAhD,CAAN,CADD;AAEA,mBAAO,EAAE,QAAF,CAAW,MAAM,KAAN,CAAX,EAAyB,KAAzB,CAAP,CAPoC;;;;qCAWxB,QAAe;AAE3B,gBAAI,IAAI,IAAJ,CAFuB;AAG3B,mBAAO,EAAE,YAAF,CACN,YAAA;AAEC,oBAAI,UAAkB,KAAlB,CAFL;AAGC,qBAAI,IAAI,IAAI,CAAJ,EAAO,IAAE,OAAO,MAAP,EAAe,GAAhC,EACA;AACC,wBAAG,EAAE,UAAF,CAAa,CAAb,EAAgB,OAAO,CAAP,CAAhB,CAAH,EACC,UAAU,IAAV,CADD;iBAFD;AAKA,uBAAO,OAAP,CARD;aAAA,CADD,CAH2B;;;;oCAmBA;8CAAf;;aAAe;;AAE3B,mBAAO,KAAK,YAAL,CAAkB,MAAlB,CAAP,CAF2B;;;;sCAKd,OAAY;AAEzB,mBAAO,KAAK,UAAL,CAAgB,KAAhB,EAAuB,KAAvB,CAAP,CAFyB;;;;kCAKT;AAEhB,gBAAI,IAAI,IAAJ;gBAAU,IAAI,EAAE,MAAF,CAFF;AAGhB,mBAAO,EAAE,MAAF,IAAY,EAAE,MAAF,CAAS;uBAAM,EAAE,WAAF,CAAc,GAAd;aAAN,CAArB,IAAkD,EAAlD,CAHS;;;;;EA5EV,sBAAA,mBAAA;;AADK,QAAA,0BAAA,GAA0B,0BAA1B;AAqFb,OAAA,cAAA,CAAA,OAAA,EAAA,YAAA,EAAA,EAAA,OAAA,IAAA,EAAA;ADnCA,QAAQ,OAAR,GCmCe,0BDnCf","file":"System/Collections/Dictionaries/OrderedStringKeyDictionary.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst ArrayUtility = require(\"../Array/Utility\");\nconst StringKeyDictionary_1 = require(\"./StringKeyDictionary\");\nconst ArgumentOutOfRangeException_1 = require(\"../../Exceptions/ArgumentOutOfRangeException\");\nconst extends_1 = require(\"../../../extends\");\nconst __extends = extends_1.default;\nconst VOID0 = void 0;\nclass OrderedStringKeyDictionary extends StringKeyDictionary_1.StringKeyDictionary {\n    constructor() {\n        super();\n        this._order = [];\n    }\n    indexOfKey(key) {\n        var o = this._order;\n        return o.length ? o.indexOf(key, 0) : -1;\n    }\n    getValueByIndex(index) {\n        var o = this._order;\n        return index < o.length ? this.getValue(o[index]) : VOID0;\n    }\n    setValue(key, value, keepIndex) {\n        var _ = this, exists = _.indexOfKey(key) != -1;\n        if (!exists && (value !== VOID0 || keepIndex))\n            _._order.push(key);\n        else if (exists && value === VOID0 && !keepIndex)\n            ArrayUtility.remove(_._order, key);\n        return super.setValue(key, value);\n    }\n    setByIndex(index, value) {\n        var _ = this, order = _._order;\n        if (index < 0)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('index', index, 'Is less than zero.');\n        if (index >= order.length)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('index', index, 'Is greater than the count.');\n        return _.setValue(order[index], value);\n    }\n    importValues(values) {\n        var _ = this;\n        return _.handleUpdate(() => {\n            var changed = false;\n            for (let i = 0; i < values.length; i++) {\n                if (_.setByIndex(i, values[i]))\n                    changed = true;\n            }\n            return changed;\n        });\n    }\n    setValues(...values) {\n        return this.importValues(values);\n    }\n    removeByIndex(index) {\n        return this.setByIndex(index, VOID0);\n    }\n    getKeys() {\n        var _ = this, o = _._order;\n        return o.length && o.filter(key => _.containsKey(key)) || [];\n    }\n}\nexports.OrderedStringKeyDictionary = OrderedStringKeyDictionary;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = OrderedStringKeyDictionary;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as ArrayUtility from \"../Array/Utility\";\r\nimport {StringKeyDictionary} from \"./StringKeyDictionary\";\r\nimport {ArgumentOutOfRangeException} from \"../../Exceptions/ArgumentOutOfRangeException\";\r\nimport {IOrderedDictionary} from \"./IDictionary\";\r\nimport __extendsImport from \"../../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void 0;\r\n\r\nexport class OrderedStringKeyDictionary<TValue>\r\nextends StringKeyDictionary<TValue> implements IOrderedDictionary<string, TValue>\r\n{\r\n\r\n\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\tprivate _order:string[] = []; // Maintains indexes.\r\n\r\n\tconstructor()\r\n\t{\r\n\t\tsuper();\r\n\t}\r\n\r\n\tindexOfKey(key:string):number\r\n\t{\r\n\t\tvar o = this._order;\r\n\t\treturn o.length ? o.indexOf(key, 0) : -1;\r\n\t}\r\n\r\n\tgetValueByIndex(index:number):TValue\r\n\t{\r\n\t\tvar o = this._order;\r\n\t\treturn index<o.length ? this.getValue(o[index]) : VOID0;\r\n\t}\r\n\r\n\t// adding keepIndex allows for clearing a value while still retaining it's index.\r\n\tsetValue(key:string, value:TValue, keepIndex?:boolean):boolean\r\n\t{\r\n\t\t// TODO: This may be inefficient and could be improved.\r\n\t\tvar _ = this, exists = _.indexOfKey(key)!= -1;\r\n\t\tif(!exists && (value!==VOID0 || keepIndex))\r\n\t\t\t_._order.push(key);\r\n\t\telse if(exists && value===VOID0 && !keepIndex)\r\n\t\t\tArrayUtility.remove(_._order, key);\r\n\r\n\t\treturn super.setValue(key, value);\r\n\t}\r\n\r\n\tsetByIndex(index:number, value:TValue):boolean\r\n\t{\r\n\t\tvar _ = this, order = _._order;\r\n\t\tif(index<0)\r\n\t\t\tthrow new ArgumentOutOfRangeException('index', index, 'Is less than zero.');\r\n\t\tif(index>=order.length)\r\n\t\t\tthrow new ArgumentOutOfRangeException('index', index, 'Is greater than the count.');\r\n\t\treturn _.setValue(order[index], value);\r\n\t}\r\n\r\n\t// importValues([x,y,z]);\r\n\timportValues(values:TValue[]):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\treturn _.handleUpdate(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar changed:boolean = false;\r\n\t\t\t\tfor(let i = 0; i<values.length; i++)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(_.setByIndex(i, values[i]))\r\n\t\t\t\t\t\tchanged = true;\r\n\t\t\t\t}\r\n\t\t\t\treturn changed;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t}\r\n\r\n\t// setValues(x,y,z);\r\n\tsetValues(...values:TValue[]):boolean\r\n\t{\r\n\t\treturn this.importValues(values);\r\n\t}\r\n\r\n\tremoveByIndex(index:number):boolean\r\n\t{\r\n\t\treturn this.setByIndex(index, VOID0);\r\n\t}\r\n\r\n\tprotected getKeys():string[]\r\n\t{\r\n\t\tvar _ = this, o = _._order;\r\n\t\treturn o.length && o.filter(key=> _.containsKey(key)) || [];\r\n\t}\r\n\r\n}\r\n\r\nexport default OrderedStringKeyDictionary;\r\n"]}