{"version":3,"sources":["System/Promises/LazyPromise.js","System/Promises/LazyPromise.ts"],"names":[],"mappings":"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","file":"System/Promises/LazyPromise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n\"use strict\";\nconst Promise_1 = require(\"./Promise\");\nconst defer_1 = require(\"../Threading/defer\");\nconst ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\nconst extends_1 = require(\"../../extends\");\nconst __extends = extends_1.default;\nconst VOID0 = void 0;\nclass LazyPromise extends Promise_1.Promise {\n    constructor(_resolver) {\n        super();\n        this._resolver = _resolver;\n        if (!_resolver)\n            throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n        this._resolvedCalled = true;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._resolver = VOID0;\n    }\n    _onThen() {\n        var r = this._resolver;\n        if (r) {\n            this._resolver = VOID0;\n            this._resolvedCalled = false;\n            this.resolveUsing(r);\n        }\n    }\n    thenSynchronous(onFulfilled, onRejected) {\n        this._onThen();\n        return super.thenSynchronous(onFulfilled, onRejected);\n    }\n    thenThis(onFulfilled, onRejected) {\n        this._onThen();\n        return super.thenThis(onFulfilled, onRejected);\n    }\n    delayFromNow(milliseconds = 0) {\n        this.throwIfDisposed();\n        if (!this._resolver || this.isSettled)\n            return super.delayFromNow(milliseconds);\n        var pass;\n        var timedOut = false;\n        var timeout = defer_1.defer(() => {\n            timedOut = true;\n            if (pass)\n                pass();\n        }, milliseconds);\n        return new LazyPromise((resolve, reject) => {\n            pass = () => {\n                this.thenThis(v => resolve(v), e => reject(e));\n                timeout.dispose();\n                timeout = null;\n                pass = null;\n            };\n            if (timedOut)\n                pass();\n        });\n    }\n    delayAfterResolve(milliseconds = 0) {\n        this.throwIfDisposed();\n        if (!this._resolver || this.isSettled)\n            return super.delayAfterResolve(milliseconds);\n        var pass;\n        var timeout;\n        var finalize = () => {\n            if (timeout) {\n                timeout.dispose();\n                timeout = null;\n            }\n            if (pass)\n                pass();\n            finalize = null;\n        };\n        {\n            let detector = () => {\n                if (finalize)\n                    timeout = defer_1.defer(finalize, milliseconds);\n            };\n            super.thenThis(detector, detector);\n            detector = null;\n        }\n        return new LazyPromise((resolve, reject) => {\n            if (this.isPending) {\n                this.thenThis(v => defer_1.defer(() => resolve(v), milliseconds), e => defer_1.defer(() => reject(e), milliseconds));\n                finalize();\n            }\n            else {\n                pass = () => {\n                    this.thenThis(v => resolve(v), e => reject(e));\n                };\n                if (!finalize)\n                    pass();\n            }\n        });\n    }\n}\nexports.LazyPromise = LazyPromise;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = LazyPromise;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Promise, PromiseBase} from \"./Promise\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ICancellable} from \"../Threading/ICancellable\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport __extendsImport from \"../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r);\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenSynchronous(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t// NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a minimum delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayFromNow(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\t\tvar timedOut:boolean = false;\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout = defer(()=>\r\n\t\t\t{\r\n\t\t\t\ttimedOut = true;\r\n\t\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(pass)\r\n\t\t\t\t\tpass();\r\n\t\t\t},\r\n\t\t\tmilliseconds);\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// A lazy promise only enters here if something called for a resolution.\r\n\t\t\t\tpass = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\ttimeout.dispose();\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t\tpass = null;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If the timeout completed already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(timedOut)\r\n\t\t\t\t\tpass();\r\n\t\t\t\t// Otherwise wait for the timeout to do it.\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayAfterResolve(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout:ICancellable;\r\n\r\n\t\tvar finalize = ()=>\r\n\t\t{\r\n\t\t\tif(timeout)\r\n\t\t\t{\r\n\t\t\t\ttimeout.dispose();\r\n\t\t\t\ttimeout = null;\r\n\t\t\t}\r\n\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\tif(pass)\r\n\t\t\t\tpass();\r\n\r\n\t\t\tfinalize = null;\r\n\t\t};\r\n\r\n\t\t{\r\n\t\t\tlet detector = ()=>\r\n\t\t\t{\r\n\t\t\t\tif(finalize) // We may already be wrapped up so never mind!\r\n\t\t\t\t\ttimeout = defer(finalize, milliseconds);\r\n\t\t\t};\r\n\r\n\t\t\t// Calling super.thenThis does not trigger resolution.\r\n\t\t\t// This simply waits for resolution to happen.\r\n\t\t\t// Is effectively the timer by when resolution has occurred.\r\n\t\t\tsuper.thenThis(detector, detector);\r\n\t\t\tdetector = null;\r\n\t\t}\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// Because of the lazy nature of this promise, this could enter here at any time.\r\n\t\t\t\tif(this.isPending)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\t\te=> defer(()=>reject(e), milliseconds)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// We don't know when this resolved and could have happened anytime after calling this delay method.\r\n\t\t\t\t\tpass = ()=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Already finalized (aka resolved after a timeout)? Go now!\r\n\t\t\t\t\tif(!finalize)\r\n\t\t\t\t\t\tpass();\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\r\nexport default LazyPromise;"]}