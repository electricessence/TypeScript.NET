{"version":3,"sources":["System/TypeValidator.js","System/TypeValidator.ts"],"names":[],"mappings":"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","file":"System/TypeValidator.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n\"use strict\";\nconst Types_1 = require(\"./Types\");\nconst Compare_1 = require(\"./Compare\");\nconst extends_1 = require(\"../extends\");\nconst __extends = extends_1.default;\nclass TypeInfoHelper extends Types_1.TypeInfo {\n    constructor(value) {\n        super(value, () => this._value = value);\n    }\n    contains(descriptor) {\n        let value = this._value;\n        if (value === descriptor)\n            return true;\n        switch (descriptor) {\n            case Function:\n                return this.isFunction;\n            case Object:\n                return this.isObject;\n            case Array:\n                return this.isArray;\n            case String:\n                return this.isString;\n            case Number:\n                return this.isNumber;\n            case Boolean:\n                return this.isBoolean;\n        }\n        if (this.type != typeof descriptor || this.isPrimitive && !Compare_1.areEqual(value, descriptor))\n            return false;\n        if (this.isArray && Array.isArray(descriptor)) {\n            let max = Math.min(descriptor.length, value.length);\n            for (let i = 0; i < max; i++) {\n                if (areInvalid(value[i], descriptor[i]))\n                    return false;\n            }\n            return true;\n        }\n        if (this.isObject) {\n            let targetKeys = Object.keys(value);\n            let dKeys = Object.keys(descriptor);\n            if (dKeys.length > targetKeys.length)\n                return false;\n            for (let key of dKeys) {\n                if (targetKeys.indexOf(key) == -1)\n                    return false;\n            }\n            for (let key of dKeys) {\n                if (areInvalid(value[key], descriptor[key]))\n                    return false;\n            }\n        }\n        return true;\n    }\n}\nexports.TypeInfoHelper = TypeInfoHelper;\nfunction areInvalid(v, d) {\n    if (!Compare_1.areEqual(v, d)) {\n        let memberType = new TypeInfoHelper(v);\n        if (!memberType.contains(d))\n            return true;\n    }\n    return false;\n}\nclass TypeValidator {\n    constructor(_typeDescriptor) {\n        this._typeDescriptor = _typeDescriptor;\n        Object.freeze(this);\n    }\n    isSubsetOf(o) {\n        var t = new TypeInfoHelper(o);\n        return t.contains(this._typeDescriptor);\n    }\n}\nexports.TypeValidator = TypeValidator;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = TypeValidator;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\n/**\r\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\r\n *\r\n * var descriptor = {\r\n *      a : Object,\r\n *      b : String,\r\n *      c : {\r\n *          d : true ,\r\n *          e : Array,\r\n *          f : []\r\n *      },\r\n *      g : \"literal\"\r\n * }\r\n */\r\n\r\nimport {TypeInfo} from \"./Types\";\r\nimport {areEqual} from \"./Compare\";\r\nimport __extendsImport from \"../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\nexport class TypeInfoHelper extends TypeInfo\r\n{\r\n\r\n\tprivate _value:any;\r\n\r\n\tconstructor(value:any)\r\n\t{\r\n\t\tsuper(value, ()=>this._value = value);\r\n\r\n\t}\r\n\r\n\tcontains<TDescriptor>(descriptor:any):this is TDescriptor\r\n\t{\r\n\r\n\t\tlet value = this._value;\r\n\r\n\t\tif(value===descriptor)\r\n\t\t\treturn true;\r\n\r\n\t\tswitch(descriptor)\r\n\t\t{\r\n\t\t\tcase Function:\r\n\t\t\t\treturn this.isFunction;\r\n\t\t\tcase Object:\r\n\t\t\t\treturn this.isObject;\r\n\t\t\tcase Array:\r\n\t\t\t\treturn this.isArray;\r\n\t\t\tcase String:\r\n\t\t\t\treturn this.isString;\r\n\t\t\tcase Number:\r\n\t\t\t\treturn this.isNumber;\r\n\t\t\tcase Boolean:\r\n\t\t\t\treturn this.isBoolean;\r\n\t\t}\r\n\r\n\t\tif(this.type != typeof descriptor || this.isPrimitive && !areEqual(value,descriptor))\r\n\t\t\treturn false;\r\n\r\n\t\t// Check array contents and confirm intersections.\r\n\t\tif(this.isArray && Array.isArray(descriptor))\r\n\t\t{\r\n\t\t\tlet max = Math.min(descriptor.length, value.length);\r\n\r\n\t\t\tfor(let i = 0; i<max; i++)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[i], descriptor[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(this.isObject)\r\n\t\t{\r\n\t\t\tlet targetKeys = Object.keys(value);\r\n\t\t\tlet dKeys = Object.keys(descriptor);\r\n\r\n\t\t\t// Quick check...\r\n\t\t\tif(dKeys.length>targetKeys.length)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Quick check #2...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(targetKeys.indexOf(key)== -1)\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Final pass with recursive...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[key], descriptor[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction areInvalid(v:any, d:any)\r\n{\r\n\tif(!areEqual(v, d))\r\n\t{\r\n\t\tlet memberType = new TypeInfoHelper(v);\r\n\t\tif(!memberType.contains(d))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport class TypeValidator<T> {\r\n\tconstructor(private _typeDescriptor:any) {\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tisSubsetOf(o:any):o is T {\r\n\t\tvar t = new TypeInfoHelper(o);\r\n\t\treturn t.contains(this._typeDescriptor);\r\n\t}\r\n}\r\n\r\nexport default TypeValidator;\r\n\r\n"]}