{"version":3,"sources":["System.Linq/Linq.js","System.Linq/Linq.ts"],"names":[],"mappings":"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","file":"System.Linq/Linq.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n\"use strict\";\nconst Values = require(\"../System/Compare\");\nconst Arrays = require(\"../System/Collections/Array/Compare\");\nconst ArrayUtility = require(\"../System/Collections/Array/Utility\");\nconst Enumerator_1 = require(\"../System/Collections/Enumeration/Enumerator\");\nconst EmptyEnumerator_1 = require(\"../System/Collections/Enumeration/EmptyEnumerator\");\nconst Types_1 = require(\"../System/Types\");\nconst Integer_1 = require(\"../System/Integer\");\nconst Functions_1 = require(\"../System/Functions\");\nconst ArrayEnumerator_1 = require(\"../System/Collections/Enumeration/ArrayEnumerator\");\nconst EnumeratorBase_1 = require(\"../System/Collections/Enumeration/EnumeratorBase\");\nconst Dictionary_1 = require(\"../System/Collections/Dictionaries/Dictionary\");\nconst Queue_1 = require(\"../System/Collections/Queue\");\nconst dispose_1 = require(\"../System/Disposable/dispose\");\nconst DisposableBase_1 = require(\"../System/Disposable/DisposableBase\");\nconst UnsupportedEnumerableException_1 = require(\"../System/Collections/Enumeration/UnsupportedEnumerableException\");\nconst ObjectDisposedException_1 = require(\"../System/Disposable/ObjectDisposedException\");\nconst KeySortedContext_1 = require(\"../System/Collections/Sorting/KeySortedContext\");\nconst ArgumentNullException_1 = require(\"../System/Exceptions/ArgumentNullException\");\nconst ArgumentOutOfRangeException_1 = require(\"../System/Exceptions/ArgumentOutOfRangeException\");\nconst extends_1 = require(\"../extends\");\nconst __extends = extends_1.default;\nconst INVALID_DEFAULT = {};\nconst VOID0 = void 0;\nconst BREAK = element => 0;\nclass LinqFunctions extends Functions_1.Functions {\n    Greater(a, b) {\n        return a > b ? a : b;\n    }\n    Lesser(a, b) {\n        return a < b ? a : b;\n    }\n}\nvar Functions = new LinqFunctions();\nObject.freeze(Functions);\nfunction getEmptyEnumerator() {\n    return EmptyEnumerator_1.EmptyEnumerator;\n}\nclass InfiniteEnumerable extends DisposableBase_1.DisposableBase {\n    constructor(_enumeratorFactory, finalizer) {\n        super(finalizer);\n        this._enumeratorFactory = _enumeratorFactory;\n        this._isEndless = true;\n    }\n    get isEndless() {\n        return this._isEndless;\n    }\n    getEnumerator() {\n        this.throwIfDisposed();\n        return this._enumeratorFactory();\n    }\n    _onDispose() {\n        super._onDispose();\n        this._enumeratorFactory = null;\n    }\n    asEnumerable() {\n        var _ = this;\n        _.throwIfDisposed();\n        return new InfiniteEnumerable(() => _.getEnumerator());\n    }\n    doAction(action, initializer, isEndless = this.isEndless) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                if (initializer)\n                    initializer();\n                index = 0;\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                while (enumerator.moveNext()) {\n                    var actionResult = action(enumerator.current, index++);\n                    if (actionResult === false || actionResult === 0)\n                        return yielder.yieldBreak();\n                    if (actionResult !== 2)\n                        return yielder.yieldReturn(enumerator.current);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, isEndless);\n        }, () => {\n            disposed = true;\n        }, isEndless);\n    }\n    force() {\n        this.throwIfDisposed();\n        this.doAction(BREAK)\n            .getEnumerator()\n            .moveNext();\n    }\n    skip(count) {\n        var _ = this;\n        _.throwIfDisposed();\n        if (!isFinite(count))\n            return Enumerable.empty();\n        Integer_1.Integer.assert(count, \"count\");\n        return this.doAction((element, index) => index < count\n            ? 2\n            : 1);\n    }\n    take(count) {\n        if (!(count > 0))\n            return Enumerable.empty();\n        var _ = this;\n        _.throwIfDisposed();\n        if (!isFinite(count))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('count', count, 'Must be finite.');\n        Integer_1.Integer.assert(count, \"count\");\n        return _.doAction((element, index) => index < count, null, false);\n    }\n    elementAt(index) {\n        var v = this.elementAtOrDefault(index, INVALID_DEFAULT);\n        if (v === INVALID_DEFAULT)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\n        return v;\n    }\n    elementAtOrDefault(index, defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        Integer_1.Integer.assertZeroOrGreater(index, 'index');\n        var n = index;\n        return dispose_1.using(this.getEnumerator(), e => {\n            var i = 0;\n            while (e.moveNext()) {\n                if (i == n)\n                    return e.current;\n                i++;\n            }\n            return defaultValue;\n        });\n    }\n    first() {\n        var v = this.firstOrDefault(INVALID_DEFAULT);\n        if (v === INVALID_DEFAULT)\n            throw new Error(\"first:The sequence is empty.\");\n        return v;\n    }\n    firstOrDefault(defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        return dispose_1.using(this.getEnumerator(), e => e.moveNext() ? e.current : defaultValue);\n    }\n    single() {\n        var _ = this;\n        _.throwIfDisposed();\n        return dispose_1.using(this.getEnumerator(), e => {\n            if (e.moveNext()) {\n                var value = e.current;\n                if (!e.moveNext())\n                    return value;\n                throw new Error(\"single:sequence contains more than one element.\");\n            }\n            throw new Error(\"single:The sequence is empty.\");\n        });\n    }\n    singleOrDefault(defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        return dispose_1.using(this.getEnumerator(), e => {\n            if (e.moveNext()) {\n                var value = e.current;\n                if (!e.moveNext())\n                    return value;\n            }\n            return defaultValue;\n        });\n    }\n    any() {\n        var _ = this;\n        _.throwIfDisposed();\n        return dispose_1.using(this.getEnumerator(), e => e.moveNext());\n    }\n    isEmpty() {\n        return !this.any();\n    }\n    traverseBreadthFirst(childrenSelector, resultSelector = Functions.Identity) {\n        var _ = this, isEndless = _._isEndless || null;\n        return new Enumerable(() => {\n            var enumerator;\n            var nestLevel = 0;\n            var buffer, len;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                nestLevel = 0;\n                buffer = [];\n                len = 0;\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                while (true) {\n                    if (enumerator.moveNext()) {\n                        buffer[len++] = enumerator.current;\n                        return yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\n                    }\n                    if (!len)\n                        return yielder.yieldBreak();\n                    var next = Enumerable\n                        .from(buffer)\n                        .selectMany(childrenSelector);\n                    if (!next.any()) {\n                        return yielder.yieldBreak();\n                    }\n                    else {\n                        nestLevel++;\n                        buffer = [];\n                        len = 0;\n                        enumerator.dispose();\n                        enumerator = next.getEnumerator();\n                    }\n                }\n            }, () => {\n                dispose_1.dispose(enumerator);\n                buffer.length = 0;\n            }, isEndless);\n        }, null, isEndless);\n    }\n    traverseDepthFirst(childrenSelector, resultSelector = Functions.Identity) {\n        var _ = this, isEndless = _._isEndless || null;\n        return new Enumerable(() => {\n            var enumeratorStack = [];\n            var enumerator;\n            var len;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                len = 0;\n            }, (yielder) => {\n                while (true) {\n                    if (enumerator.moveNext()) {\n                        let value = resultSelector(enumerator.current, len);\n                        enumeratorStack[len++] = enumerator;\n                        let e = Enumerable.fromAny(childrenSelector(enumerator.current));\n                        enumerator = e ? e.getEnumerator() : EmptyEnumerator_1.EmptyEnumerator;\n                        return yielder.yieldReturn(value);\n                    }\n                    if (len == 0)\n                        return false;\n                    enumerator.dispose();\n                    enumerator = enumeratorStack[--len];\n                    enumeratorStack.length = len;\n                }\n            }, () => {\n                try {\n                    dispose_1.dispose(enumerator);\n                }\n                finally {\n                    dispose_1.dispose.these(enumeratorStack);\n                }\n            }, isEndless);\n        }, null, isEndless);\n    }\n    flatten() {\n        var _ = this, isEndless = _._isEndless || null;\n        return new Enumerable(() => {\n            var enumerator;\n            var middleEnumerator = null;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                while (true) {\n                    if (middleEnumerator) {\n                        if (middleEnumerator.moveNext()) {\n                            return yielder.yieldReturn(middleEnumerator.current);\n                        }\n                        else {\n                            middleEnumerator.dispose();\n                            middleEnumerator = null;\n                        }\n                    }\n                    if (enumerator.moveNext()) {\n                        var c = enumerator.current;\n                        var e = !Types_1.Type.isString(c) && Enumerable.fromAny(c);\n                        if (e) {\n                            middleEnumerator\n                                = e\n                                    .selectMany(Functions.Identity)\n                                    .flatten()\n                                    .getEnumerator();\n                            continue;\n                        }\n                        else {\n                            return yielder.yieldReturn(c);\n                        }\n                    }\n                    return yielder.yieldBreak();\n                }\n            }, () => {\n                dispose_1.dispose(enumerator, middleEnumerator);\n            }, isEndless);\n        }, null, isEndless);\n    }\n    pairwise(selector) {\n        var _ = this;\n        return new Enumerable(() => {\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                enumerator.moveNext();\n            }, (yielder) => {\n                var prev = enumerator.current;\n                return enumerator.moveNext()\n                    && yielder.yieldReturn(selector(prev, enumerator.current));\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    scan(func, seed) {\n        var isUseSeed = seed !== VOID0;\n        var _ = this;\n        return new Enumerable(() => {\n            var enumerator;\n            var value;\n            var isFirst;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                isFirst = true;\n            }, (yielder) => {\n                if (isFirst) {\n                    isFirst = false;\n                    return isUseSeed\n                        ? yielder.yieldReturn(value = seed)\n                        : enumerator.moveNext() && yielder.yieldReturn(value\n                            = enumerator.current);\n                }\n                return (enumerator.moveNext())\n                    ? yielder.yieldReturn(value = func(value, enumerator.current))\n                    : false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    select(selector) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                index = 0;\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                return enumerator.moveNext()\n                    ? yielder.yieldReturn(selector(enumerator.current, index++))\n                    : yielder.yieldBreak();\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, () => {\n            disposed = true;\n        }, _._isEndless);\n    }\n    _selectMany(collectionSelector, resultSelector) {\n        var _ = this, isEndless = _._isEndless || null;\n        if (!resultSelector)\n            resultSelector = (a, b) => b;\n        return new Enumerable(() => {\n            var enumerator;\n            var middleEnumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                middleEnumerator = undefined;\n                index = 0;\n            }, (yielder) => {\n                if (middleEnumerator === VOID0 && !enumerator.moveNext())\n                    return false;\n                do {\n                    if (!middleEnumerator) {\n                        var middleSeq = collectionSelector(enumerator.current, index++);\n                        if (!middleSeq)\n                            continue;\n                        middleEnumerator = Enumerator_1.from(middleSeq);\n                    }\n                    if (middleEnumerator.moveNext())\n                        return yielder.yieldReturn(resultSelector(enumerator.current, middleEnumerator.current));\n                    middleEnumerator.dispose();\n                    middleEnumerator = null;\n                } while (enumerator.moveNext());\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator, middleEnumerator);\n                enumerator = null;\n                middleEnumerator = null;\n            }, isEndless);\n        }, null, isEndless);\n    }\n    selectMany(collectionSelector, resultSelector) {\n        return this._selectMany(collectionSelector, resultSelector);\n    }\n    _choose(selector) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                index = 0;\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                while (enumerator.moveNext()) {\n                    var result = selector(enumerator.current, index++);\n                    if (result !== null && result !== VOID0)\n                        return yielder.yieldReturn(result);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, () => {\n            disposed = true;\n        }, _._isEndless);\n    }\n    choose(selector = Functions.Identity) {\n        return this._choose(selector);\n    }\n    where(predicate) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                index = 0;\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                while (enumerator.moveNext()) {\n                    if (predicate(enumerator.current, index++))\n                        return yielder.yieldReturn(enumerator.current);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, () => {\n            disposed = true;\n        }, _._isEndless);\n    }\n    ofType(type) {\n        var typeName;\n        switch (type) {\n            case Number:\n                typeName = Types_1.Type.NUMBER;\n                break;\n            case String:\n                typeName = Types_1.Type.STRING;\n                break;\n            case Boolean:\n                typeName = Types_1.Type.BOOLEAN;\n                break;\n            case Function:\n                typeName = Types_1.Type.FUNCTION;\n                break;\n            default:\n                return this\n                    .where(x => x instanceof type);\n        }\n        return this\n            .choose()\n            .where(x => (typeof x) === typeName);\n    }\n    except(second, compareSelector) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var keys;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                enumerator = _.getEnumerator();\n                keys = new Dictionary_1.Dictionary(compareSelector);\n                if (second)\n                    Enumerator_1.forEach(second, key => { keys.addByKeyValue(key, true); });\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                while (enumerator.moveNext()) {\n                    var current = enumerator.current;\n                    if (!keys.containsKey(current)) {\n                        keys.addByKeyValue(current, true);\n                        return yielder.yieldReturn(current);\n                    }\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n                keys.clear();\n            }, _._isEndless);\n        }, () => {\n            disposed = true;\n        }, _._isEndless);\n    }\n    distinct(compareSelector) {\n        return this.except(null, compareSelector);\n    }\n    distinctUntilChanged(compareSelector = Functions.Identity) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var compareKey;\n            var initial = true;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                while (enumerator.moveNext()) {\n                    var key = compareSelector(enumerator.current);\n                    if (initial) {\n                        initial = false;\n                    }\n                    else if (Values.areEqual(compareKey, key)) {\n                        continue;\n                    }\n                    compareKey = key;\n                    return yielder.yieldReturn(enumerator.current);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, () => {\n            disposed = true;\n        }, _._isEndless);\n    }\n    defaultIfEmpty(defaultValue = null) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            var isFirst;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                isFirst = true;\n                throwIfDisposed(disposed);\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                if (enumerator.moveNext()) {\n                    isFirst = false;\n                    return yielder.yieldReturn(enumerator.current);\n                }\n                else if (isFirst) {\n                    isFirst = false;\n                    return yielder.yieldReturn(defaultValue);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    zip(second, resultSelector) {\n        var _ = this;\n        _.throwIfDisposed();\n        return new Enumerable(() => {\n            var firstEnumerator;\n            var secondEnumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                index = 0;\n                firstEnumerator = _.getEnumerator();\n                secondEnumerator = Enumerator_1.from(second);\n            }, (yielder) => firstEnumerator.moveNext()\n                && secondEnumerator.moveNext()\n                && yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++)), () => {\n                dispose_1.dispose(firstEnumerator, secondEnumerator);\n            });\n        });\n    }\n    zipMultiple(second, resultSelector) {\n        var _ = this;\n        _.throwIfDisposed();\n        if (!second.length)\n            return Enumerable.empty();\n        return new Enumerable(() => {\n            var secondTemp;\n            var firstEnumerator;\n            var secondEnumerator;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                secondTemp = new Queue_1.Queue(second);\n                index = 0;\n                firstEnumerator = _.getEnumerator();\n                secondEnumerator = null;\n            }, (yielder) => {\n                if (firstEnumerator.moveNext()) {\n                    while (true) {\n                        while (!secondEnumerator) {\n                            if (secondTemp.count) {\n                                var next = secondTemp.dequeue();\n                                if (next)\n                                    secondEnumerator = Enumerator_1.from(next);\n                            }\n                            else\n                                return yielder.yieldBreak();\n                        }\n                        if (secondEnumerator.moveNext())\n                            return yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++));\n                        secondEnumerator.dispose();\n                        secondEnumerator = null;\n                    }\n                }\n                return yielder.yieldBreak();\n            }, () => {\n                dispose_1.dispose(firstEnumerator, secondTemp);\n            });\n        });\n    }\n    join(inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector = Functions.Identity) {\n        var _ = this;\n        return new Enumerable(() => {\n            var outerEnumerator;\n            var lookup;\n            var innerElements = null;\n            var innerCount = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                outerEnumerator = _.getEnumerator();\n                lookup = Enumerable.from(inner)\n                    .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n            }, (yielder) => {\n                while (true) {\n                    if (innerElements != null) {\n                        var innerElement = innerElements[innerCount++];\n                        if (innerElement !== VOID0)\n                            return yielder.yieldReturn(resultSelector(outerEnumerator.current, innerElement));\n                        innerElement = null;\n                        innerCount = 0;\n                    }\n                    if (outerEnumerator.moveNext()) {\n                        var key = outerKeySelector(outerEnumerator.current);\n                        innerElements = lookup.get(key);\n                    }\n                    else {\n                        return yielder.yieldBreak();\n                    }\n                }\n            }, () => {\n                dispose_1.dispose(outerEnumerator);\n            });\n        });\n    }\n    groupJoin(inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector = Functions.Identity) {\n        var _ = this;\n        return new Enumerable(() => {\n            var enumerator;\n            var lookup = null;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                lookup = Enumerable.from(inner)\n                    .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n            }, (yielder) => enumerator.moveNext()\n                && yielder.yieldReturn(resultSelector(enumerator.current, lookup.get(outerKeySelector(enumerator.current)))), () => {\n                dispose_1.dispose(enumerator);\n            });\n        });\n    }\n    merge(enumerables) {\n        var _ = this, isEndless = _._isEndless || null;\n        if (!enumerables || enumerables.length == 0)\n            return _;\n        return new Enumerable(() => {\n            var enumerator;\n            var queue;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                queue = new Queue_1.Queue(enumerables);\n            }, (yielder) => {\n                while (true) {\n                    while (!enumerator && queue.count) {\n                        enumerator = Enumerator_1.from(queue.dequeue());\n                    }\n                    if (enumerator && enumerator.moveNext())\n                        return yielder.yieldReturn(enumerator.current);\n                    if (enumerator) {\n                        enumerator.dispose();\n                        enumerator = null;\n                        continue;\n                    }\n                    return yielder.yieldBreak();\n                }\n            }, () => {\n                dispose_1.dispose(enumerator, queue);\n            }, isEndless);\n        }, null, isEndless);\n    }\n    concat(...enumerables) {\n        return this.merge(enumerables);\n    }\n    union(second, compareSelector = Functions.Identity) {\n        var _ = this, isEndless = _._isEndless || null;\n        return new Enumerable(() => {\n            var firstEnumerator;\n            var secondEnumerator;\n            var keys;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                firstEnumerator = _.getEnumerator();\n                keys = new Dictionary_1.Dictionary(compareSelector);\n            }, (yielder) => {\n                var current;\n                if (secondEnumerator === VOID0) {\n                    while (firstEnumerator.moveNext()) {\n                        current = firstEnumerator.current;\n                        if (!keys.containsKey(current)) {\n                            keys.addByKeyValue(current, null);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    secondEnumerator = Enumerator_1.from(second);\n                }\n                while (secondEnumerator.moveNext()) {\n                    current = secondEnumerator.current;\n                    if (!keys.containsKey(current)) {\n                        keys.addByKeyValue(current, null);\n                        return yielder.yieldReturn(current);\n                    }\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(firstEnumerator, secondEnumerator);\n            }, isEndless);\n        }, null, isEndless);\n    }\n    insertAt(index, other) {\n        Integer_1.Integer.assertZeroOrGreater(index, 'index');\n        var n = index;\n        var _ = this, isEndless = _._isEndless || null;\n        _.throwIfDisposed();\n        return new Enumerable(() => {\n            var firstEnumerator;\n            var secondEnumerator;\n            var count = 0;\n            var isEnumerated = false;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                count = 0;\n                firstEnumerator = _.getEnumerator();\n                secondEnumerator = Enumerator_1.from(other);\n                isEnumerated = false;\n            }, (yielder) => {\n                if (count == n) {\n                    isEnumerated = true;\n                    if (secondEnumerator.moveNext())\n                        return yielder.yieldReturn(secondEnumerator.current);\n                }\n                if (firstEnumerator.moveNext()) {\n                    count++;\n                    return yielder.yieldReturn(firstEnumerator.current);\n                }\n                return !isEnumerated\n                    && secondEnumerator.moveNext()\n                    && yielder.yieldReturn(secondEnumerator.current);\n            }, () => {\n                dispose_1.dispose(firstEnumerator, secondEnumerator);\n            }, isEndless);\n        }, null, isEndless);\n    }\n    alternateMultiple(sequence) {\n        var _ = this;\n        return new Enumerable(() => {\n            var buffer, mode, enumerator, alternateEnumerator;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                alternateEnumerator = new ArrayEnumerator_1.ArrayEnumerator(Enumerable.toArray(sequence));\n                enumerator = _.getEnumerator();\n                var hasAtLeastOne = enumerator.moveNext();\n                mode = hasAtLeastOne\n                    ? 1\n                    : 0;\n                if (hasAtLeastOne)\n                    buffer = enumerator.current;\n            }, (yielder) => {\n                switch (mode) {\n                    case 0:\n                        return yielder.yieldBreak();\n                    case 2:\n                        if (alternateEnumerator.moveNext())\n                            return yielder.yieldReturn(alternateEnumerator.current);\n                        alternateEnumerator.reset();\n                        mode = 1;\n                        break;\n                }\n                var latest = buffer;\n                var another = enumerator.moveNext();\n                mode = another\n                    ? 2\n                    : 0;\n                if (another)\n                    buffer = enumerator.current;\n                return yielder.yieldReturn(latest);\n            }, () => {\n                dispose_1.dispose(enumerator, alternateEnumerator);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    alternateSingle(value) {\n        return this.alternateMultiple(Enumerable.make(value));\n    }\n    alternate(...sequence) {\n        return this.alternateMultiple(sequence);\n    }\n    catchError(handler) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                try {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }\n                catch (e) {\n                }\n            }, (yielder) => {\n                try {\n                    throwIfDisposed(disposed);\n                    if (enumerator.moveNext())\n                        return yielder.yieldReturn(enumerator.current);\n                }\n                catch (e) {\n                    handler(e);\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator);\n            });\n        });\n    }\n    finallyAction(action) {\n        var _ = this, disposed = !_.throwIfDisposed();\n        return new Enumerable(() => {\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                return (enumerator.moveNext())\n                    ? yielder.yieldReturn(enumerator.current)\n                    : false;\n            }, () => {\n                try {\n                    dispose_1.dispose(enumerator);\n                }\n                finally {\n                    action();\n                }\n            });\n        });\n    }\n    buffer(size) {\n        if (size < 1 || !isFinite(size))\n            throw new Error(\"Invalid buffer size.\");\n        Integer_1.Integer.assert(size, \"size\");\n        var _ = this, len;\n        return new Enumerable(() => {\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n            }, (yielder) => {\n                var array = ArrayUtility.initialize(size);\n                len = 0;\n                while (len < size && enumerator.moveNext()) {\n                    array[len++] = enumerator.current;\n                }\n                array.length = len;\n                return len && yielder.yieldReturn(array);\n            }, () => {\n                dispose_1.dispose(enumerator);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    share() {\n        var _ = this;\n        _.throwIfDisposed();\n        var sharedEnumerator;\n        return new Enumerable(() => {\n            return sharedEnumerator || (sharedEnumerator = _.getEnumerator());\n        }, () => {\n            dispose_1.dispose(sharedEnumerator);\n        }, _._isEndless);\n    }\n}\nexports.InfiniteEnumerable = InfiniteEnumerable;\nclass Enumerable extends InfiniteEnumerable {\n    constructor(enumeratorFactory, finalizer, isEndless = null) {\n        super(enumeratorFactory, finalizer);\n        this._isEndless = isEndless;\n    }\n    static from(source) {\n        var e = Enumerable.fromAny(source);\n        if (!e)\n            throw new UnsupportedEnumerableException_1.UnsupportedEnumerableException();\n        return e;\n    }\n    static fromAny(source, defaultEnumerable = null) {\n        if (Types_1.Type.isObject(source) || Types_1.Type.isString(source)) {\n            if (source instanceof Enumerable)\n                return source;\n            if (Types_1.Type.isArrayLike(source))\n                return new ArrayEnumerable(source);\n            if (Enumerator_1.isEnumerable(source))\n                return new Enumerable(() => source.getEnumerator(), null, source.isEndless);\n        }\n        return defaultEnumerable;\n    }\n    static fromOrEmpty(source) {\n        return Enumerable.fromAny(source) || Enumerable.empty();\n    }\n    static toArray(source) {\n        if (source instanceof Enumerable)\n            return source.toArray();\n        return Enumerator_1.toArray(source);\n    }\n    static choice(values) {\n        var len = values && values.length;\n        if (!len || !isFinite(len))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n        return new InfiniteEnumerable(() => new EnumeratorBase_1.EnumeratorBase(null, (yielder) => yielder.yieldReturn(Integer_1.Integer.random.select(values)), true));\n    }\n    static chooseFrom(...args) {\n        return Enumerable.choice(args);\n    }\n    static cycle(values) {\n        var len = values && values.length;\n        if (!len || !isFinite(len))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n        return new InfiniteEnumerable(() => {\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                index = 0;\n            }, (yielder) => {\n                if (index >= values.length)\n                    index = 0;\n                return yielder.yieldReturn(values[index++]);\n            }, true);\n        });\n    }\n    static cycleThrough(...args) {\n        return Enumerable.cycle(args);\n    }\n    static empty() {\n        return new FiniteEnumerable(getEmptyEnumerator);\n    }\n    static repeat(element, count = Infinity) {\n        if (!(count > 0))\n            return Enumerable.empty();\n        return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n            ? new FiniteEnumerable(() => {\n                var c = count;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(() => { index = 0; }, (yielder) => (index++ < c) && yielder.yieldReturn(element), null, false);\n            })\n            : new Enumerable(() => new EnumeratorBase_1.EnumeratorBase(null, (yielder) => yielder.yieldReturn(element), true));\n    }\n    static repeatWithFinalize(initializer, finalizer) {\n        return new InfiniteEnumerable(() => {\n            var element;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                element = initializer();\n            }, (yielder) => yielder.yieldReturn(element), () => {\n                finalizer(element);\n            }, true);\n        });\n    }\n    static make(element) {\n        return Enumerable.repeat(element, 1);\n    }\n    static range(start, count, step = 1) {\n        if (!isFinite(start))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n        if (!(count > 0))\n            return Enumerable.empty();\n        if (!step)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n        if (!isFinite(step))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n        Integer_1.Integer.assert(count, \"count\");\n        return new FiniteEnumerable(() => {\n            var value;\n            var c = count;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                index = 0;\n                value = start;\n            }, (yielder) => {\n                var result = index++ < c\n                    && yielder.yieldReturn(value);\n                if (result && index < count)\n                    value += step;\n                return result;\n            }, false);\n        });\n    }\n    static rangeDown(start, count, step = 1) {\n        step = Math.abs(step) * -1;\n        return Enumerable.range(start, count, step);\n    }\n    static toInfinity(start = 0, step = 1) {\n        if (!isFinite(start))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n        if (!step)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n        if (!isFinite(step))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n        return new InfiniteEnumerable(() => {\n            var value;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                value = start;\n            }, (yielder) => {\n                var current = value;\n                value += step;\n                return yielder.yieldReturn(current);\n            }, true);\n        });\n    }\n    static toNegativeInfinity(start = 0, step = 1) {\n        return Enumerable.toInfinity(start, -step);\n    }\n    static rangeTo(start, to, step = 1) {\n        if (isNaN(to) || !isFinite(to))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\n        if (step && !isFinite(step))\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\n        step = Math.abs(step);\n        return new FiniteEnumerable(() => {\n            var value;\n            return new EnumeratorBase_1.EnumeratorBase(() => { value = start; }, start < to\n                ?\n                    yielder => {\n                        var result = value <= to && yielder.yieldReturn(value);\n                        if (result)\n                            value += step;\n                        return result;\n                    }\n                :\n                    yielder => {\n                        var result = value >= to && yielder.yieldReturn(value);\n                        if (result)\n                            value -= step;\n                        return result;\n                    }, false);\n        });\n    }\n    static matches(input, pattern, flags = \"\") {\n        if (input === null || input === VOID0)\n            throw new ArgumentNullException_1.ArgumentNullException(\"input\");\n        var type = typeof input;\n        if (type != Types_1.Type.STRING)\n            throw new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\n        if (pattern instanceof RegExp) {\n            flags += (pattern.ignoreCase) ? \"i\" : \"\";\n            flags += (pattern.multiline) ? \"m\" : \"\";\n            pattern = pattern.source;\n        }\n        if (flags.indexOf(\"g\") === -1)\n            flags += \"g\";\n        return new FiniteEnumerable(() => {\n            var regex;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                regex = new RegExp(pattern, flags);\n            }, (yielder) => {\n                var match = regex.exec(input);\n                return (match !== null) ? yielder.yieldReturn(match) : false;\n            });\n        });\n    }\n    static generate(factory, count = Infinity) {\n        if (isNaN(count) || count <= 0)\n            return Enumerable.empty();\n        return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n            ?\n                new FiniteEnumerable(() => {\n                    var c = count;\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(() => {\n                        index = 0;\n                    }, (yielder) => {\n                        var current = index++;\n                        return current < c && yielder.yieldReturn(factory(current));\n                    }, false);\n                })\n            :\n                new InfiniteEnumerable(() => {\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(() => {\n                        index = 0;\n                    }, (yielder) => yielder.yieldReturn(factory(index++)), true);\n                });\n    }\n    static unfold(seed, valueFactory, skipSeed = false) {\n        return new InfiniteEnumerable(() => {\n            var index = 0;\n            var value;\n            var isFirst;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                index = 0;\n                value = seed;\n                isFirst = !skipSeed;\n            }, (yielder) => {\n                var i = index++;\n                if (isFirst)\n                    isFirst = false;\n                else\n                    value = valueFactory(value, i);\n                return yielder.yieldReturn(value);\n            }, true);\n        });\n    }\n    static forEach(enumerable, action, max = Infinity) {\n        return Enumerator_1.forEach(enumerable, action, max);\n    }\n    static map(enumerable, selector) {\n        return Enumerator_1.map(enumerable, selector);\n    }\n    static max(values) {\n        return values\n            .takeUntil(v => v == +Infinity, true)\n            .aggregate(Functions.Greater);\n    }\n    static min(values) {\n        return values\n            .takeUntil(v => v == -Infinity, true)\n            .aggregate(Functions.Lesser);\n    }\n    static weave(enumerables) {\n        if (!enumerables)\n            throw new ArgumentNullException_1.ArgumentNullException('enumerables');\n        return new Enumerable(() => {\n            var queue;\n            var mainEnumerator;\n            var index;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                index = 0;\n                queue = new Queue_1.Queue();\n                mainEnumerator = Enumerator_1.from(enumerables);\n            }, (yielder) => {\n                let e;\n                if (mainEnumerator) {\n                    while (!e && mainEnumerator.moveNext()) {\n                        let c = mainEnumerator.current;\n                        e = nextEnumerator(queue, c && Enumerator_1.from(c));\n                    }\n                    if (!e)\n                        mainEnumerator = null;\n                }\n                while (!e && queue.count) {\n                    e = nextEnumerator(queue, queue.dequeue());\n                }\n                return e\n                    ? yielder.yieldReturn(e.current)\n                    : yielder.yieldBreak();\n            }, () => {\n                dispose_1.dispose.these(queue.dump());\n                dispose_1.dispose(mainEnumerator, queue);\n                mainEnumerator = null;\n                queue = null;\n            });\n        });\n    }\n    doAction(action, initializer, isEndless = this.isEndless) {\n        return super.doAction(action, initializer, isEndless);\n    }\n    skip(count) {\n        return super.skip(count);\n    }\n    skipWhile(predicate) {\n        this.throwIfDisposed();\n        return this.doAction((element, index) => predicate(element, index)\n            ? 2\n            : 1);\n    }\n    takeWhile(predicate) {\n        this.throwIfDisposed();\n        if (!predicate)\n            throw new ArgumentNullException_1.ArgumentNullException('predicate');\n        return this.doAction((element, index) => predicate(element, index)\n            ? 1\n            : 0, null, null);\n    }\n    takeUntil(predicate, includeUntilValue) {\n        this.throwIfDisposed();\n        if (!predicate)\n            throw new ArgumentNullException_1.ArgumentNullException('predicate');\n        if (!includeUntilValue)\n            return this.doAction((element, index) => predicate(element, index)\n                ? 0\n                : 1, null, null);\n        var found = false;\n        return this.doAction((element, index) => {\n            if (found)\n                return 0;\n            found = predicate(element, index);\n            return 1;\n        }, () => {\n            found = false;\n        }, null);\n    }\n    forEach(action) {\n        var _ = this;\n        _.throwIfDisposed();\n        Enumerator_1.throwIfEndless(_.isEndless);\n        var index = 0;\n        dispose_1.using(_.getEnumerator(), e => {\n            Enumerator_1.throwIfEndless(e.isEndless);\n            while (_.throwIfDisposed() && e.moveNext()) {\n                if (action(e.current, index++) === false)\n                    break;\n            }\n        });\n    }\n    toArray(predicate) {\n        return predicate\n            ? this.where(predicate).toArray()\n            : this.copyTo([]);\n    }\n    copyTo(target, index = 0, count = Infinity) {\n        this.throwIfDisposed();\n        if (!target)\n            throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n        Integer_1.Integer.assertZeroOrGreater(index);\n        Enumerator_1.forEach(this, (x, i) => {\n            target[i + index] = x;\n        }, count);\n        return target;\n    }\n    toLookup(keySelector, elementSelector = Functions.Identity, compareSelector = Functions.Identity) {\n        var dict = new Dictionary_1.Dictionary(compareSelector);\n        this.forEach(x => {\n            var key = keySelector(x);\n            var element = elementSelector(x);\n            var array = dict.getValue(key);\n            if (array !== VOID0)\n                array.push(element);\n            else\n                dict.addByKeyValue(key, [element]);\n        });\n        return new Lookup(dict);\n    }\n    toMap(keySelector, elementSelector) {\n        var obj = {};\n        this.forEach((x, i) => {\n            obj[keySelector(x, i)] = elementSelector(x, i);\n        });\n        return obj;\n    }\n    toDictionary(keySelector, elementSelector, compareSelector = Functions.Identity) {\n        var dict = new Dictionary_1.Dictionary(compareSelector);\n        this.forEach((x, i) => dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)));\n        return dict;\n    }\n    toJoinedString(separator = \"\", selector = Functions.Identity) {\n        return this.select(selector).toArray().join(separator);\n    }\n    takeExceptLast(count = 1) {\n        var _ = this;\n        if (!(count > 0))\n            return _;\n        if (!isFinite(count))\n            return Enumerable.empty();\n        Integer_1.Integer.assert(count, \"count\");\n        var c = count;\n        return new Enumerable(() => {\n            var enumerator;\n            var q;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                q = new Queue_1.Queue();\n            }, (yielder) => {\n                while (enumerator.moveNext()) {\n                    q.enqueue(enumerator.current);\n                    if (q.count > c)\n                        return yielder.yieldReturn(q.dequeue());\n                }\n                return false;\n            }, () => {\n                dispose_1.dispose(enumerator, q);\n            });\n        });\n    }\n    skipToLast(count) {\n        if (!(count > 0))\n            return Enumerable.empty();\n        var _ = this;\n        if (!isFinite(count))\n            return _;\n        Integer_1.Integer.assert(count, \"count\");\n        return _.reverse()\n            .take(count)\n            .reverse();\n    }\n    where(predicate) {\n        return super.where(predicate);\n    }\n    select(selector) {\n        return super.select(selector);\n    }\n    selectMany(collectionSelector, resultSelector) {\n        return this._selectMany(collectionSelector, resultSelector);\n    }\n    choose(selector = Functions.Identity) {\n        return this._choose(selector);\n    }\n    reverse() {\n        var _ = this, disposed = !_.throwIfDisposed();\n        Enumerator_1.throwIfEndless(_._isEndless);\n        return new Enumerable(() => {\n            var buffer;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                buffer = _.toArray();\n                index = buffer.length;\n            }, (yielder) => index && yielder.yieldReturn(buffer[--index]), () => {\n                buffer.length = 0;\n            });\n        }, () => {\n            disposed = true;\n        });\n    }\n    shuffle() {\n        var _ = this, disposed = !_.throwIfDisposed();\n        Enumerator_1.throwIfEndless(_._isEndless);\n        return new Enumerable(() => {\n            var buffer;\n            var capacity;\n            var len;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                buffer = _.toArray();\n                capacity = len = buffer.length;\n            }, (yielder) => {\n                if (!len)\n                    return yielder.yieldBreak();\n                var selectedIndex = Integer_1.Integer.random(len);\n                var selectedValue = buffer[selectedIndex];\n                buffer[selectedIndex] = buffer[--len];\n                buffer[len] = null;\n                if (len % 32 == 0)\n                    buffer.length = len;\n                return yielder.yieldReturn(selectedValue);\n            }, () => {\n                buffer.length = 0;\n            });\n        }, () => {\n            disposed = true;\n        });\n    }\n    count(predicate) {\n        var count = 0;\n        this.forEach(predicate\n            ?\n                    (x, i) => {\n                    if (predicate(x, i))\n                        ++count;\n                }\n            :\n                    () => {\n                    ++count;\n                });\n        return count;\n    }\n    all(predicate) {\n        if (!predicate)\n            throw new ArgumentNullException_1.ArgumentNullException(\"predicate\");\n        var result = true;\n        this.forEach((x, i) => {\n            if (!predicate(x, i)) {\n                result = false;\n                return false;\n            }\n        });\n        return result;\n    }\n    every(predicate) {\n        return this.all(predicate);\n    }\n    any(predicate) {\n        if (!predicate)\n            return super.any();\n        var result = false;\n        this.forEach((x, i) => {\n            result = predicate(x, i);\n            return !result;\n        });\n        return result;\n    }\n    some(predicate) {\n        return this.any(predicate);\n    }\n    contains(value, compareSelector) {\n        return compareSelector\n            ? this.any(v => compareSelector(v) === compareSelector(value))\n            : this.any(v => v === value);\n    }\n    indexOf(value, compareSelector) {\n        var found = -1;\n        this.forEach(compareSelector\n            ?\n                    (element, i) => {\n                    if (Values.areEqual(compareSelector(element, i), compareSelector(value, i), true)) {\n                        found = i;\n                        return false;\n                    }\n                }\n            :\n                    (element, i) => {\n                    if (Values.areEqual(element, value, true)) {\n                        found = i;\n                        return false;\n                    }\n                });\n        return found;\n    }\n    lastIndexOf(value, compareSelector) {\n        var result = -1;\n        this.forEach(compareSelector\n            ?\n                    (element, i) => {\n                    if (Values.areEqual(compareSelector(element, i), compareSelector(value, i), true))\n                        result\n                            = i;\n                }\n            :\n                    (element, i) => {\n                    if (Values.areEqual(element, value, true))\n                        result = i;\n                });\n        return result;\n    }\n    merge(enumerables) {\n        return super.merge(enumerables);\n    }\n    concat(...enumerables) {\n        return this.merge(enumerables);\n    }\n    intersect(second, compareSelector) {\n        var _ = this;\n        return new Enumerable(() => {\n            var enumerator;\n            var keys;\n            var outs;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                keys = new Dictionary_1.Dictionary(compareSelector);\n                outs = new Dictionary_1.Dictionary(compareSelector);\n                Enumerator_1.forEach(second, key => {\n                    keys.addByKeyValue(key, true);\n                });\n            }, (yielder) => {\n                while (enumerator.moveNext()) {\n                    var current = enumerator.current;\n                    if (!outs.containsKey(current) && keys.containsKey(current)) {\n                        outs.addByKeyValue(current, true);\n                        return yielder.yieldReturn(current);\n                    }\n                }\n                return yielder.yieldBreak();\n            }, () => {\n                dispose_1.dispose(enumerator, keys, outs);\n            }, _._isEndless);\n        }, null, _._isEndless);\n    }\n    sequenceEqual(second, equalityComparer = Values.areEqual) {\n        return dispose_1.using(this.getEnumerator(), e1 => dispose_1.using(Enumerator_1.from(second), e2 => {\n            Enumerator_1.throwIfEndless(e1.isEndless && e2.isEndless);\n            while (e1.moveNext()) {\n                if (!e2.moveNext() || !equalityComparer(e1.current, e2.current))\n                    return false;\n            }\n            return !e2.moveNext();\n        }));\n    }\n    ofType(type) {\n        return super.ofType(type);\n    }\n    except(second, compareSelector) {\n        return super.except(second, compareSelector);\n    }\n    distinct(compareSelector) {\n        return super.distinct(compareSelector);\n    }\n    distinctUntilChanged(compareSelector = Functions.Identity) {\n        return super.distinctUntilChanged(compareSelector);\n    }\n    orderBy(keySelector = Functions.Identity) {\n        return new OrderedEnumerable(this, keySelector, 1);\n    }\n    orderUsing(comparison) {\n        return new OrderedEnumerable(this, null, 1, null, comparison);\n    }\n    orderUsingReversed(comparison) {\n        return new OrderedEnumerable(this, null, -1, null, comparison);\n    }\n    orderByDescending(keySelector = Functions.Identity) {\n        return new OrderedEnumerable(this, keySelector, -1);\n    }\n    buffer(size) {\n        return super.buffer(size);\n    }\n    groupBy(keySelector, elementSelector, compareSelector) {\n        if (!elementSelector)\n            elementSelector = Functions.Identity;\n        return new Enumerable(() => this.toLookup(keySelector, elementSelector, compareSelector)\n            .getEnumerator());\n    }\n    partitionBy(keySelector, elementSelector, resultSelector = (key, elements) => new Grouping(key, elements), compareSelector = Functions.Identity) {\n        var _ = this;\n        if (!elementSelector)\n            elementSelector = Functions.Identity;\n        return new Enumerable(() => {\n            var enumerator;\n            var key;\n            var compareKey;\n            var group;\n            var len;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                enumerator = _.getEnumerator();\n                if (enumerator.moveNext()) {\n                    key = keySelector(enumerator.current);\n                    compareKey = compareSelector(key);\n                    group = [elementSelector(enumerator.current)];\n                    len = 1;\n                }\n                else\n                    group = null;\n            }, (yielder) => {\n                if (!group)\n                    return yielder.yieldBreak();\n                var hasNext, c;\n                while ((hasNext = enumerator.moveNext())) {\n                    c = enumerator.current;\n                    if (compareKey === compareSelector(keySelector(c)))\n                        group[len++] = elementSelector(c);\n                    else\n                        break;\n                }\n                var result = resultSelector(key, group);\n                if (hasNext) {\n                    c = enumerator.current;\n                    key = keySelector(c);\n                    compareKey = compareSelector(key);\n                    group = [elementSelector(c)];\n                    len = 1;\n                }\n                else {\n                    group = null;\n                }\n                return yielder.yieldReturn(result);\n            }, () => {\n                dispose_1.dispose(enumerator);\n                group = null;\n            });\n        });\n    }\n    aggregate(func, seed) {\n        return this.scan(func, seed).lastOrDefault();\n    }\n    average(selector = Types_1.Type.numberOrNaN) {\n        var count = 0;\n        var sum = this.sum((e, i) => {\n            count++;\n            return selector(e, i);\n        });\n        return (isNaN(sum) || !count)\n            ? NaN\n            : (sum / count);\n    }\n    max() {\n        return this.aggregate(Functions.Greater);\n    }\n    min() {\n        return this.aggregate(Functions.Lesser);\n    }\n    maxBy(keySelector = Functions.Identity) {\n        return this.aggregate((a, b) => (keySelector(a) > keySelector(b)) ? a : b);\n    }\n    minBy(keySelector = Functions.Identity) {\n        return this.aggregate((a, b) => (keySelector(a) < keySelector(b)) ? a : b);\n    }\n    sum(selector = Types_1.Type.numberOrNaN) {\n        var sum = 0;\n        var sumInfinite = 0;\n        this.forEach(x => {\n            var value = selector(x);\n            if (isNaN(value)) {\n                sum = NaN;\n                return false;\n            }\n            if (isFinite(value))\n                sum += value;\n            else\n                sumInfinite +=\n                    value > 0 ?\n                        (+1) :\n                        (-1);\n        });\n        return isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite * Infinity) : sum);\n    }\n    product(selector = Types_1.Type.numberOrNaN) {\n        var result = 1, exists = false;\n        this.forEach((x, i) => {\n            exists = true;\n            var value = selector(x, i);\n            if (isNaN(value)) {\n                result = NaN;\n                return false;\n            }\n            if (value == 0) {\n                result = 0;\n                return false;\n            }\n            result *= value;\n        });\n        return (exists && isNaN(result)) ? NaN : result;\n    }\n    quotient(selector = Types_1.Type.numberOrNaN) {\n        var count = 0;\n        var result = NaN;\n        this.forEach((x, i) => {\n            var value = selector(x, i);\n            count++;\n            if (count === 1) {\n                result = value;\n            }\n            else {\n                if (isNaN(value) || value === 0 || !isFinite(value)) {\n                    result = NaN;\n                    return false;\n                }\n                result /= value;\n            }\n        });\n        if (count === 1)\n            result = NaN;\n        return result;\n    }\n    last() {\n        var _ = this;\n        _.throwIfDisposed();\n        var value = undefined;\n        var found = false;\n        _.forEach(x => {\n            found = true;\n            value = x;\n        });\n        if (!found)\n            throw new Error(\"last:No element satisfies the condition.\");\n        return value;\n    }\n    lastOrDefault(defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        var value = undefined;\n        var found = false;\n        _.forEach(x => {\n            found = true;\n            value = x;\n        });\n        return (!found) ? defaultValue : value;\n    }\n    share() {\n        return super.share();\n    }\n    catchError(handler) {\n        return super.catchError(handler);\n    }\n    finallyAction(action) {\n        return super.finallyAction(action);\n    }\n    memoize() {\n        var _ = this, disposed = !_.throwIfDisposed();\n        var cache;\n        var enumerator;\n        return new Enumerable(() => {\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(() => {\n                throwIfDisposed(disposed);\n                if (!enumerator)\n                    enumerator = _.getEnumerator();\n                if (!cache)\n                    cache = [];\n                index = 0;\n            }, (yielder) => {\n                throwIfDisposed(disposed);\n                var i = index++;\n                if (i >= cache.length) {\n                    return (enumerator.moveNext())\n                        ? yielder.yieldReturn(cache[i] = enumerator.current)\n                        : false;\n                }\n                return yielder.yieldReturn(cache[i]);\n            });\n        }, () => {\n            disposed = true;\n            if (cache)\n                cache.length = 0;\n            cache = null;\n            dispose_1.dispose(enumerator);\n            enumerator = null;\n        });\n    }\n}\nexports.Enumerable = Enumerable;\nclass FiniteEnumerable extends Enumerable {\n    constructor(enumeratorFactory, finalizer) {\n        super(enumeratorFactory, finalizer, false);\n    }\n}\nexports.FiniteEnumerable = FiniteEnumerable;\nclass ArrayEnumerable extends FiniteEnumerable {\n    constructor(source) {\n        super(() => {\n            _.throwIfDisposed();\n            return new ArrayEnumerator_1.ArrayEnumerator(() => {\n                _.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\n                return _._source;\n            });\n        });\n        var _ = this;\n        _._disposableObjectName = \"ArrayEnumerable\";\n        _._source = source;\n    }\n    _onDispose() {\n        super._onDispose();\n        this._source = null;\n    }\n    get source() {\n        return this._source;\n    }\n    toArray() {\n        var _ = this;\n        _.throwIfDisposed();\n        return Enumerator_1.toArray(_._source);\n    }\n    asEnumerable() {\n        return new ArrayEnumerable(this._source);\n    }\n    forEach(action, max = Infinity) {\n        var _ = this;\n        _.throwIfDisposed();\n        return Enumerator_1.forEach(_._source, action, max);\n    }\n    any(predicate) {\n        var _ = this;\n        _.throwIfDisposed();\n        var source = _._source, len = source.length;\n        return len && (!predicate || super.any(predicate));\n    }\n    count(predicate) {\n        var _ = this;\n        _.throwIfDisposed();\n        var source = _._source, len = source.length;\n        return len && (predicate ? super.count(predicate) : len);\n    }\n    elementAtOrDefault(index, defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        Integer_1.Integer.assertZeroOrGreater(index, 'index');\n        var source = _._source;\n        return index < source.length\n            ? source[index]\n            : defaultValue;\n    }\n    last() {\n        var _ = this;\n        _.throwIfDisposed();\n        var source = _._source, len = source.length;\n        return (len)\n            ? source[len - 1]\n            : super.last();\n    }\n    lastOrDefault(defaultValue = null) {\n        var _ = this;\n        _.throwIfDisposed();\n        var source = _._source, len = source.length;\n        return len\n            ? source[len - 1]\n            : defaultValue;\n    }\n    skip(count) {\n        var _ = this;\n        if (!(count > 0))\n            return _;\n        return new Enumerable(() => new ArrayEnumerator_1.ArrayEnumerator(() => _._source, count));\n    }\n    takeExceptLast(count = 1) {\n        var _ = this;\n        return _.take(_._source.length - count);\n    }\n    skipToLast(count) {\n        if (!(count > 0))\n            return Enumerable.empty();\n        var _ = this;\n        if (!isFinite(count))\n            return _;\n        var len = _._source\n            ? _._source.length\n            : 0;\n        return _.skip(len - count);\n    }\n    reverse() {\n        var _ = this;\n        return new Enumerable(() => new ArrayEnumerator_1.ArrayEnumerator(() => _._source, _._source\n            ? (_._source.length - 1)\n            : 0, -1));\n    }\n    memoize() {\n        return this.asEnumerable();\n    }\n    sequenceEqual(second, equalityComparer = Values.areEqual) {\n        if (Types_1.Type.isArrayLike(second))\n            return Arrays.areEqual(this.source, second, true, equalityComparer);\n        if (second instanceof ArrayEnumerable)\n            return second.sequenceEqual(this.source, equalityComparer);\n        return super.sequenceEqual(second, equalityComparer);\n    }\n    toJoinedString(separator = \"\", selector = Functions.Identity) {\n        var s = this._source;\n        return !selector && Array.isArray(s)\n            ? s.join(separator)\n            : super.toJoinedString(separator, selector);\n    }\n}\nclass Grouping extends ArrayEnumerable {\n    constructor(_groupKey, elements) {\n        super(elements);\n        this._groupKey = _groupKey;\n    }\n    get key() {\n        return this._groupKey;\n    }\n}\nclass Lookup {\n    constructor(_dictionary) {\n        this._dictionary = _dictionary;\n    }\n    get count() {\n        return this._dictionary.count;\n    }\n    get(key) {\n        return this._dictionary.getValue(key);\n    }\n    contains(key) {\n        return this._dictionary.containsKey(key);\n    }\n    getEnumerator() {\n        var _ = this;\n        var enumerator;\n        return new EnumeratorBase_1.EnumeratorBase(() => {\n            enumerator = _._dictionary.getEnumerator();\n        }, (yielder) => {\n            if (!enumerator.moveNext())\n                return false;\n            var current = enumerator.current;\n            return yielder.yieldReturn(new Grouping(current.key, current.value));\n        }, () => {\n            dispose_1.dispose(enumerator);\n        });\n    }\n}\nclass OrderedEnumerable extends FiniteEnumerable {\n    constructor(source, keySelector, order, parent, comparer = Values.compare) {\n        super(null);\n        this.source = source;\n        this.keySelector = keySelector;\n        this.order = order;\n        this.parent = parent;\n        this.comparer = comparer;\n        Enumerator_1.throwIfEndless(source && source.isEndless);\n    }\n    createOrderedEnumerable(keySelector, order) {\n        return new OrderedEnumerable(this.source, keySelector, order, this);\n    }\n    thenBy(keySelector) {\n        return this.createOrderedEnumerable(keySelector, 1);\n    }\n    thenUsing(comparison) {\n        return new OrderedEnumerable(this.source, null, 1, this, comparison);\n    }\n    thenByDescending(keySelector) {\n        return this.createOrderedEnumerable(keySelector, -1);\n    }\n    thenUsingReversed(comparison) {\n        return new OrderedEnumerable(this.source, null, -1, this, comparison);\n    }\n    getEnumerator() {\n        var _ = this;\n        var buffer;\n        var indexes;\n        var index = 0;\n        return new EnumeratorBase_1.EnumeratorBase(() => {\n            index = 0;\n            buffer = Enumerable.toArray(_.source);\n            indexes = createSortContext(_).generateSortedIndexes(buffer);\n        }, (yielder) => {\n            return (index < indexes.length)\n                ? yielder.yieldReturn(buffer[indexes[index++]])\n                : false;\n        }, () => {\n            if (buffer)\n                buffer.length = 0;\n            buffer = null;\n            if (indexes)\n                indexes.length = 0;\n            indexes = null;\n        }, false);\n    }\n    _onDispose() {\n        super._onDispose();\n        this.source = null;\n        this.keySelector = null;\n        this.order = null;\n        this.parent = null;\n    }\n}\nfunction nextEnumerator(queue, e) {\n    if (e) {\n        if (e.moveNext()) {\n            queue.enqueue(e);\n        }\n        else {\n            dispose_1.dispose(e);\n            e = null;\n        }\n    }\n    return e;\n}\nfunction createSortContext(orderedEnumerable, currentContext = null) {\n    var context = new KeySortedContext_1.KeySortedContext(currentContext, orderedEnumerable.keySelector, orderedEnumerable.order, orderedEnumerable.comparer);\n    if (orderedEnumerable.parent)\n        return createSortContext(orderedEnumerable.parent, context);\n    return context;\n}\nfunction throwIfDisposed(disposed) {\n    if (disposed)\n        throw new ObjectDisposedException_1.ObjectDisposedException(\"Enumerable\");\n}\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.default = Enumerable;\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\n\r\nimport * as Values from \"../System/Compare\";\r\nimport * as Arrays from \"../System/Collections/Array/Compare\";\r\nimport * as ArrayUtility from \"../System/Collections/Array/Utility\";\r\nimport {\r\n\tfrom as enumeratorFrom,\r\n\tforEach,\r\n\ttoArray,\r\n\tmap,\r\n\tisEnumerable,\r\n\tthrowIfEndless\r\n} from \"../System/Collections/Enumeration/Enumerator\";\r\nimport {EmptyEnumerator} from \"../System/Collections/Enumeration/EmptyEnumerator\";\r\nimport {Type} from \"../System/Types\";\r\nimport {Integer} from \"../System/Integer\";\r\nimport {Functions as BaseFunctions} from \"../System/Functions\";\r\nimport {ArrayEnumerator} from \"../System/Collections/Enumeration/ArrayEnumerator\";\r\nimport {EnumeratorBase} from \"../System/Collections/Enumeration/EnumeratorBase\";\r\nimport {Dictionary} from \"../System/Collections/Dictionaries/Dictionary\";\r\nimport {Queue} from \"../System/Collections/Queue\";\r\nimport {dispose, using} from \"../System/Disposable/dispose\";\r\nimport {DisposableBase} from \"../System/Disposable/DisposableBase\";\r\nimport {UnsupportedEnumerableException} from \"../System/Collections/Enumeration/UnsupportedEnumerableException\";\r\nimport {ObjectDisposedException} from \"../System/Disposable/ObjectDisposedException\";\r\nimport {KeySortedContext} from \"../System/Collections/Sorting/KeySortedContext\";\r\nimport {ArgumentNullException} from \"../System/Exceptions/ArgumentNullException\";\r\nimport {ArgumentOutOfRangeException} from \"../System/Exceptions/ArgumentOutOfRangeException\";\r\nimport {IEnumerator} from \"../System/Collections/Enumeration/IEnumerator\";\r\nimport {IEnumerable} from \"../System/Collections/Enumeration/IEnumerable\";\r\nimport {Action, Predicate, Selector, EqualityComparison, Comparison} from \"../System/FunctionTypes\";\r\nimport {IEnumerableOrArray} from \"../System/Collections/IEnumerableOrArray\";\r\nimport {IArray} from \"../System/Collections/Array/IArray\";\r\nimport {IMap, IDictionary} from \"../System/Collections/Dictionaries/IDictionary\";\r\nimport {Comparable} from \"../System/IComparable\";\r\nimport {IComparer} from \"../System/IComparer\";\r\nimport {IKeyValuePair} from \"../System/KeyValuePair\";\r\nimport {Order} from \"../System/Collections/Sorting/Order\";\r\nimport {\r\n\tIInfiniteEnumerable,\r\n\tILinqEnumerable,\r\n\tIFiniteEnumerable,\r\n\tILookup,\r\n\tIOrderedEnumerable,\r\n\tIGrouping,\r\n\tEnumerableAction\r\n} from \"./Enumerable\";\r\nimport __extendsImport from \"../extends\";\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// #region Local Constants.\r\n\r\nconst INVALID_DEFAULT:any = {}; // create a private unique instance for referencing.\r\nconst VOID0:any = void 0;\r\nconst BREAK:(e:any)=>EnumerableAction = element => EnumerableAction.Break;\r\n\r\n// Leave internal to avoid accidental overwriting.\r\nclass LinqFunctions extends BaseFunctions\r\n{\r\n\tGreater<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a>b ? a : b;\r\n\t}\r\n\r\n\tLesser<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a<b ? a : b;\r\n\t}\r\n}\r\n\r\nvar Functions = new LinqFunctions();\r\nObject.freeze(Functions);\r\n\r\n// For re-use as a factory.\r\nfunction getEmptyEnumerator():IEnumerator<any>\r\n{\r\n\treturn EmptyEnumerator;\r\n}\r\n\r\n// #endregion\r\n\r\n\r\n\r\n/*\r\n * NOTE: About InfiniteEnumerable<T> and Enumerable<T>.\r\n * There may seem like there's extra overrides here and they may seem unnecessary.\r\n * But after closer inspection you'll see the type chain is retained and\r\n * infinite enumerables are prevented from having features that finite ones have.\r\n *\r\n * I'm not sure if it's the best option to just use overrides, but it honors the typing properly.\r\n */\r\n\r\nexport class InfiniteEnumerable<T>\r\nextends DisposableBase implements IInfiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tprotected _enumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:() => void)\r\n\t{\r\n\t\tsuper(finalizer);\r\n\t\tthis._isEndless = true;\r\n\t}\r\n\r\n\tprotected _isEndless:boolean;\r\n\tget isEndless():boolean\r\n\t{\r\n\t\treturn this._isEndless;\r\n\t}\r\n\r\n\t// #region IEnumerable<T> Implementation...\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this._enumeratorFactory();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IDisposable override...\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose(); // Just in case.\r\n\t\tthis._enumeratorFactory = null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// Return a default (unfiltered) enumerable.\r\n\tasEnumerable():InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\treturn new InfiniteEnumerable<T>(() => _.getEnumerator());\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Similar to forEach, but executes an action for each time a value is enumerated.\r\n\t * If the action explicitly returns false or 0 (EnumerationAction.Break), the enumeration will complete.\r\n\t * If it returns a 2 (EnumerationAction.Skip) it will move on to the next item.\r\n\t * This also automatically handles disposing the enumerator.\r\n\t */\r\n\tdoAction(\r\n\t\taction:Action<T> | Predicate<T> | Selector<T, number> | Selector<T, EnumerableAction>,\r\n\t\tinitializer?:()=>void,\r\n\t\tisEndless:boolean = this.isEndless):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tif(initializer) initializer();\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t// May need a way to propagate isEndless\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar actionResult = <any>action(enumerator.current, index++);\r\n\r\n\t\t\t\t\t\t\tif(actionResult===false || actionResult===EnumerableAction.Break)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tif(actionResult!==EnumerableAction.Skip) // || !== 2\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\r\n\t\t\t\t\t\t\t// If actionResult===2, then a signal for skip is received.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\r\n\t\t\t},\r\n\t\t\t// Using a finalizer value reduces the chance of a circular reference\r\n\t\t\t// since we could simply reference the enumeration and check e.wasDisposed.\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforce():void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis.doAction(BREAK)\r\n\t\t\t.getEnumerator()\r\n\t\t\t.moveNext();\r\n\r\n\t}\r\n\r\n\t// #region Indexing/Paging methods.\r\n\tskip(count:number):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tindex<count\r\n\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t: EnumerableAction.Return\r\n\t\t);\r\n\t}\r\n\r\n\r\n\ttake(count:number):FiniteEnumerable<T>\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count))\r\n\t\t\tthrow new ArgumentOutOfRangeException('count', count, 'Must be finite.');\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// Once action returns false, the enumeration will stop.\r\n\t\treturn <Enumerable<T>>_.doAction((element:T, index?:number) => index<count, null, false);\r\n\t}\r\n\r\n\t// #region Single Value Return...\r\n\r\n\telementAt(index:number):T\r\n\t{\r\n\t\tvar v = this.elementAtOrDefault(index, INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\r\n\t\treturn v;\r\n\t}\r\n\r\n\telementAtOrDefault(index:number, defaultValue:T = null):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tvar n:number = index;\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tvar i = 0;\r\n\t\t\t\twhile(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(i==n) return e.current;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/* Note: Unlike previous implementations, you could pass a predicate into these methods.\r\n\t * But since under the hood it ends up calling .where(predicate) anyway,\r\n\t * it may be better to remove this to allow for a cleaner signature/override.\r\n\t * JavaScript/TypeScript does not easily allow for a strict method interface like C#.\r\n\t * Having to write extra override logic is error prone and confusing to the consumer.\r\n\t * Removing the predicate here may also cause the consumer of this method to think more about how they structure their query.\r\n\t * The end all difference is that the user must declare .where(predicate) before .first(), .single(), or .last().\r\n\t * */\r\n\r\n\tfirst():T\r\n\t{\r\n\t\tvar v = this.firstOrDefault(INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new Error(\"first:The sequence is empty.\");\r\n\t\treturn v;\r\n\t}\r\n\r\n\tfirstOrDefault(defaultValue:T = null):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=> e.moveNext() ? e.current : defaultValue\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tsingle():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t\tthrow new Error(\"single:sequence contains more than one element.\");\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(\"single:The sequence is empty.\");\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tsingleOrDefault(defaultValue:T = null):T\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tvar value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t}\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tany():boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te=> e.moveNext()\r\n\t\t);\r\n\t}\r\n\r\n\tisEmpty():boolean\r\n\t{\r\n\t\treturn !this.any();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region Projection and Filtering Methods\r\n\r\n\ttraverseBreadthFirst(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\r\n\ttraverseBreadthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel?:number) => any = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null; // Is endless is not affirmative if false.\r\n\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<any>;\r\n\t\t\t\tvar nestLevel:number = 0;\r\n\t\t\t\tvar buffer:any[], len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<any>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnestLevel = 0;\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbuffer[len++] = enumerator.current;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tvar next = Enumerable\r\n\t\t\t\t\t\t\t\t.from(buffer)\r\n\t\t\t\t\t\t\t\t.selectMany(childrenSelector);\r\n\r\n\t\t\t\t\t\t\tif(!next.any())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnestLevel++;\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = next.getEnumerator();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\ttraverseDepthFirst(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>):Enumerable<T>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>):Enumerable<TNode>;\r\n\r\n\ttraverseDepthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => IEnumerableOrArray<T>,\r\n\t\tresultSelector?:(element:T, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector?:(element:TNode, nestLevel?:number) => TResult):Enumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T|TNode) => IEnumerableOrArray<TNode>,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel?:number) => any = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null; // Is endless is not affirmative if false.\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Dev Note: May want to consider using an actual stack and not an array.\r\n\t\t\t\tvar enumeratorStack:IEnumerator<any>[] = [];\r\n\t\t\t\tvar enumerator:IEnumerator<any>;\r\n\t\t\t\tvar len:number;  // Avoid using push/pop since they query .length every time and can be slower.\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet value = resultSelector(enumerator.current, len);\r\n\t\t\t\t\t\t\t\tenumeratorStack[len++] = enumerator;\r\n\t\t\t\t\t\t\t\tlet e = Enumerable.fromAny<any>(childrenSelector(enumerator.current));\r\n\t\t\t\t\t\t\t\tenumerator = e ? e.getEnumerator() : EmptyEnumerator;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(len==0) return false;\r\n\r\n\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\tenumerator = enumeratorStack[--len];\r\n\t\t\t\t\t\t\tenumeratorStack.length = len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose.these(enumeratorStack);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tflatten():Enumerable<any>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null; // Is endless is not affirmative if false.;\r\n\r\n\t\treturn new Enumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<any>;\r\n\t\t\t\tvar middleEnumerator:IEnumerator<any> = null;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(middleEnumerator)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tif(middleEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(middleEnumerator.current);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator.dispose();\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator = null;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar c = enumerator.current;\r\n\t\t\t\t\t\t\t\t// Because strings are enumerable, we can get stuck in an infinite loop.\r\n\t\t\t\t\t\t\t\t// Treat strings as primitives here.\r\n\t\t\t\t\t\t\t\tvar e = !Type.isString(c) && Enumerable.fromAny(c);\r\n\t\t\t\t\t\t\t\tif(e)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tmiddleEnumerator\r\n\t\t\t\t\t\t\t\t\t\t= e\r\n\t\t\t\t\t\t\t\t\t\t.selectMany(Functions.Identity)\r\n\t\t\t\t\t\t\t\t\t\t.flatten()\r\n\t\t\t\t\t\t\t\t\t\t.getEnumerator();\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(c);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, middleEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tpairwise<TSelect>(selector:(prev:T, current:T) => TSelect):Enumerable<TSelect>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<TSelect>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TSelect>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tenumerator.moveNext();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar prev = enumerator.current;\r\n\t\t\t\t\t\treturn enumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(selector(prev, enumerator.current));\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\tscan(func:(a:T, b:T) => T, seed?:T):Enumerable<T>\r\n\t{\r\n\r\n\t\tvar isUseSeed = seed!==VOID0; // For now...\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar value:T;\r\n\t\t\t\tvar isFirst:boolean;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tisFirst = true;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(isFirst)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\t//noinspection JSUnusedAssignment\r\n\t\t\t\t\t\t\treturn isUseSeed\r\n\t\t\t\t\t\t\t\t? yielder.yieldReturn(value = seed)\r\n\t\t\t\t\t\t\t\t: enumerator.moveNext() && yielder.yieldReturn(value\r\n\t\t\t\t\t\t\t\t= enumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(value = func(value, enumerator.current))\r\n\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):InfiniteEnumerable<TResult>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\treturn enumerator.moveNext()\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(selector(enumerator.current, index++))\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/*\r\n\tpublic static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(\r\n\t\tthis IEnumerable<TSource> source,\r\n\t\tFunc<TSource,IEnumerable<TCollection>> collectionSelector,\r\n\t\tFunc<TSource,TCollection,TResult> resultSelector)\r\n\t */\r\n\r\n\tprotected _selectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector?:(collection:T, element:TElement) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null; // Do second enumeration, it will be indeterminate if false.\r\n\t\tif(!resultSelector)\r\n\t\t\tresultSelector = (a:T, b:any) => <TResult>b;\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar middleEnumerator:IEnumerator<any>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tmiddleEnumerator = undefined;\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t// Just started, and nothing to enumerate? End.\r\n\t\t\t\t\t\tif(middleEnumerator===VOID0 && !enumerator.moveNext())\r\n\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t// moveNext has been called at least once...\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t// Initialize middle if there isn't one.\r\n\t\t\t\t\t\t\tif(!middleEnumerator)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar middleSeq = collectionSelector(enumerator.current, index++);\r\n\r\n\t\t\t\t\t\t\t\t// Collection is null?  Skip it...\r\n\t\t\t\t\t\t\t\tif(!middleSeq)\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t\tmiddleEnumerator = enumeratorFrom(middleSeq);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(middleEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\tresultSelector(\r\n\t\t\t\t\t\t\t\t\t\tenumerator.current, middleEnumerator.current\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// else no more in this middle?  Then clear and reset for next...\r\n\r\n\t\t\t\t\t\t\tmiddleEnumerator.dispose();\r\n\t\t\t\t\t\t\tmiddleEnumerator = null;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(enumerator.moveNext());\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, middleEnumerator);\r\n\t\t\t\t\t\tenumerator = null;\r\n\t\t\t\t\t\tmiddleEnumerator = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TResult>>):InfiniteEnumerable<TResult>;\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):InfiniteEnumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<any>>,\r\n\t\tresultSelector?:(collection:T, element:any) => TResult):InfiniteEnumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tprotected _choose<TResult>(selector:Selector<T, TResult>):Enumerable<TResult>\r\n\t{\r\n\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar result = selector(enumerator.current, index++);\r\n\t\t\t\t\t\t\tif(result!==null && result!==VOID0)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns selected values that are not null or undefined.\r\n\t */\r\n\tchoose():InfiniteEnumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):InfiniteEnumerable<TResult>\r\n\tchoose(selector:Selector<T, any> = Functions.Identity):InfiniteEnumerable<any>\r\n\t{\r\n\t\treturn this._choose(selector)\r\n\t}\r\n\r\n\twhere(predicate:Predicate<T>):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(predicate(enumerator.current, index++))\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\r\n\t}\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):InfiniteEnumerable<TType>;\r\n\tofType<TType>(type:any):InfiniteEnumerable<TType>\r\n\t{\r\n\t\tvar typeName:string;\r\n\t\tswitch(<any>type)\r\n\t\t{\r\n\t\t\tcase Number:\r\n\t\t\t\ttypeName = Type.NUMBER;\r\n\t\t\t\tbreak;\r\n\t\t\tcase String:\r\n\t\t\t\ttypeName = Type.STRING;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Boolean:\r\n\t\t\t\ttypeName = Type.BOOLEAN;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Function:\r\n\t\t\t\ttypeName = Type.FUNCTION;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn <Enumerable<any>>this\r\n\t\t\t\t\t.where(x=>x instanceof type);\r\n\t\t}\r\n\t\treturn <Enumerable<any>>this\r\n\t\t\t.choose()\r\n\t\t\t.where(x=>(typeof x)===typeName);\r\n\t}\r\n\r\n\texcept<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar keys:Dictionary<T, boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\tif(second)\r\n\t\t\t\t\t\t\tforEach(second, key => { keys.addByKeyValue(key, true) });\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar current = enumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tkeys.clear();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\tdistinct(compareSelector?:(value:T) => T):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn this.except(null, compareSelector);\r\n\t}\r\n\r\n\t// [0,0,0,1,1,1,2,2,2,0,0,0,1,1] results in [0,1,2,0,1];\r\n\tdistinctUntilChanged<TCompare>(compareSelector:Selector<T, TCompare> = Functions.Identity):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar compareKey:TCompare;\r\n\t\t\t\tvar initial:boolean = true;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar key = compareSelector(enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(initial)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinitial = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(Values.areEqual(compareKey, key))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcompareKey = key;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns a single default value if empty.\r\n\t * @param defaultValue\r\n\t * @returns {Enumerable}\r\n\t */\r\n\tdefaultIfEmpty(defaultValue:T = null):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed:boolean = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar isFirst:boolean;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisFirst = true;\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if(isFirst)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(defaultValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\tzip<TSecond, TResult>(\r\n\t\tsecond:IEnumerableOrArray<TSecond>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<TSecond>(second);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> firstEnumerator.moveNext()\r\n\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++)),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tzipMultiple<TSecond, TResult>(\r\n\t\tsecond:IArray<IEnumerableOrArray<TSecond>>,\r\n\t\tresultSelector:(first:T, second:TSecond, index?:number) => TResult):Enumerable<TResult>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!second.length)\r\n\t\t\treturn Enumerable.empty<TResult>();\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar secondTemp:Queue<any>;\r\n\t\t\t\tvar firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsecondTemp = new Queue<any>(second);\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\twhile(!secondEnumerator)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(secondTemp.count)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tvar next = secondTemp.dequeue();\r\n\t\t\t\t\t\t\t\t\t\tif(next) // In case by chance next is null, then try again.\r\n\t\t\t\t\t\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<TSecond>(next);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\t\tresultSelector(firstEnumerator.current, secondEnumerator.current, index++)\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tsecondEnumerator.dispose();\r\n\t\t\t\t\t\t\t\tsecondEnumerator = null;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondTemp);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #region Join Methods\r\n\r\n\tjoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner) => TResult,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):Enumerable<TResult>\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar outerEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar lookup:ILookup<TKey,TInner>;\r\n\t\t\t\tvar innerElements:TInner[] = null;\r\n\t\t\t\tvar innerCount:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\touterEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(innerElements!=null)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar innerElement = innerElements[innerCount++];\r\n\t\t\t\t\t\t\t\tif(innerElement!==VOID0)\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(outerEnumerator.current, innerElement));\r\n\r\n\t\t\t\t\t\t\t\tinnerElement = null;\r\n\t\t\t\t\t\t\t\tinnerCount = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(outerEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tvar key = outerKeySelector(outerEnumerator.current);\r\n\t\t\t\t\t\t\t\tinnerElements = lookup.get(key);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(outerEnumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgroupJoin<TInner, TKey, TResult, TCompare>(\r\n\t\tinner:IEnumerableOrArray<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner[]) => TResult,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):Enumerable<TResult>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar lookup:ILookup<TKey, TInner> = null;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\tenumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(\r\n\t\t\t\t\t\tresultSelector(\r\n\t\t\t\t\t\t\tenumerator.current,\r\n\t\t\t\t\t\t\tlookup.get(outerKeySelector(enumerator.current))\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tmerge(enumerables:IArray<IEnumerableOrArray<T>>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null;\r\n\r\n\t\tif(!enumerables || enumerables.length==0)\r\n\t\t\treturn _;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar queue:Queue<IEnumerableOrArray<T>>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 1) First get our values...\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tqueue = new Queue<IEnumerableOrArray<T>>(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\twhile(!enumerator && queue.count)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator = enumeratorFrom<T>(queue.dequeue()); // 4) Keep going and on to step 2.  Else fall through to yieldBreak().\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(enumerator && enumerator.moveNext()) // 2) Keep returning until done.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(enumerator) // 3) Dispose and reset for next.\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = null;\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, queue); // Just in case this gets disposed early.\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tconcat(...enumerables:Array<IEnumerableOrArray<T>>):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn this.merge(enumerables);\r\n\t}\r\n\r\n\r\n\tunion<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector:Selector<T, TCompare> = Functions.Identity):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this, isEndless = _._isEndless || null;\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar secondEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar keys:Dictionary<T, any>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, any>(compareSelector); // Acting as a HashSet.\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar current:T;\r\n\t\t\t\t\t\tif(secondEnumerator===VOID0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcurrent = firstEnumerator.current;\r\n\t\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsecondEnumerator = enumeratorFrom(second);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcurrent = secondEnumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tinsertAt(index:number, other:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tvar n:number = index;\r\n\r\n\t\tvar _ = this, isEndless = _._isEndless || null;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\r\n\t\t\t\tvar firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tvar secondEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\tvar count:number = 0;\r\n\t\t\t\tvar isEnumerated:boolean = false;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcount = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumeratorFrom<T>(other);\r\n\t\t\t\t\t\tisEnumerated = false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(count==n)\r\n\t\t\t\t\t\t{ // Inserting?\r\n\t\t\t\t\t\t\tisEnumerated = true;\r\n\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(firstEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn !isEnumerated\r\n\t\t\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(firstEnumerator, secondEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\talternateMultiple(sequence:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar buffer:T,\r\n\t\t\t\t    mode:EnumerableAction,\r\n\t\t\t\t    enumerator:IEnumerator<T>,\r\n\t\t\t\t    alternateEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Instead of recalling getEnumerator every time, just reset the existing one.\r\n\t\t\t\t\t\talternateEnumerator = new ArrayEnumerator(\r\n\t\t\t\t\t\t\tEnumerable.toArray<T>(sequence)\r\n\t\t\t\t\t\t); // Freeze\r\n\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tvar hasAtLeastOne = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = hasAtLeastOne\r\n\t\t\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(hasAtLeastOne)\r\n\t\t\t\t\t\t\tbuffer = enumerator.current;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tswitch(mode)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcase EnumerableAction.Break: // We're done?\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tcase EnumerableAction.Skip:\r\n\t\t\t\t\t\t\t\tif(alternateEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(alternateEnumerator.current);\r\n\t\t\t\t\t\t\t\talternateEnumerator.reset();\r\n\t\t\t\t\t\t\t\tmode = EnumerableAction.Return;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar latest = buffer;\r\n\r\n\t\t\t\t\t\t// Set up the next round...\r\n\r\n\t\t\t\t\t\t// Is there another one?  Set the buffer and setup instruct for the next one to be the alternate.\r\n\t\t\t\t\t\tvar another = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = another\r\n\t\t\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(another)\r\n\t\t\t\t\t\t\tbuffer = enumerator.current;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(latest);\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, alternateEnumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\talternateSingle(value:T):Enumerable<T>\r\n\t{\r\n\t\treturn this.alternateMultiple(Enumerable.make(value));\r\n\t}\r\n\r\n\talternate(...sequence:T[]):Enumerable<T>\r\n\t{\r\n\t\treturn this.alternateMultiple(sequence);\r\n\t}\r\n\r\n\r\n\t// #region Error Handling\r\n\tcatchError(handler:(e:any) => void):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Don't init...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\thandler(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tfinallyAction(action:() => void):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(enumerator.current)\r\n\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\taction();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tbuffer(size:number):InfiniteEnumerable<T[]>\r\n\t{\r\n\t\tif(size<1 || !isFinite(size))\r\n\t\t\tthrow new Error(\"Invalid buffer size.\");\r\n\r\n\t\tInteger.assert(size, \"size\");\r\n\r\n\t\tvar _ = this, len:number;\r\n\r\n\t\treturn new Enumerable<T[]>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\treturn new EnumeratorBase<T[]>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar array:T[] = ArrayUtility.initialize<T>(size);\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\twhile(len<size && enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tarray[len++] = enumerator.current;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tarray.length = len;\r\n\t\t\t\t\t\treturn len && yielder.yieldReturn(array);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tshare():InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar sharedEnumerator:IEnumerator<T>;\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\treturn sharedEnumerator || (sharedEnumerator = _.getEnumerator());\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdispose(sharedEnumerator);\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Enumerable<T> is a wrapper class that allows more primitive enumerables to exhibit LINQ behavior.\r\n *\r\n * In C# Enumerable<T> is not an instance but has extensions for IEnumerable<T>.\r\n * In this case, we use Enumerable<T> as the underlying class that is being chained.\r\n */\r\nexport class Enumerable<T>\r\nextends InfiniteEnumerable<T> implements ILinqEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:() => void,\r\n\t\tisEndless:boolean = null)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer);\r\n\t\tthis._isEndless = isEndless;\r\n\t}\r\n\r\n\t/**\r\n\t * Universal method for converting a primitive enumerables into a LINQ enabled ones.\r\n\t *\r\n\t * Is not limited to TypeScript usages.\r\n\t */\r\n\tstatic from<T>(source:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\tvar e = Enumerable.fromAny(source);\r\n\t\tif(!e) throw new UnsupportedEnumerableException();\r\n\t\treturn e;\r\n\t}\r\n\r\n\tstatic fromAny(\r\n\t\tsource:any):Enumerable<any>\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:IEnumerableOrArray<T>,\r\n\t\tdefaultEnumerable?:Enumerable<T>):Enumerable<T>\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:any,\r\n\t\tdefaultEnumerable?:Enumerable<T>):Enumerable<T>\r\n\r\n\tstatic fromAny<T>(\r\n\t\tsource:any,\r\n\t\tdefaultEnumerable:Enumerable<T> = null):Enumerable<T>\r\n\t{\r\n\t\tif(Type.isObject(source) || Type.isString(source))\r\n\t\t{\r\n\t\t\tif(source instanceof Enumerable)\r\n\t\t\t\treturn source;\r\n\r\n\t\t\tif(Type.isArrayLike<T>(source))\r\n\t\t\t\treturn new ArrayEnumerable<T>(source);\r\n\r\n\t\t\tif(isEnumerable<T>(source))\r\n\t\t\t\treturn new Enumerable<T>(\r\n\t\t\t\t\t()=>source.getEnumerator(),\r\n\t\t\t\t\tnull, source.isEndless);\r\n\t\t}\r\n\r\n\t\treturn defaultEnumerable;\r\n\t}\r\n\r\n\tstatic fromOrEmpty<T>(source:IEnumerableOrArray<T>):Enumerable<T>\r\n\t{\r\n\t\treturn Enumerable.fromAny(source) || Enumerable.empty<T>();\r\n\t}\r\n\r\n\t/**\r\n\t * Static helper for converting enumerables to an array.\r\n\t * @param source\r\n\t * @returns {any}\r\n\t */\r\n\tstatic toArray<T>(source:IEnumerableOrArray<T>):T[]\r\n\t{\r\n\t\tif(source instanceof Enumerable)\r\n\t\t\treturn source.toArray();\r\n\r\n\t\treturn toArray(source);\r\n\t}\r\n\r\n\r\n\t//////////////////////////////////////////\r\n\t// #region Static Methods...\r\n\tstatic choice<T>(values:IArray<T>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() => new EnumeratorBase<T>(\r\n\t\t\t\tnull,\r\n\t\t\t\t(yielder)=>\r\n\t\t\t\t\tyielder.yieldReturn(Integer.random.select(values)),\r\n\t\t\t\ttrue // Is endless!\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tstatic chooseFrom<T>(...args:T[]):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.choice(args);\r\n\t}\r\n\r\n\tstatic cycle<T>(values:IArray<T>):InfiniteEnumerable<T>\r\n\t{\r\n\t\tvar len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar index:number = 0;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t}, // Reinitialize the value just in case the enumerator is restarted.\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(index>=values.length) index = 0;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(values[index++]);\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic cycleThrough<T>(...args:T[]):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.cycle(args);\r\n\t}\r\n\r\n\tstatic empty<T>():FiniteEnumerable<T>\r\n\t{\r\n\t\t// Could be single static instance, but for safety, we'll make a new one.\r\n\t\treturn new FiniteEnumerable<T>(getEmptyEnumerator);\r\n\t}\r\n\r\n\tstatic repeat<T>(element:T):InfiniteEnumerable<T>;\r\n\tstatic repeat<T>(element:T, count:number):FiniteEnumerable<T>;\r\n\tstatic repeat<T>(element:T, count:number = Infinity):Enumerable<T>\r\n\t{\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t? new FiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar c:number = count;\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() => { index = 0; },\r\n\t\t\t\t\t(yielder)=> (index++<c) && yielder.yieldReturn(element),\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t)\r\n\t\t\t: new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t\tnew EnumeratorBase<T>(\r\n\t\t\t\t\tnull,\r\n\t\t\t\t\t(yielder)=> yielder.yieldReturn(element),\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t// Note: this enumeration is endless but can be disposed/cancelled and finalized.\r\n\tstatic repeatWithFinalize<T>(\r\n\t\tinitializer:() => T,\r\n\t\tfinalizer:(element:T) => void):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar element:T;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\telement = initializer();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> yielder.yieldReturn(element),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfinalizer(element);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an enumerable of one element.\r\n\t * @param element\r\n\t * @returns {FiniteEnumerable<T>}\r\n\t */\r\n\tstatic make<T>(element:T):FiniteEnumerable<T>\r\n\t{\r\n\t\treturn Enumerable.repeat<T>(element, 1);\r\n\t}\r\n\r\n\t// start and step can be other than integer.\r\n\r\n\tstatic range(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<number>();\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar value:number;\r\n\t\t\t\tvar c:number = count; // Force integer evaluation.\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar result:boolean =\r\n\t\t\t\t\t\t\t    index++<c\r\n\t\t\t\t\t\t\t    && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\tif(result && index<count)\r\n\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t}\r\n\r\n\tstatic rangeDown(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tstep = Math.abs(step)* -1;\r\n\r\n\t\treturn Enumerable.range(start, count, step);\r\n\t}\r\n\r\n\t// step = -1 behaves the same as toNegativeInfinity;\r\n\tstatic toInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number = 1):InfiniteEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\treturn new InfiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar current:number = value;\r\n\t\t\t\t\t\tvalue += step;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic toNegativeInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number = 1):InfiniteEnumerable<number>\r\n\t{\r\n\t\treturn Enumerable.toInfinity(start, -step);\r\n\t}\r\n\r\n\tstatic rangeTo(\r\n\t\tstart:number,\r\n\t\tto:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(isNaN(to) || !isFinite(to))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\r\n\r\n\t\tif(step && !isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\r\n\r\n\t\t// This way we adjust for the delta from start and to so the user can say +/- step and it will work as expected.\r\n\t\tstep = Math.abs(step);\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(() => { value = start; },\r\n\t\t\t\t\tstart<to\r\n\t\t\t\t\t\t?\r\n\t\t\t\t\t\tyielder=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar result:boolean = value<=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t:\r\n\t\t\t\t\t\tyielder=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar result:boolean = value>=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\t\tvalue -= step;\r\n\r\n\t\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t, false);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic matches(input:string, pattern:any, flags:string = \"\"):FiniteEnumerable<RegExpExecArray>\r\n\t{\r\n\t\tif(input===null || input===VOID0)\r\n\t\t\tthrow new ArgumentNullException(\"input\");\r\n\t\tvar type = typeof input;\r\n\t\tif(type!=Type.STRING)\r\n\t\t\tthrow new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tflags += (pattern.ignoreCase) ? \"i\" : \"\";\r\n\t\t\tflags += (pattern.multiline) ? \"m\" : \"\";\r\n\t\t\tpattern = pattern.source;\r\n\t\t}\r\n\r\n\t\tif(flags.indexOf(\"g\")=== -1) flags += \"g\";\r\n\r\n\t\treturn new FiniteEnumerable<RegExpExecArray>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar regex:RegExp;\r\n\t\t\t\treturn new EnumeratorBase<RegExpExecArray>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tregex = new RegExp(pattern, flags);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Calling regex.exec consecutively on the same input uses the lastIndex to start the next match.\r\n\t\t\t\t\t\tvar match = regex.exec(input);\r\n\t\t\t\t\t\treturn (match!==null) ? yielder.yieldReturn(match) : false;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic generate<T>(factory:(index?:number) => T):InfiniteEnumerable<T>;\r\n\tstatic generate<T>(factory:(index?:number) => T, count:number):FiniteEnumerable<T>;\r\n\tstatic generate<T>(factory:(index?:number) => T, count:number = Infinity):InfiniteEnumerable<T>\r\n\t{\r\n\r\n\t\tif(isNaN(count) || count<=0)\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t?\r\n\t\t\tnew FiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tvar c:number = count;\r\n\t\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar current:number = index++;\r\n\t\t\t\t\t\t\treturn current<c && yielder.yieldReturn(factory(current));\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\t);\r\n\t\t\t\t})\r\n\t\t\t:\r\n\t\t\tnew InfiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tvar index:number = 0;\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder)=> yielder.yieldReturn(factory(index++)),\r\n\r\n\t\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t\t);\r\n\t\t\t\t});\r\n\t}\r\n\r\n\tstatic unfold<T>(\r\n\t\tseed:T,\r\n\t\tvalueFactory:Selector<T, T>,\r\n\t\tskipSeed:Boolean = false):InfiniteEnumerable<T>\r\n\t{\r\n\t\treturn new InfiniteEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar index:number = 0;\r\n\t\t\t\tvar value:T;\r\n\t\t\t\tvar isFirst:boolean;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = seed;\r\n\t\t\t\t\t\tisFirst = !skipSeed;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvar i = index++;\r\n\t\t\t\t\t\tif(isFirst)\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvalue = valueFactory(value, i);\r\n\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tstatic forEach<T>(\r\n\t\tenumerable:IEnumerableOrArray<T>,\r\n\t\taction:(element:T, index?:number) => any,\r\n\t\tmax:number = Infinity):number\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn forEach(enumerable, action, max);\r\n\t}\r\n\r\n\tstatic map<T,TResult>(\r\n\t\tenumerable:IEnumerableOrArray<T>,\r\n\t\tselector:Selector<T,TResult>):TResult[]\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn map(enumerable, selector);\r\n\r\n\t}\r\n\r\n\t// Slightly optimized versions for numbers.\r\n\tstatic max(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\treturn values\r\n\t\t\t.takeUntil(v=> v== +Infinity, true)\r\n\t\t\t.aggregate(Functions.Greater);\r\n\t}\r\n\r\n\tstatic min(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\treturn values\r\n\t\t\t.takeUntil(v=> v== -Infinity, true)\r\n\t\t\t.aggregate(Functions.Lesser);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any set of collections of the same type and weaves them together.\r\n\t * @param enumerables\r\n\t * @returns {Enumerable<T>}\r\n\t */\r\n\tstatic weave<T>(\r\n\t\tenumerables:IEnumerableOrArray<IEnumerableOrArray<T>>):Enumerable<T>\r\n\t{\r\n\t\tif(!enumerables)\r\n\t\t\tthrow new ArgumentNullException('enumerables');\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar queue:Queue<IEnumerator<T>>;\r\n\t\t\t\tvar mainEnumerator:IEnumerator<IEnumerableOrArray<T>>;\r\n\t\t\t\tvar index:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tqueue = new Queue<IEnumerator<T>>();\r\n\t\t\t\t\t\tmainEnumerator = enumeratorFrom(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet e:IEnumerator<T>;\r\n\r\n\t\t\t\t\t\t// First pass...\r\n\t\t\t\t\t\tif(mainEnumerator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(!e && mainEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet c = mainEnumerator.current;\r\n\t\t\t\t\t\t\t\te = nextEnumerator(queue, c && enumeratorFrom(c));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!e)\r\n\t\t\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twhile(!e && queue.count)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\te = nextEnumerator(queue, queue.dequeue());\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn e\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(e.current)\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose.these(queue.dump());\r\n\t\t\t\t\t\tdispose(mainEnumerator, queue);\r\n\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t\tqueue = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tdoAction(\r\n\t\taction:Action<T>|Predicate<T>|Selector<T, number>|Selector<T, EnumerableAction>,\r\n\t\tinitializer?:()=>void,\r\n\t\tisEndless:boolean = this.isEndless):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.doAction(action, initializer, isEndless);\r\n\t}\r\n\r\n// #region Indexing/Paging methods.\r\n\r\n\tskip(count:number):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.skip(count);\r\n\t}\r\n\r\n\tskipWhile(predicate:Predicate<T>):Enumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t: EnumerableAction.Return\r\n\t\t);\r\n\t}\r\n\r\n\ttakeWhile(predicate:Predicate<T>):Enumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t: EnumerableAction.Break,\r\n\t\t\tnull,\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\t// Is like the inverse of take While with the ability to return the value identified by the predicate.\r\n\ttakeUntil(predicate:Predicate<T>, includeUntilValue?:boolean):Enumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\tif(!includeUntilValue)\r\n\t\t\treturn this.doAction(\r\n\t\t\t\t(element:T, index?:number) =>\r\n\t\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t\t? EnumerableAction.Break\r\n\t\t\t\t\t\t: EnumerableAction.Return,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t\t);\r\n\r\n\t\tvar found:boolean = false;\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index?:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(found)\r\n\t\t\t\t\treturn EnumerableAction.Break;\r\n\r\n\t\t\t\tfound = predicate(element, index);\r\n\t\t\t\treturn EnumerableAction.Return;\r\n\t\t\t},\r\n\t\t\t()=>\r\n\t\t\t{\r\n\t\t\t\tfound = false;\r\n\t\t\t},\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforEach(action:Predicate<T> | Action<T>):void\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tthrowIfEndless(_.isEndless);\r\n\r\n\t\tvar index:number = 0;\r\n\t\t// Return value of action can be anything, but if it is (===) false then the forEach will discontinue.\r\n\t\tusing(\r\n\t\t\t_.getEnumerator(), e=>\r\n\t\t\t{\r\n\t\t\t\tthrowIfEndless(e.isEndless);\r\n\r\n\t\t\t\t// It is possible that subsequently 'action' could cause the enumeration to dispose, so we have to check each time.\r\n\t\t\t\twhile(_.throwIfDisposed() && e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(action(e.current, index++)===false)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #region Conversion Methods\r\n\ttoArray(predicate?:Predicate<T>):T[]\r\n\t{\r\n\t\treturn predicate\r\n\t\t\t? this.where(predicate).toArray()\r\n\t\t\t: this.copyTo([]);\r\n\t}\r\n\r\n\tcopyTo(target:T[], index:number = 0, count:number = Infinity):T[]\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(!target) throw new ArgumentNullException(\"target\");\r\n\t\tInteger.assertZeroOrGreater(index);\r\n\r\n\t\t// If not exposing an action that could cause dispose, then use forEach utility instead.\r\n\t\tforEach<T>(this, (x, i)=>\r\n\t\t{\r\n\t\t\ttarget[i + index] = x\r\n\t\t}, count);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\ttoLookup<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TValue> = Functions.Identity,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):ILookup<TKey, TValue>\r\n\t{\r\n\t\tvar dict:Dictionary<TKey, TValue[]> = new Dictionary<TKey, TValue[]>(compareSelector);\r\n\t\tthis.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tvar key = keySelector(x);\r\n\t\t\t\tvar element = elementSelector(x);\r\n\r\n\t\t\t\tvar array = dict.getValue(key);\r\n\t\t\t\tif(array!==VOID0) array.push(element);\r\n\t\t\t\telse dict.addByKeyValue(key, [element]);\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn new Lookup<TKey, TValue>(dict);\r\n\t}\r\n\r\n\ttoMap<TResult>(\r\n\t\tkeySelector:Selector<T, string>,\r\n\t\telementSelector:Selector<T, TResult>):IMap<TResult>\r\n\t{\r\n\t\tvar obj:IMap<TResult> = {};\r\n\t\tthis.forEach((x, i)=>\r\n\t\t{\r\n\t\t\tobj[keySelector(x, i)] = elementSelector(x, i);\r\n\t\t});\r\n\t\treturn obj;\r\n\t}\r\n\r\n\ttoDictionary<TKey, TValue, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TValue>,\r\n\t\tcompareSelector:Selector<TKey, TCompare> = Functions.Identity):IDictionary<TKey, TValue>\r\n\t{\r\n\t\tvar dict:Dictionary<TKey, TValue> = new Dictionary<TKey, TValue>(compareSelector);\r\n\t\tthis.forEach((x, i)=> dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)));\r\n\t\treturn dict;\r\n\t}\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\treturn this.select(selector).toArray().join(separator);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\ttakeExceptLast(count:number = 1):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!(count>0)) // Out of bounds?\r\n\t\t\treturn _;\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\t\tvar c = count;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar q:Queue<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tq = new Queue<T>();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Add the next one to the queue.\r\n\t\t\t\t\t\t\tq.enqueue(enumerator.current);\r\n\r\n\t\t\t\t\t\t\t// Did we reach our quota?\r\n\t\t\t\t\t\t\tif(q.count>c)\r\n\t\t\t\t\t\t\t// Okay then, start returning results.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(q.dequeue());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, q);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tskipToLast(count:number):Enumerable<T>\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!isFinite(count)) // Infinity means return all.\r\n\t\t\treturn _;\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// This sets up the query so nothing is done until move next is called.\r\n\t\treturn _.reverse()\r\n\t\t\t.take(count)\r\n\t\t\t.reverse();\r\n\t}\r\n\r\n\t// To help with type guarding.\r\n\r\n\twhere(predicate:Predicate<T>):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.where(predicate);\r\n\t}\r\n\r\n\tselect<TResult>(selector:Selector<T, TResult>):Enumerable<TResult>\r\n\t{\r\n\t\treturn <Enumerable<TResult>>super.select(selector);\r\n\t}\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TResult>>):Enumerable<TResult>;\r\n\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<TElement>>,\r\n\t\tresultSelector:(collection:T, element:TElement)=>TResult):Enumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:Selector<T, IEnumerableOrArray<any>>,\r\n\t\tresultSelector?:(collection:T, element:any)=>TResult):Enumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tchoose():Enumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):Enumerable<TResult>\r\n\tchoose(selector:Selector<T, any> = Functions.Identity):Enumerable<any>\r\n\t{\r\n\t\treturn this._choose(selector);\r\n\t}\r\n\r\n\treverse():Enumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot reverse an endless collection...\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar buffer:T[];\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tindex = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=> index && yielder.yieldReturn(buffer[--index]),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tshuffle():Enumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot shuffle an endless collection...\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar buffer:T[];\r\n\t\t\t\tvar capacity:number;\r\n\t\t\t\tvar len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tcapacity = len = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Avoid using major array operations like .slice();\r\n\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tvar selectedIndex = Integer.random(len);\r\n\t\t\t\t\t\tvar selectedValue = buffer[selectedIndex];\r\n\r\n\t\t\t\t\t\tbuffer[selectedIndex] = buffer[--len]; // Take the last one and put it here.\r\n\t\t\t\t\t\tbuffer[len] = null; // clear possible reference.\r\n\r\n\t\t\t\t\t\tif(len%32==0) // Shrink?\r\n\t\t\t\t\t\t\tbuffer.length = len;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(selectedValue);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tcount(predicate?:Predicate<T>):number\r\n\t{\r\n\t\tvar count:number = 0;\r\n\t\tthis.forEach(\r\n\t\t\tpredicate\r\n\r\n\t\t\t\t?\r\n\t\t\t\t(x, i) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(predicate(x, i))++count;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t:\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\t++count;\r\n\t\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\t// Akin to '.every' on an array.\r\n\tall(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException(\"predicate\");\r\n\r\n\t\tvar result = true;\r\n\t\tthis.forEach((x, i) =>\r\n\t\t{\r\n\t\t\tif(!predicate(x, i))\r\n\t\t\t{\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn false; // break\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// 'every' has been added here for parity/compatibility with an array.\r\n\tevery(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\treturn this.all(predicate);\r\n\t}\r\n\r\n\t// Akin to '.some' on an array.\r\n\tany(predicate?:Predicate<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\treturn super.any();\r\n\r\n\t\tvar result = false;\r\n\t\t// Splitting the forEach up this way reduces iterative processing.\r\n\t\t// forEach handles the generation and disposal of the enumerator.\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tresult = predicate(x, i); // false = not found and therefore it should continue.  true = found and break;\r\n\t\t\t\treturn !result;\r\n\t\t\t});\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t// 'some' has been added here for parity/compatibility with an array.\r\n\tsome(predicate:Predicate<T>):boolean\r\n\t{\r\n\t\treturn this.any(predicate);\r\n\t}\r\n\r\n\r\n\tcontains<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):boolean\r\n\t{\r\n\t\treturn compareSelector\r\n\t\t\t? this.any(v=> compareSelector(v)===compareSelector(value))\r\n\t\t\t: this.any(v=> v===value);\r\n\t}\r\n\r\n\t// Originally has an overload for a predicate,\r\n\t// but that's a bad idea since this could be an enumeration of functions and therefore fail the intent.\r\n\t// Better to chain a where statement first to be more explicit.\r\n\tindexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number\r\n\t{\r\n\t\tvar found:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t?\r\n\t\t\t\t(element:T, i?:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(compareSelector(element, i), compareSelector(value, i), true))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = i;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t:\r\n\t\t\t\t(element:T, i?:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\t// Why?  Because NaN doesn't equal NaN. :P\r\n\t\t\t\t\tif(Values.areEqual(element, value, true))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfound = i;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\r\n\r\n\t\treturn found;\r\n\t}\r\n\r\n\tlastIndexOf<TCompare>(value:T, compareSelector?:Selector<T, TCompare>):number\r\n\t{\r\n\t\tvar result:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t?\r\n\t\t\t\t(element:T, i?:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(compareSelector(element, i), compareSelector(value, i), true)) result\r\n\t\t\t\t\t\t= i;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t:\r\n\t\t\t\t(element:T, i?:number) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(Values.areEqual(element, value, true)) result = i;\r\n\t\t\t\t});\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tmerge(enumerables:IArray<IEnumerableOrArray<T>>):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.merge(enumerables);\r\n\t}\r\n\r\n\tconcat(...enumerables:Array<IEnumerableOrArray<T>>):Enumerable<T>\r\n\t{\r\n\t\treturn this.merge(enumerables);\r\n\t}\r\n\r\n\r\n\tintersect<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar keys:Dictionary<T,boolean>;\r\n\t\t\t\tvar outs:Dictionary<T,boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\touts = new Dictionary<T, boolean>(compareSelector);\r\n\r\n\t\t\t\t\t\tforEach(second, key=>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tkeys.addByKeyValue(key, true);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tvar current = enumerator.current;\r\n\t\t\t\t\t\t\tif(!outs.containsKey(current) && keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\touts.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator, keys, outs);\r\n\t\t\t\t\t},\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t{\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te1=> using(\r\n\t\t\t\tenumeratorFrom(second),\r\n\t\t\t\te2=>\r\n\t\t\t\t{\r\n\t\t\t\t\t// if both are endless, this will never evaluate.\r\n\t\t\t\t\tthrowIfEndless(e1.isEndless && e2.isEndless);\r\n\r\n\t\t\t\t\twhile(e1.moveNext())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!e2.moveNext() || !equalityComparer(e1.current, e2.current))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn !e2.moveNext();\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t//isEquivalent(second:IEnumerableOrArray<T>,\r\n\t//\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t//{\r\n\t//\treturn this\r\n\t//\t\t.orderBy(keySelector)\r\n\t//\t\t.sequenceEqual(Enumerable.from(second).orderBy(keySelector))\r\n\t//}\r\n\r\n\r\n\t// #endregion\r\n\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):Enumerable<TType>;\r\n\tofType<TType>(type:any):Enumerable<TType>\r\n\t{\r\n\t\treturn <Enumerable<TType>>super.ofType(type);\r\n\t}\r\n\r\n\texcept<TCompare>(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tcompareSelector?:Selector<T, TCompare>):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.except(second, compareSelector);\r\n\t}\r\n\r\n\tdistinct(compareSelector?:(value:T)=>T):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.distinct(compareSelector);\r\n\t}\r\n\r\n\tdistinctUntilChanged<TCompare>(compareSelector:Selector<T, TCompare> = Functions.Identity):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.distinctUntilChanged(compareSelector);\r\n\t}\r\n\r\n// #region Ordering Methods\r\n\r\n\torderBy<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TKey>(this, keySelector, Order.Ascending);\r\n\t}\r\n\r\n\torderUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this, null, Order.Ascending, null, comparison);\r\n\t}\r\n\r\n\torderUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this, null, Order.Descending, null, comparison);\r\n\t}\r\n\r\n\torderByDescending<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TKey>(this, keySelector, Order.Descending);\r\n\t}\r\n\r\n\t/*\r\n\t\t weightedSample(weightSelector) {\r\n\t\t weightSelector = Utils.createLambda(weightSelector);\r\n\t\t var source = this;\r\n\r\n\t\t return new Enumerable<T>(() => {\r\n\t\t var sortedByBound;\r\n\t\t var totalWeight = 0;\r\n\r\n\t\t return new EnumeratorBase<T>(\r\n\t\t () => {\r\n\t\t sortedByBound = source\r\n\t\t .choose(function (x) {\r\n\t\t var weight = weightSelector(x);\r\n\t\t if (weight <= 0) return null; // ignore 0\r\n\r\n\t\t totalWeight += weight;\r\n\t\t return { value: x, bound: totalWeight }\r\n\t\t })\r\n\t\t .toArray();\r\n\t\t },\r\n\t\t () => {\r\n\t\t if (sortedByBound.length > 0) {\r\n\t\t var draw = (Math.random() * totalWeight) + 1;\r\n\r\n\t\t var lower = -1;\r\n\t\t var upper = sortedByBound.length;\r\n\t\t while (upper - lower > 1) {\r\n\t\t var index = ((lower + upper) / 2);\r\n\t\t if (sortedByBound[index].bound >= draw) {\r\n\t\t upper = index;\r\n\t\t }\r\n\t\t else {\r\n\t\t lower = index;\r\n\t\t }\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldReturn(sortedByBound[upper].value);\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldBreak();\r\n\t\t },\r\n\t\t Functions.Blank);\r\n\t\t });\r\n\t\t }\r\n\t\t */\r\n\t// #endregion\r\n\r\n\tbuffer(size:number):Enumerable<T[]>\r\n\t{\r\n\t\treturn <Enumerable<T[]>>super.buffer(size);\r\n\t}\r\n\r\n\t// #region Grouping Methods\r\n\r\n\t// Originally contained a result selector (not common use), but this could be done simply by a select statement after.\r\n\r\n\r\n\tgroupBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tgroupBy<TKey, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, T>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, T>>;\r\n\tgroupBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new Enumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() => this.toLookup(keySelector, elementSelector, compareSelector)\r\n\t\t\t\t.getEnumerator()\r\n\t\t);\r\n\t}\r\n\r\n\tpartitionBy<TKey>(keySelector:Selector<T, TKey>):Enumerable<IGrouping<TKey, T>>;\r\n\tpartitionBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector:Selector<T, TElement>,\r\n\t\tresultSelector?:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, TCompare>):Enumerable<IGrouping<TKey, TElement>>;\r\n\tpartitionBy<TKey, TElement, TCompare>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tresultSelector:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>\r\n\t\t\t= (key:TKey, elements:TElement[]) => new Grouping<TKey, TElement>(key, elements),\r\n\t\tcompareSelector:Selector<TKey, TCompare>\r\n\t\t\t= Functions.Identity):Enumerable<IGrouping<TKey, T>>|Enumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new Enumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvar enumerator:IEnumerator<T>;\r\n\t\t\t\tvar key:TKey;\r\n\t\t\t\tvar compareKey:TCompare;\r\n\t\t\t\tvar group:TElement[];\r\n\t\t\t\tvar len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<IGrouping<TKey, TElement>>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tkey = keySelector(enumerator.current);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector(enumerator.current)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!group)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tvar hasNext:boolean, c:T;\r\n\t\t\t\t\t\twhile((hasNext = enumerator.moveNext()))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = enumerator.current;\r\n\t\t\t\t\t\t\tif(compareKey===compareSelector(keySelector(c)))\r\n\t\t\t\t\t\t\t\tgroup[len++] = elementSelector(c);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tvar result:IGrouping<TKey, TElement>\r\n\t\t\t\t\t\t\t    = resultSelector(key, group);\r\n\r\n\t\t\t\t\t\tif(hasNext)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = enumerator.current;\r\n\t\t\t\t\t\t\tkey = keySelector(c);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector(c)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tdispose(enumerator);\r\n\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Aggregate Methods\r\n\r\n\taggregate(\r\n\t\tfunc:(a:T, b:T) => T,\r\n\t\tseed?:T):T\r\n\t{\r\n\t\treturn this.scan(func, seed).lastOrDefault();\r\n\t}\r\n\r\n\taverage(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar count = 0;\r\n\t\tvar sum = this.sum((e, i)=>\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\treturn selector(e, i);\r\n\t\t});\r\n\r\n\t\treturn (isNaN(sum) || !count)\r\n\t\t\t? NaN\r\n\t\t\t: (sum/count);\r\n\t}\r\n\r\n\t// If using numbers, it may be useful to call .takeUntil(v=>v==Infinity,true) before calling max. See static versions for numbers.\r\n\tmax():T\r\n\t{\r\n\t\treturn this.aggregate(Functions.Greater);\r\n\t}\r\n\r\n\tmin():T\r\n\t{\r\n\t\treturn this.aggregate(Functions.Lesser);\r\n\t}\r\n\r\n\tmaxBy<TCompare>(keySelector:Selector<T, TCompare> = Functions.Identity):T\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)>keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\tminBy<TCompare>(keySelector:Selector<T, TCompare> = Functions.Identity):T\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)<keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\t// Addition...  Only works with numerical enumerations.\r\n\tsum(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar sum = 0;\r\n\r\n\t\t// This allows for infinity math that doesn't destroy the other values.\r\n\t\tvar sumInfinite = 0; // Needs more investigation since we are really trying to retain signs.\r\n\r\n\t\tthis.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tvar value = selector(x);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tsum = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif(isFinite(value))\r\n\t\t\t\t\tsum += value;\r\n\t\t\t\telse\r\n\t\t\t\t\tsumInfinite +=\r\n\t\t\t\t\t\tvalue>0 ?\r\n\t\t\t\t\t\t\t(+1) :\r\n\t\t\t\t\t\t\t(-1);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite*Infinity) : sum);\r\n\t}\r\n\r\n\t// Multiplication...\r\n\tproduct(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar result = 1, exists:boolean = false;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i)=>\r\n\t\t\t{\r\n\t\t\t\texists = true;\r\n\t\t\t\tvar value = selector(x, i);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(value==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = 0; // Multiplying by zero will always end in zero.\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Multiplication can never recover from infinity and simply must retain signs.\r\n\t\t\t\t// You could cancel out infinity with 1/infinity but no available representation exists.\r\n\t\t\t\tresult *= value;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn (exists && isNaN(result)) ? NaN : result;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes the first number and divides it by all following.\r\n\t * @param selector\r\n\t * @returns {number}\r\n\t */\r\n\tquotient(selector:Selector<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tvar count = 0;\r\n\t\tvar result:number = NaN;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i)=>\r\n\t\t\t{\r\n\t\t\t\tvar value = selector(x, i);\r\n\t\t\t\tcount++;\r\n\r\n\t\t\t\tif(count===1)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = value;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(isNaN(value) || value===0 || !isFinite(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult /= value;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(count===1)\r\n\t\t\tresult = NaN;\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Single Value Return...\r\n\r\n\tlast():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar value:T = undefined;\r\n\t\tvar found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx =>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(!found) throw new Error(\"last:No element satisfies the condition.\");\r\n\t\treturn value;\r\n\t}\r\n\r\n\tlastOrDefault(defaultValue:T = null):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar value:T = undefined;\r\n\t\tvar found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx=>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn (!found) ? defaultValue : value;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tshare():Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.share();\r\n\t}\r\n\r\n\r\n\tcatchError(handler:(e:any)=>void):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.catchError(handler);\r\n\t}\r\n\r\n\r\n\tfinallyAction(action:()=>void):Enumerable<T>\r\n\t{\r\n\t\treturn <Enumerable<T>>super.finallyAction(action);\r\n\t}\r\n\r\n\tmemoize():Enumerable<T>\r\n\t{\r\n\t\tvar _ = this, disposed:boolean = !_.throwIfDisposed();\r\n\r\n\t\tvar cache:T[];\r\n\t\tvar enumerator:IEnumerator<T>;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\r\n\t\t\t\tvar index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tif(!enumerator)\r\n\t\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tif(!cache)\r\n\t\t\t\t\t\t\tcache = [];\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder)=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tvar i = index++;\r\n\r\n\t\t\t\t\t\tif(i>=cache.length)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t\t? yielder.yieldReturn(cache[i] = enumerator.current)\r\n\t\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(cache[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t\tif(cache)\r\n\t\t\t\t\tcache.length = 0;\r\n\t\t\t\tcache = null;\r\n\r\n\t\t\t\tdispose(enumerator);\r\n\t\t\t\tenumerator = null;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n// Provided for type guarding.\r\nexport class FiniteEnumerable<T>\r\nextends Enumerable<T> implements IFiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:() => void)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer, false);\r\n\t}\r\n\r\n}\r\n\r\nclass ArrayEnumerable<T>\r\nextends FiniteEnumerable<T>\r\n{\r\n\tprivate _source:IArray<T>;\r\n\r\n\tconstructor(source:IArray<T>)\r\n\t{\r\n\t\tsuper(() =>\r\n\t\t{\r\n\t\t\t_.throwIfDisposed();\r\n\t\t\treturn new ArrayEnumerator<T>(() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\r\n\r\n\t\t\t\treturn _._source; // Should never be null, but ArrayEnumerable if not disposed simply treats null as empty array.\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tvar _ = this;\r\n\t\t_._disposableObjectName = \"ArrayEnumerable\";\r\n\t\t_._source = source;\r\n\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._source = <any>null;\r\n\t}\r\n\r\n\tget source():IArray<T>\r\n\t{\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn toArray(_._source);\r\n\t}\r\n\r\n\tasEnumerable():ArrayEnumerable<T>\r\n\t{\r\n\t\treturn new ArrayEnumerable<T>(this._source);\r\n\t}\r\n\r\n\t// Optimize forEach so that subsequent usage is optimized.\r\n\tforEach(action:Predicate<T> | Action<T>, max:number = Infinity):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn forEach(_._source, action, max);\r\n\t}\r\n\r\n\t// These methods should ALWAYS check for array length before attempting anything.\r\n\r\n\tany(predicate?:Predicate<T>):boolean\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn len && (!predicate || super.any(predicate));\r\n\t}\r\n\r\n\tcount(predicate?:Predicate<T>):number\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn len && (predicate ? super.count(predicate) : len);\r\n\t}\r\n\r\n\telementAtOrDefault(index:number, defaultValue:T = null):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\r\n\t\tvar source = _._source;\r\n\t\treturn index<source.length\r\n\t\t\t? source[index]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tlast():T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn (len)\r\n\t\t\t? source[len - 1]\r\n\t\t\t: super.last();\r\n\t}\r\n\r\n\tlastOrDefault(defaultValue:T = null):T\r\n\t{\r\n\t\tvar _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tvar source = _._source, len = source.length;\r\n\t\treturn len\r\n\t\t\t? source[len - 1]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tskip(count:number):Enumerable<T>\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn _;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() => new ArrayEnumerator<T>(() => _._source, count)\r\n\t\t);\r\n\t}\r\n\r\n\ttakeExceptLast(count:number = 1):Enumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\treturn _.take(_._source.length - count);\r\n\t}\r\n\r\n\tskipToLast(count:number):Enumerable<T>\r\n\t{\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tvar _ = this;\r\n\t\tif(!isFinite(count))\r\n\t\t\treturn _;\r\n\r\n\t\tvar len = _._source\r\n\t\t\t? _._source.length\r\n\t\t\t: 0;\r\n\r\n\t\treturn _.skip(len - count);\r\n\t}\r\n\r\n\treverse():Enumerable<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\r\n\t\treturn new Enumerable<T>(\r\n\t\t\t() => new ArrayEnumerator<T>(\r\n\t\t\t\t() => _._source, _._source\r\n\t\t\t\t\t? (_._source.length - 1)\r\n\t\t\t\t\t: 0, -1\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\tmemoize():ArrayEnumerable<T>\r\n\t{\r\n\t\treturn this.asEnumerable();\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:IEnumerableOrArray<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n\t{\r\n\t\tif(Type.isArrayLike(second))\r\n\t\t\treturn Arrays.areEqual(this.source, second, true, equalityComparer);\r\n\r\n\t\tif(second instanceof ArrayEnumerable)\r\n\t\t\treturn second.sequenceEqual(this.source, equalityComparer);\r\n\r\n\t\treturn super.sequenceEqual(second, equalityComparer);\r\n\t}\r\n\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\tvar s = this._source;\r\n\t\treturn !selector && Array.isArray(s)\r\n\t\t\t? (<Array<T>>s).join(separator)\r\n\t\t\t: super.toJoinedString(separator, selector);\r\n\t}\r\n\r\n}\r\n\r\nclass Grouping<TKey, TElement>\r\nextends ArrayEnumerable<TElement> implements IGrouping<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _groupKey:TKey, elements:TElement[])\r\n\t{\r\n\t\tsuper(elements);\r\n\t}\r\n\r\n\tget key():TKey\r\n\t{\r\n\t\treturn this._groupKey;\r\n\t}\r\n}\r\n\r\nclass Lookup<TKey, TElement>\r\nimplements ILookup<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _dictionary:IDictionary<TKey, TElement[]>)\r\n\t{\r\n\t}\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._dictionary.count;\r\n\t}\r\n\r\n\tget(key:TKey):TElement[]\r\n\t{\r\n\t\treturn this._dictionary.getValue(key);\r\n\t}\r\n\r\n\tcontains(key:TKey):boolean\r\n\t{\r\n\t\treturn this._dictionary.containsKey(key);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<Grouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tvar _ = this;\r\n\t\tvar enumerator:IEnumerator<IKeyValuePair<TKey, TElement[]>>;\r\n\r\n\t\treturn new EnumeratorBase<Grouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tenumerator = _._dictionary.getEnumerator();\r\n\t\t\t},\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(!enumerator.moveNext())\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\tvar current = enumerator.current;\r\n\r\n\t\t\t\treturn yielder.yieldReturn(new Grouping<TKey, TElement>(current.key, current.value));\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdispose(enumerator);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\n\r\nclass OrderedEnumerable<T,TOrderBy extends Comparable>\r\nextends FiniteEnumerable<T> implements IOrderedEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tprivate source:IEnumerable<T>,\r\n\t\tpublic keySelector:(value:T) => TOrderBy,\r\n\t\tpublic order:Order,\r\n\t\tpublic parent?:OrderedEnumerable<T,any>,\r\n\t\tpublic comparer:Comparison<T> = Values.compare)\r\n\t{\r\n\t\tsuper(null);\r\n\t\tthrowIfEndless(source && source.isEndless);\r\n\t}\r\n\r\n\tprivate createOrderedEnumerable(\r\n\t\tkeySelector:(value:T) => TOrderBy,\r\n\t\torder:Order):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,TOrderBy>(this.source, keySelector, order, this);\r\n\t}\r\n\r\n\tthenBy(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Ascending);\r\n\t}\r\n\r\n\tthenUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this.source, null, Order.Ascending, this, comparison);\r\n\t}\r\n\r\n\tthenByDescending(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Descending);\r\n\t}\r\n\r\n\tthenUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T,any>(this.source, null, Order.Descending, this, comparison);\r\n\t}\r\n\r\n\tgetEnumerator():EnumeratorBase<T>\r\n\t{\r\n\t\tvar _ = this;\r\n\t\tvar buffer:T[];\r\n\t\tvar indexes:number[];\r\n\t\tvar index:number = 0;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tbuffer = Enumerable.toArray(_.source);\r\n\t\t\t\tindexes = createSortContext(_).generateSortedIndexes(buffer);\r\n\t\t\t},\r\n\r\n\t\t\t(yielder)=>\r\n\t\t\t{\r\n\t\t\t\treturn (index<indexes.length)\r\n\t\t\t\t\t? yielder.yieldReturn(buffer[indexes[index++]])\r\n\t\t\t\t\t: false;\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(buffer)\r\n\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\tbuffer = null;\r\n\t\t\t\tif(indexes)\r\n\t\t\t\t\tindexes.length = 0;\r\n\t\t\t\tindexes = null;\r\n\t\t\t},\r\n\r\n\t\t\tfalse\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis.source = null;\r\n\t\tthis.keySelector = null;\r\n\t\tthis.order = null;\r\n\t\tthis.parent = null;\r\n\t}\r\n\r\n}\r\n\r\n// A private static helper for the weave function.\r\nfunction nextEnumerator<T>(queue:Queue<IEnumerator<T>>, e:IEnumerator<T>):IEnumerator<T>\r\n{\r\n\tif(e)\r\n\t{\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tqueue.enqueue(e);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tdispose(e);\r\n\t\t\te = null;\r\n\t\t}\r\n\t}\r\n\treturn e;\r\n}\r\n\r\n/**\r\n * Recursively builds a SortContext chain.\r\n * @param orderedEnumerable\r\n * @param currentContext\r\n * @returns {any}\r\n */\r\nfunction createSortContext<T, TOrderBy extends Comparable>(\r\n\torderedEnumerable:OrderedEnumerable<T,TOrderBy>,\r\n\tcurrentContext:IComparer<T> = null):KeySortedContext<T, TOrderBy>\r\n{\r\n\r\n\tvar context = new KeySortedContext<T, TOrderBy>(\r\n\t\tcurrentContext,\r\n\t\torderedEnumerable.keySelector,\r\n\t\torderedEnumerable.order,\r\n\t\torderedEnumerable.comparer);\r\n\r\n\tif(orderedEnumerable.parent)\r\n\t\treturn createSortContext(orderedEnumerable.parent, context);\r\n\r\n\treturn context;\r\n}\r\n\r\n// #region Helper Functions...\r\n// This allows for the use of a boolean instead of calling this.throwIfDisposed()\r\n// since there is a strong chance of introducing a circular reference.\r\nfunction throwIfDisposed(disposed:boolean):void\r\n{\r\n\tif(disposed) throw new ObjectDisposedException(\"Enumerable\");\r\n}\r\n// #endregion\r\n\r\nexport default Enumerable;\r\n"]}