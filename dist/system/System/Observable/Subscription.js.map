{"version":3,"sources":["System/Observable/Subscription.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;;;;;;;;YASH;gBAEC,sBACS,aAA8B,EAC9B,WAAa;oBADb,kBAAa,GAAb,aAAa,CAAiB;oBAC9B,gBAAW,GAAX,WAAW,CAAE;oBAErB,EAAE,CAAA,CAAC,CAAC,aAAa,IAAI,CAAC,WAAW,CAAC;wBACjC,MAAM,6CAA6C,CAAC;gBACtD,CAAC;gBAED,sBAAI,oCAAU;yBAAd;wBAEC,MAAM,CAAC,IAAI,CAAC,WAAW,CAAC;oBACzB,CAAC;;;mBAAA;gBAiBD,sBAAI,qCAAW;yBAAf;wBAEC,MAAM,CAAC,CAAC,IAAI,CAAC,aAAa,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC;oBACjD,CAAC;;;mBAAA;gBAED,8BAAO,GAAP;oBAEC,IAAI,UAAU,GAAG,IAAI,CAAC,UAAU,CAAC;oBACjC,IAAI,YAAY,GAAG,IAAI,CAAC,aAAa,CAAC;oBAGtC,IAAI,CAAC,aAAa,GAAQ,IAAI,CAAC;oBAE/B,IACA,CAAC;wBACA,EAAE,CAAA,CAAC,UAAU,IAAI,YAAY,CAAC,CAC9B,CAAC;4BACA,YAAY,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;wBACtC,CAAC;oBACF,CAAC;4BAED,CAAC;wBAEA,IAAI,CAAC,WAAW,GAAQ,IAAI,CAAC;oBAC9B,CAAC;gBACF,CAAC;gBACF,mBAAC;YAAD,CAxDA,AAwDC,IAAA;YAxDD,uCAwDC,CAAA;YAED,oBAAe,YAAY,EAAC","file":"System/Observable/Subscription.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based upon .NET source.\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Source: http://referencesource.microsoft.com/#mscorlib/system/IObserver.cs\r\n */\r\n\r\n\r\nimport {IDisposableAware} from \"../Disposable/IDisposableAware\";\r\nimport {ISubscribable} from \"./ISubscribable\"; // For compatibility with (let, const, function, class);\r\n\r\n/**\r\n * A registration that an IObservable returns that can be disposed in order to cancel sending data to the observer.\r\n */\r\nexport class Subscription<T> implements IDisposableAware\r\n{\r\n\tconstructor(\r\n\t\tprivate _subscribable:ISubscribable<T>,\r\n\t\tprivate _subscriber:T)\r\n\t{\r\n\t\tif(!_subscribable || !_subscriber)\r\n\t\t\tthrow 'Subscribable and subscriber cannot be null.';\r\n\t}\r\n\r\n\tget subscriber():T\r\n\t{\r\n\t\treturn this._subscriber;\r\n\t}\r\n\r\n\t/*\r\n\t In the case where we could possibly have the following happen:\r\n\r\n\t var u = observable.subscribe(observer);\r\n\r\n\t ...\r\n\r\n\t u.dispose(); // Should only be allowed to unsubscribe once and then it's useless.\r\n\r\n\t // Resubscribing creates a new instance.\r\n\t var x = observable.subscribe(observer);\r\n\r\n\t u.dispose(); // Calling this again should do nothing and 'x' should still work.\r\n\t */\r\n\r\n\tget wasDisposed():boolean\r\n\t{\r\n\t\treturn !this._subscribable || !this._subscriber;\r\n\t}\r\n\r\n\tdispose():void\r\n\t{\r\n\t\tvar subscriber = this.subscriber;\r\n\t\tvar subscribable = this._subscribable;\r\n\r\n\t\t// Release this reference.  It will prevent potential unwanted recursion.\r\n\t\tthis._subscribable = <any>null;\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tif(subscriber && subscribable)\r\n\t\t\t{\r\n\t\t\t\tsubscribable.unsubscribe(subscriber);\r\n\t\t\t}\r\n\t\t}\r\n\t\tfinally\r\n\t\t{\r\n\t\t\t// Keep this reference until the end so it can be identified by the list.\r\n\t\t\tthis._subscriber = <any>null;\r\n\t\t}\r\n\t}\r\n}\r\n\r\nexport default Subscription;\r\n"]}