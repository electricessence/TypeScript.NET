{"version":3,"sources":["System/Events/EventDispatcherBase.ts"],"names":[],"mappings":"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","file":"EventDispatcherBase.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport * as AU from \"../Collections/Array/Utility\";\r\nimport {shallowCopy} from \"../Utility/shallowCopy\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {dispose} from \"../Disposable/dispose\";\r\nimport {IEventListener} from \"./IEventListener\";\r\nimport {EventDispatcherEntry} from \"./EventDispatcherEntry\";\r\nimport {IEventDispatcher} from \"./IEventDispatcher\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst DISPOSING:string = 'disposing',\r\n      DISPOSED:string  = 'disposed';\r\n\r\n// The following interfaces are exported for sub class implementation.\r\n\r\nexport interface IEventBase<TTarget>\r\n{\r\n\ttype:string;\r\n\ttarget:TTarget;\r\n}\r\n\r\nexport interface IEvent extends IEventBase<any>\r\n{\r\n\r\n}\r\n\r\nexport interface IEntryParams\r\n{\r\n\tpriority:number;\r\n\tdispatcher:EventDispatcherBase;\r\n}\r\n\r\nfunction entryFinalizer()\r\n{\r\n\tconst p:IEntryParams = this.params;\r\n\tp.dispatcher.removeEntry(this);\r\n\t(<any>p).dispatcher = null;\r\n}\r\n\r\nconst NAME = \"EventDispatcherBase\";\r\n\r\nexport default\r\nclass EventDispatcherBase extends DisposableBase implements IEventDispatcher\r\n{\r\n\r\n\tconstructor() {\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = NAME;\r\n\t}\r\n\r\n\tprotected _entries:EventDispatcherEntry<IEntryParams>[];\r\n\r\n\taddEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void\r\n\t{\r\n\t\tlet e = this._entries;\r\n\t\tif(!e) this._entries = e = [];\r\n\r\n\t\t// flash/vibe.js means of adding is indiscriminate and will double add listeners...\r\n\t\t// we can then avoid double adds by including a 'registerEventListener' method.\r\n\t\te.push(\r\n\t\t\tnew EventDispatcherEntry(type, listener, {\r\n\t\t\t\t\tpriority: priority || 0,\r\n\t\t\t\t\tdispatcher: this\r\n\t\t\t\t},\r\n\t\t\t\tentryFinalizer));\r\n\t}\r\n\r\n\tremoveEntry(entry:EventDispatcherEntry<IEntryParams>):boolean\r\n\t{\r\n\t\treturn !!this._entries && AU.remove(this._entries, entry)!=0;\r\n\t}\r\n\r\n\t// Allow for simple add once mechanism.\r\n\tregisterEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener,\r\n\t\tpriority:number = 0):void//, useWeakReference: boolean= false)\r\n\t{\r\n\t\tif(!this.hasEventListener(type, listener))\r\n\t\t\tthis.addEventListener(type, listener, priority);\r\n\t}\r\n\r\n\thasEventListener(type:string, listener?:IEventListener):boolean\r\n\t{\r\n\t\tconst e = this._entries;\r\n\t\treturn e && e.some(\r\n\t\t\t\t(value:EventDispatcherEntry<IEntryParams>):boolean =>\r\n\t\t\t\ttype==value.type && (!listener || listener==value.listener)\r\n\t\t\t);\r\n\t}\r\n\r\n\tremoveEventListener(\r\n\t\ttype:string,\r\n\t\tlistener:IEventListener):void\r\n\t{\r\n\t\tdispose.these(this._entries.filter(entry=> entry.matches(type, listener)));\r\n\t}\r\n\r\n\tdispatchEvent(type:string, params?:any):boolean;\r\n\tdispatchEvent(event:IEvent):boolean;\r\n\tdispatchEvent(e:any, params?:any):boolean\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\r\n\r\n\t\tlet l = _._entries;\r\n\t\tif(!l || !l.length)\r\n\t\t\treturn false;\r\n\r\n\t\tlet event:IEventBase<any>;\r\n\r\n\t\tif(typeof e==\"string\")\r\n\t\t{\r\n\t\t\tevent = <any>(Event && Object.create(Event) || {});\r\n\t\t\tif(!params)\r\n\t\t\t\tparams = {};\r\n\t\t\tif(params['cancellable'])\r\n\t\t\t\t(<any>event).cancellable = true;\r\n\t\t\tevent.target = _;\r\n\t\t\tevent.type = e;\r\n\t\t}\r\n\t\telse\r\n\t\t\tevent = e;\r\n\r\n\t\tconst type = event.type;\r\n\r\n\t\t// noinspection JSMismatchedCollectionQueryUpdate\r\n\t\tconst entries:EventDispatcherEntry<IEntryParams>[] = l.filter(e => e.type==type);//, propagate = true, prevent = false;\r\n\t\tif(!entries.length)\r\n\t\t\treturn false;\r\n\r\n\t\tentries.sort((a, b)=>\r\n\t\t\t(b.params ? b.params.priority : 0)\r\n\t\t\t- (a.params ? a.params.priority : 0)\r\n\t\t);\r\n\r\n\t\t// For now... Just use simple...\r\n\t\tentries.forEach(\r\n\t\t\tentry=>\r\n\t\t\t{\r\n\t\t\t\tconst newEvent:any = Object.create(Event);\r\n\t\t\t\tshallowCopy(event, newEvent);\r\n\t\t\t\tnewEvent.target = this;\r\n\t\t\t\tentry.dispatch(newEvent);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\tstatic get DISPOSING() { return DISPOSING; }\r\n\r\n\tstatic get DISPOSED() { return DISPOSED; }\r\n\r\n\t// When dispatching events, we need a way to prevent recursion when disposing.\r\n\tprivate _isDisposing:boolean = false;\r\n\tget isDisposing():boolean\r\n\t{\r\n\t\treturn this._isDisposing;\r\n\t}\r\n\r\n\t// Override the public method here since EventDispatcher will end up doing things a bit differently from here on.\r\n\tpublic dispose()\r\n\t{\r\n\r\n\t\t// Having a disposing event can allow for child objects to automatically release themselves when their parent is disposed.\r\n\t\tconst _ = this;\r\n\t\tif(!_.wasDisposed && !_._isDisposing)\r\n\t\t{\r\n\t\t\t_._isDisposing = true;\r\n\t\t\t_.dispatchEvent(DISPOSING);\r\n\r\n\t\t\tsuper.dispose();\r\n\r\n\t\t\t_.dispatchEvent(DISPOSED);\r\n\r\n\t\t\tconst l = _._entries;\r\n\t\t\tif(l)\r\n\t\t\t{\r\n\t\t\t\tthis._entries = <any>null;\r\n\t\t\t\tl.forEach(e=> e.dispose());\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n"]}