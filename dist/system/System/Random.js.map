{"version":3,"sources":["System/Random.ts"],"names":[],"mappings":"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","file":"Random.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Integer} from \"./Integer\";\r\nimport {initialize} from \"./Collections/Array/initialize\";\r\nimport {shuffle as arrayShuffle} from \"./Collections/Array/shuffle\";\r\nimport {ArrayLikeWritable} from \"./Collections/Array/ArrayLikeWritable\";\r\nimport assert = Integer.assert;\r\n\r\n/**\r\n * This module only acts as a utility API for getting random numbers from Math.random().\r\n * If you need repeatable seeded random numbers then you'll need a separate utility.\r\n * Highly recommended: https://github.com/ckknight/random-js which has typings under @types/random-js.\r\n */\r\nexport module Random\r\n{\r\n\r\n\tfunction r(maxExclusive:number):number\r\n\t{\r\n\t\treturn Math.floor(Math.random()*maxExclusive);\r\n\t}\r\n\r\n\tfunction nr(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tconst a = Math.abs(boundary);\r\n\t\tif(a===0 || a===1 && !inclusive) return 0;\r\n\t\tif(inclusive) boundary += boundary/a;\r\n\t\treturn r(boundary);\r\n\t}\r\n\r\n\tfunction arrayCopy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\tconst len = source.length;\r\n\t\tconst result = initialize<T>(len);\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tresult[i] = source[i];\r\n\t\t}\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the maxExclusive.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param maxExclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function integer(maxExclusive:number):number\r\n\t{\r\n\t\treturn next(maxExclusive);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a function that generates random floating point numbers up to the maxExclusive value.\r\n\t * Useful for generating a random and memoizable set for use with other enumerables.\r\n\t * @param maxExclusive\r\n\t * @returns {()=>number}\r\n\t */\r\n\texport function generate(maxExclusive:number):()=>number\r\n\t{\r\n\t\treturn ()=> r(maxExclusive);\r\n\t}\r\n\r\n\texport module generate\r\n\t{\r\n\t\t/**\r\n\t\t * Returns a function that generates random integers up to the boundary.\r\n\t\t * Useful for generating a random and memoizable set for use with other enumerables.\r\n\t\t * @param boundary\r\n\t\t * @param inclusive\r\n\t\t * @returns {()=>number}\r\n\t\t */\r\n\t\texport function integers(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):()=>number\r\n\t\t{\r\n\t\t\treturn ()=> nr(boundary,inclusive);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a random integer from 0 to the boundary.\r\n\t * Return value will be less than the boundary unless inclusive is set to true.\r\n\t * Negative numbers are allowed.\r\n\t *\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number}\r\n\t */\r\n\texport function next(\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number\r\n\t{\r\n\t\tassert(boundary, 'boundary');\r\n\t\treturn nr(boundary, inclusive);\r\n\t}\r\n\r\n\texport module next\r\n\t{\r\n\t\texport function integer(\r\n\t\t\tboundary:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\treturn Random.next(boundary, inclusive);\r\n\t\t}\r\n\r\n\t\texport function float(boundary:number = Number.MAX_VALUE):number\r\n\t\t{\r\n\t\t\tif(isNaN(boundary))\r\n\t\t\t\tthrow \"'boundary' is not a number.\";\r\n\t\t\treturn Math.random()*boundary;\r\n\t\t}\r\n\r\n\t\texport function inRange(\r\n\t\t\tmin:number,\r\n\t\t\tmax:number,\r\n\t\t\tinclusive?:boolean):number\r\n\t\t{\r\n\t\t\tassert(min, 'min');\r\n\t\t\tassert(max, 'max');\r\n\t\t\tlet range = max - min;\r\n\t\t\tif(range===0) return min;\r\n\t\t\tif(inclusive) range += range/Math.abs(range);\r\n\t\t\treturn min + r(range);\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns an array of random integers.\r\n\t * @param count\r\n\t * @param boundary\r\n\t * @param inclusive\r\n\t * @returns {number[]}\r\n\t */\r\n\texport function integers(\r\n\t\tcount:number,\r\n\t\tboundary:number,\r\n\t\tinclusive?:boolean):number[]\r\n\t{\r\n\t\tassert(count);\r\n\t\tconst s:number[] = [];\r\n\t\ts.length = count;\r\n\t\tfor(let i = 0; i<count; i++)\r\n\t\t{\r\n\t\t\ts[i] = nr(boundary, inclusive);\r\n\t\t}\r\n\t\treturn s;\r\n\t}\r\n\r\n\t/**\r\n\t * Shuffles an array.\r\n\t * @param target\r\n\t * @returns {T}\r\n\t */\r\n\texport function shuffle<T extends ArrayLikeWritable<any>>(target:T):T\r\n\t{\r\n\t\treturn arrayShuffle(target);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a copy of an array-like  and returns it shuffled.\r\n\t * @param source\r\n\t * @returns {T[]}\r\n\t */\r\n\texport function copy<T>(source:ArrayLike<T>):T[]\r\n\t{\r\n\t\treturn arrayShuffle(arrayCopy(source));\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a distinct random set from the source array up to the maxCount or the full length of the array.\r\n\t * @param source\r\n\t * @param maxCount\r\n\t * @returns {any}\r\n\t */\r\n\texport function select<T>(source:ArrayLike<T>, maxCount:number):T[]\r\n\t{\r\n\t\tif(maxCount!==Infinity) Integer.assertZeroOrGreater(maxCount);\r\n\t\tswitch (maxCount) {\r\n\t\t\tcase 0:\r\n\t\t\t\treturn [];\r\n\t\t\tcase 1:\r\n\t\t\t\treturn [select.one(source, true)];\r\n\t\t\tdefault:\r\n\t\t\t\tlet result = arrayShuffle(arrayCopy(source));\r\n\t\t\t\tif(maxCount<result.length)\r\n\t\t\t\t\tresult.length = maxCount;\r\n\t\t\t\treturn result;\r\n\r\n\t\t}\r\n\r\n\t}\r\n\r\n\texport module select\r\n\t{\r\n\t\t/**\r\n\t\t * Returns random value from an array.\r\n\t\t * @param source\r\n\t\t * @param throwIfEmpty\r\n\t\t */\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty:true):T\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\texport function one<T>(source:ArrayLike<T>, throwIfEmpty?:boolean):T|undefined\r\n\t\t{\r\n\t\t\tif(source && source.length)\r\n\t\t\t\treturn source[r(source.length)];\r\n\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow \"Cannot select from an empty set.\";\r\n\t\t}\r\n\t}\r\n\r\n\r\n}"]}