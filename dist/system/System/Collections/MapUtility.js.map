{"version":3,"sources":["System/Collections/MapUtility.ts"],"names":[],"mappings":";;;IAMA;;;;;OAKG;IACH,eACC,MAAQ,EACR,MAAQ;QAER,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;QAChC,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;YACA,EAAE,CAAA,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC9B,CAAC;gBACA,MAAM,CAAC,GAAG,CAAC,GAAS,MAAO,CAAC,GAAG,CAAC,CAAC;YAClC,CAAC;QACF,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;IAED;;;;;OAKG;IACH,gBACC,MAAQ,EACR,QAAU;QAEV,IAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;QAChC,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,QAAQ,CAAC,CAC1B,CAAC;YACA,EAAE,CAAA,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/D,CAAC;gBACA,MAAM,CAAC,GAAG,CAAC,GAAS,QAAS,CAAC,GAAG,CAAC,CAAC;YACpC,CAAC;QACF,CAAC;QACD,MAAM,CAAC,MAAM,CAAC;IACf,CAAC;IAED;;;;OAIG;IACH,cAA0C,MAAQ;QAEjD,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;IAC1B,CAAC;IAGD;;;;;OAKG;IACH,eACC,CAAG,EACH,CAAG;QAEH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;IAC1B,CAAC;IAED;;;;OAIG;IACH,cAAgD,MAAgB,EAAE,MAAc;QAE/E,GAAG,CAAA,CAAC,IAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;YACA,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/B,CAAC;gBACA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;YACpB,CAAC;QACF,CAAC;QACD,qBAAqB;IACtB,CAAC;;;;;;;;;QAAA,CAAC","file":"MapUtility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}"]}