{"version":3,"sources":["System.Linq/Linq.js","System.Linq/Linq.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","BREAK","RETURN","isNotNullOrUndefined","e","getEmptyEnumerator","EmptyEnumerator_1","EmptyEnumerator","nextEnumerator","queue","moveNext","dispose","enqueue","createSortContext","orderedEnumerable","currentContext","context","KeySortedContext_1","KeySortedContext","keySelector","order","comparer","parent","throwIfDisposed","disposed","ObjectDisposedException_1","ObjectDisposedException","Enumerable","source","additional","_i","arguments","length","enumerableFrom","fromAny","UnsupportedEnumerableException_1","UnsupportedEnumerableException","merge","Object","defineProperty","value","Compare_1","copy_1","Arrays","enumUtil","Enumerator_1","Types_1","Integer_1","Functions_1","ArrayEnumerator_1","EnumeratorBase_1","Dictionary_1","Queue_1","dispose_1","DisposableBase_1","ArgumentNullException_1","ArgumentOutOfRangeException_1","IndexEnumerator_1","IteratorEnumerator_1","initialize_1","Random_1","InfiniteEnumerator_1","extends_1","LazyList_1","disposeSingle","single","__extends","INVALID_DEFAULT","VOID0","NULL","LinqFunctions","_super","apply","this","prototype","Greater","a","b","Lesser","Functions","freeze","InfiniteLinqEnumerable","_enumeratorFactory","finalizer","_this","call","_isEndless","_disposableObjectName","get","enumerable","configurable","getEnumerator","_onDispose","asEnumerable","_","doAction","action","initializer","isEndless","onComplete","isE","ArgumentNullException","LinqEnumerable","enumerator","index","EnumeratorBase","yielder","c","current","actionResult","yieldBreak","yieldReturn","force","skip","count","isFinite","Integer","assert","where","element","take","empty","ArgumentOutOfRangeException","elementAt","elementAtOrDefault","defaultValue","assertZeroOrGreater","n","using","i","first","firstOrDefault","Error","singleOrDefault","any","isEmpty","traverseDepthFirst","childrenSelector","resultSelector","Identity","enumeratorStack","len","Type","isString","these","noCopy","flatten","selectMany","entry","pairwise","selector","previous","select","result","scan","func","seed","_filterSelected","map","_selectMany","collectionSelector","middleEnumerator","middleSeq","from","filter","choose","predicate","nonNull","ofType","type","typeName","Number","NUMBER","String","STRING","Boolean","BOOLEAN","Function","FUNCTION","x","except","second","compareSelector","keys","Dictionary","forEach","key","addByKeyValue","containsKey","clear","distinct","distinctUntilChanged","compareKey","initial","areEqual","defaultIfEmpty","isFirst","zip","firstEnumerator","secondEnumerator","zipMultiple","secondTemp","Queue","next","dequeue","join","inner","outerKeySelector","innerKeySelector","outerEnumerator","lookup","innerElements","innerCount","toLookup","innerElement","groupJoin","enumerables","tryDequeue","concat","union","insertAt","other","isEnumerated","alternateMultiple","sequence","buffer","mode","alternateEnumerator","ArrayEnumerator","toArray","hasAtLeastOne","reset","latest","another","alternateSingle","make","alternate","catchError","handler","finallyAction","size","array","initialize","share","sharedEnumerator","DisposableBase","enumeratorFactory","skipWhile","takeWhile","takeUntil","includeUntilValue","found","traverseBreadthFirst","nestLevel","max","Infinity","throwIfEndless","copyTo","target","elementSelector","dict","getValue","push","Lookup","toMap","obj","toDictionary","toJoinedString","separator","takeExceptLast","q","skipToLast","reverse","shuffle","capacity","selectedIndex","Random","integer","selectedValue","all","every","some","contains","s_1","indexOf","lastIndexOf","intersect","outs","sequenceEqual","equalityComparer","e1","e2","orderBy","OrderedEnumerable","orderUsing","comparison","orderUsingReversed","orderByDescending","groupBy","partitionBy","elements","Grouping","group","hasNext","aggregate","reduction","initialValue","reduce","average","numberOrNaN","sum","isNaN","NaN","min","maxBy","minBy","sumInfinite","product","exists","quotient","last","lastOrDefault","memoize","LazyList","throwWhenEmpty","FiniteEnumerable","ArrayEnumerable","_source","IndexEnumerator","s","pointer","step","isArrayLike","_groupKey","_dictionary","compare","createOrderedEnumerable","thenBy","thenUsing","thenByDescending","thenUsingReversed","indexes","generateSortedIndexes","defaultEnumerable","isObject","isEnumerable","isEnumerator","isIterator","IteratorEnumerator","isFunction","InfiniteEnumerator","fromThese","sources","fromOrEmpty","_choice","values","one","choice","copy","chooseFrom","args","_cycle","cycle","cycleThrough","repeat","repeatWithFinalize","range","start","rangeDown","Math","abs","toInfinity","toNegativeInfinity","rangeTo","to","matches","input","pattern","flags","RegExp","regex","match","exec","generate","unfold","valueFactory","skipSeed","weave","mainEnumerator","dump","random","floats","maxExclusive","integers","boundary","inclusive"],"mappings":"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","file":"Linq.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Original: http://linqjs.codeplex.com/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../System/Compare\", \"../System/Collections/Array/copy\", \"../System/Collections/Array/Compare\", \"../System/Collections/Enumeration/Enumerator\", \"../System/Collections/Enumeration/Enumerator\", \"../System/Collections/Enumeration/EmptyEnumerator\", \"../System/Types\", \"../System/Integer\", \"../System/Functions\", \"../System/Collections/Enumeration/ArrayEnumerator\", \"../System/Collections/Enumeration/EnumeratorBase\", \"../System/Collections/Dictionaries/Dictionary\", \"../System/Collections/Queue\", \"../System/Disposable/dispose\", \"../System/Disposable/DisposableBase\", \"../System/Collections/Enumeration/UnsupportedEnumerableException\", \"../System/Disposable/ObjectDisposedException\", \"../System/Collections/Sorting/KeySortedContext\", \"../System/Exceptions/ArgumentNullException\", \"../System/Exceptions/ArgumentOutOfRangeException\", \"../System/Collections/Enumeration/IndexEnumerator\", \"../System/Collections/Enumeration/IteratorEnumerator\", \"../System/Collections/Array/initialize\", \"../System/Random\", \"../System/Collections/Enumeration/InfiniteEnumerator\", \"../extends\", \"../System/Collections/LazyList\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Compare_1 = require(\"../System/Compare\");\n    var copy_1 = require(\"../System/Collections/Array/copy\");\n    var Arrays = require(\"../System/Collections/Array/Compare\");\n    var enumUtil = require(\"../System/Collections/Enumeration/Enumerator\");\n    var Enumerator_1 = require(\"../System/Collections/Enumeration/Enumerator\");\n    var EmptyEnumerator_1 = require(\"../System/Collections/Enumeration/EmptyEnumerator\");\n    var Types_1 = require(\"../System/Types\");\n    var Integer_1 = require(\"../System/Integer\");\n    var Functions_1 = require(\"../System/Functions\");\n    var ArrayEnumerator_1 = require(\"../System/Collections/Enumeration/ArrayEnumerator\");\n    var EnumeratorBase_1 = require(\"../System/Collections/Enumeration/EnumeratorBase\");\n    var Dictionary_1 = require(\"../System/Collections/Dictionaries/Dictionary\");\n    var Queue_1 = require(\"../System/Collections/Queue\");\n    var dispose_1 = require(\"../System/Disposable/dispose\");\n    var DisposableBase_1 = require(\"../System/Disposable/DisposableBase\");\n    var UnsupportedEnumerableException_1 = require(\"../System/Collections/Enumeration/UnsupportedEnumerableException\");\n    var ObjectDisposedException_1 = require(\"../System/Disposable/ObjectDisposedException\");\n    var KeySortedContext_1 = require(\"../System/Collections/Sorting/KeySortedContext\");\n    var ArgumentNullException_1 = require(\"../System/Exceptions/ArgumentNullException\");\n    var ArgumentOutOfRangeException_1 = require(\"../System/Exceptions/ArgumentOutOfRangeException\");\n    var IndexEnumerator_1 = require(\"../System/Collections/Enumeration/IndexEnumerator\");\n    var IteratorEnumerator_1 = require(\"../System/Collections/Enumeration/IteratorEnumerator\");\n    var initialize_1 = require(\"../System/Collections/Array/initialize\");\n    var Random_1 = require(\"../System/Random\");\n    var InfiniteEnumerator_1 = require(\"../System/Collections/Enumeration/InfiniteEnumerator\");\n    var extends_1 = require(\"../extends\");\n    var LazyList_1 = require(\"../System/Collections/LazyList\");\n    var disposeSingle = dispose_1.dispose.single;\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    // #region Local Constants.\n    var INVALID_DEFAULT = {}; // create a private unique instance for referencing.\n    var VOID0 = void 0;\n    var NULL = null;\n    function BREAK() {\n        return 0 /* Break */;\n    }\n    function RETURN() {\n        return 1 /* Return */;\n    }\n    function isNotNullOrUndefined(e) {\n        return e != null;\n    }\n    // Leave internal to avoid accidental overwriting.\n    var LinqFunctions = (function (_super) {\n        __extends(LinqFunctions, _super);\n        function LinqFunctions() {\n            return _super !== null && _super.apply(this, arguments) || this;\n        }\n        // noinspection JSMethodCanBeStatic\n        LinqFunctions.prototype.Greater = function (a, b) {\n            return a > b ? a : b;\n        };\n        // noinspection JSMethodCanBeStatic\n        LinqFunctions.prototype.Lesser = function (a, b) {\n            return a < b ? a : b;\n        };\n        return LinqFunctions;\n    }(Functions_1.Functions));\n    var Functions = Object.freeze(new LinqFunctions());\n    // For re-use as a factory.\n    function getEmptyEnumerator() {\n        return EmptyEnumerator_1.EmptyEnumerator;\n    }\n    // #endregion\n    /*\n     * NOTE: About InfiniteEnumerable<T> and Enumerable<T>.\n     * There may seem like there's extra overrides here and they may seem unnecessary.\n     * But after closer inspection you'll see the type chain is retained and\n     * infinite enumerables are prevented from having features that finite ones have.\n     *\n     * I'm not sure if it's the best option to just use overrides, but it honors the typing properly.\n     */\n    var InfiniteLinqEnumerable = (function (_super) {\n        __extends(InfiniteLinqEnumerable, _super);\n        function InfiniteLinqEnumerable(_enumeratorFactory, finalizer) {\n            var _this = _super.call(this, finalizer) || this;\n            _this._enumeratorFactory = _enumeratorFactory;\n            _this._isEndless = true;\n            _this._disposableObjectName = \"InfiniteLinqEnumerable\";\n            return _this;\n        }\n        Object.defineProperty(InfiniteLinqEnumerable.prototype, \"isEndless\", {\n            get: function () {\n                return this._isEndless;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        // #region IEnumerable<T> Implementation...\n        InfiniteLinqEnumerable.prototype.getEnumerator = function () {\n            this.throwIfDisposed();\n            return this._enumeratorFactory();\n        };\n        // #endregion\n        // #region IDisposable override...\n        InfiniteLinqEnumerable.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this); // Just in case.\n            this._enumeratorFactory = null;\n        };\n        // #endregion\n        // Return a default (unfiltered) enumerable.\n        InfiniteLinqEnumerable.prototype.asEnumerable = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return new InfiniteLinqEnumerable(function () { return _.getEnumerator(); });\n        };\n        InfiniteLinqEnumerable.prototype.doAction = function (action, initializer, isEndless, onComplete) {\n            if (isEndless === void 0) { isEndless = this.isEndless; }\n            var _ = this;\n            _.throwIfDisposed();\n            var isE = isEndless || undefined; // In case it's null.\n            if (!action)\n                throw new ArgumentNullException_1.ArgumentNullException(\"action\");\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(!action);\n                    if (initializer)\n                        initializer();\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                    // May need a way to propagate isEndless\n                }, function (yielder) {\n                    throwIfDisposed(!action);\n                    while (enumerator.moveNext()) {\n                        var c = enumerator.current;\n                        var actionResult = action(c, index++);\n                        if (actionResult === false || actionResult === 0 /* Break */)\n                            return yielder.yieldBreak();\n                        if (actionResult !== 2 /* Skip */)\n                            return yielder.yieldReturn(c);\n                        // If actionResult===2, then a signal for skip is received.\n                    }\n                    if (onComplete)\n                        onComplete(index);\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                }, isE);\n            }, \n            // Using a finalizer value reduces the chance of a circular reference\n            // since we could simply reference the enumeration and check e.wasDisposed.\n            function () {\n                action = NULL;\n            }, isE);\n        };\n        InfiniteLinqEnumerable.prototype.force = function () {\n            this.throwIfDisposed();\n            this.doAction(BREAK)\n                .getEnumerator()\n                .moveNext();\n        };\n        // #region Indexing/Paging methods.\n        InfiniteLinqEnumerable.prototype.skip = function (count) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!isFinite(count))\n                return new InfiniteLinqEnumerable(getEmptyEnumerator);\n            Integer_1.Integer.assert(count, \"count\");\n            return this.where(function (element, index) { return index >= count; });\n        };\n        InfiniteLinqEnumerable.prototype.take = function (count) {\n            if (!(count > 0))\n                return Enumerable.empty();\n            var _ = this;\n            _.throwIfDisposed();\n            if (!isFinite(count))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('count', count, 'Must be finite.');\n            Integer_1.Integer.assert(count, \"count\");\n            // Once action returns false, the enumeration will stop.\n            return _.doAction(function (element, index) { return index < count; }, null, false);\n        };\n        // #region Single Value Return...\n        InfiniteLinqEnumerable.prototype.elementAt = function (index) {\n            var v = this.elementAtOrDefault(index, INVALID_DEFAULT);\n            if (v === INVALID_DEFAULT)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\n            return v;\n        };\n        InfiniteLinqEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var n = index;\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                var i = 0;\n                while (e.moveNext()) {\n                    if (i == n)\n                        return e.current;\n                    i++;\n                }\n                return defaultValue;\n            });\n        };\n        /* Note: Unlike previous implementations, you could pass a predicate into these methods.\n         * But since under the hood it ends up calling .where(predicate) anyway,\n         * it may be better to remove this to allow for a cleaner signature/override.\n         * JavaScript/TypeScript does not easily allow for a strict method interface like C#.\n         * Having to write extra override logic is error prone and confusing to the consumer.\n         * Removing the predicate here may also cause the consumer of this method to think more about how they structure their query.\n         * The end all difference is that the user must declare .where(predicate) before .first(), .single(), or .last().\n         * Otherwise there would need to be much more code to handle these cases (.first(predicate), etc);\n         * */\n        InfiniteLinqEnumerable.prototype.first = function () {\n            var v = this.firstOrDefault(INVALID_DEFAULT);\n            if (v === INVALID_DEFAULT)\n                throw new Error(\"first:The sequence is empty.\");\n            return v;\n        };\n        InfiniteLinqEnumerable.prototype.firstOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) { return e.moveNext() ? e.current : defaultValue; });\n        };\n        InfiniteLinqEnumerable.prototype.single = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                if (e.moveNext()) {\n                    var value = e.current;\n                    if (!e.moveNext())\n                        return value;\n                    throw new Error(\"single:sequence contains more than one element.\");\n                }\n                throw new Error(\"single:The sequence is empty.\");\n            });\n        };\n        InfiniteLinqEnumerable.prototype.singleOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) {\n                if (e.moveNext()) {\n                    var value = e.current;\n                    if (!e.moveNext())\n                        return value;\n                }\n                return defaultValue;\n            });\n        };\n        InfiniteLinqEnumerable.prototype.any = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e) { return e.moveNext(); });\n        };\n        InfiniteLinqEnumerable.prototype.isEmpty = function () {\n            return !this.any();\n        };\n        InfiniteLinqEnumerable.prototype.traverseDepthFirst = function (childrenSelector, resultSelector) {\n            if (resultSelector === void 0) { resultSelector = Functions.Identity; }\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless; // Is endless is not affirmative if false.\n            return new LinqEnumerable(function () {\n                // Dev Note: May want to consider using an actual stack and not an array.\n                var enumeratorStack;\n                var enumerator;\n                var len; // Avoid using push/pop since they query .length every time and can be slower.\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                    enumeratorStack = [];\n                    len = 0;\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            var value = resultSelector(enumerator.current, len);\n                            enumeratorStack[len++] = enumerator;\n                            var c = childrenSelector(enumerator.current);\n                            var e = !Types_1.Type.isString(c) && Enumerable.fromAny(c);\n                            enumerator = e ? e.getEnumerator() : EmptyEnumerator_1.EmptyEnumerator;\n                            return yielder.yieldReturn(value);\n                        }\n                        if (len == 0)\n                            return false;\n                        enumerator.dispose();\n                        enumerator = enumeratorStack[--len];\n                        enumeratorStack.length = len;\n                    }\n                }, function () {\n                    try {\n                        if (enumerator)\n                            enumerator.dispose();\n                    }\n                    finally {\n                        if (enumeratorStack) {\n                            dispose_1.dispose.these.noCopy(enumeratorStack);\n                            enumeratorStack.length = 0;\n                            enumeratorStack = NULL;\n                        }\n                    }\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.flatten = function () {\n            return this.selectMany(function (entry) {\n                var e = !Types_1.Type.isString(entry) && Enumerable.fromAny(entry);\n                return e ? e.flatten() : [entry];\n            });\n        };\n        InfiniteLinqEnumerable.prototype.pairwise = function (selector) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!selector)\n                throw new ArgumentNullException_1.ArgumentNullException(\"selector\");\n            var previous;\n            return this.select(function (value, i) {\n                var result = i ? selector(previous, value, i) : NULL;\n                previous = value;\n                return result;\n            }).skip(1);\n        };\n        InfiniteLinqEnumerable.prototype.scan = function (func, seed) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!func)\n                throw new ArgumentNullException_1.ArgumentNullException(\"func\");\n            return (seed === VOID0\n                ? this.select(function (value, i) { return seed = i ? func(seed, value, i) : value; })\n                : this.select(function (value, i) { return seed = func(seed, value, i); }));\n        };\n        // #endregion\n        InfiniteLinqEnumerable.prototype.select = function (selector) {\n            return this._filterSelected(selector);\n        };\n        InfiniteLinqEnumerable.prototype.map = function (selector) {\n            return this._filterSelected(selector);\n        };\n        /*\n        public static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(\n            this IEnumerable<TSource> source,\n            Func<TSource,IEnumerable<TCollection>> collectionSelector,\n            Func<TSource,TCollection,TResult> resultSelector)\n         */\n        InfiniteLinqEnumerable.prototype._selectMany = function (collectionSelector, resultSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!collectionSelector)\n                throw new ArgumentNullException_1.ArgumentNullException(\"collectionSelector\");\n            var isEndless = _._isEndless; // Do second enumeration, it will be indeterminate if false.\n            if (!resultSelector)\n                resultSelector = function (a, b) { return b; };\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var middleEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(!collectionSelector);\n                    enumerator = _.getEnumerator();\n                    middleEnumerator = VOID0;\n                    index = 0;\n                }, function (yielder) {\n                    throwIfDisposed(!collectionSelector);\n                    // Just started, and nothing to enumerate? End.\n                    if (middleEnumerator === VOID0 && !enumerator.moveNext())\n                        return false;\n                    // moveNext has been called at least once...\n                    do {\n                        // Initialize middle if there isn't one.\n                        if (!middleEnumerator) {\n                            var middleSeq = collectionSelector(enumerator.current, index++);\n                            // Collection is null?  Skip it...\n                            if (!middleSeq)\n                                continue;\n                            middleEnumerator = enumUtil.from(middleSeq);\n                        }\n                        if (middleEnumerator.moveNext())\n                            return yielder.yieldReturn(resultSelector(enumerator.current, middleEnumerator.current));\n                        // else no more in this middle?  Then clear and reset for next...\n                        middleEnumerator.dispose();\n                        middleEnumerator = null;\n                    } while (enumerator.moveNext());\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    disposeSingle(middleEnumerator);\n                    enumerator = NULL;\n                    middleEnumerator = null;\n                }, isEndless);\n            }, function () {\n                collectionSelector = NULL;\n            }, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n            return this._selectMany(collectionSelector, resultSelector);\n        };\n        InfiniteLinqEnumerable.prototype._filterSelected = function (selector, filter) {\n            if (selector === void 0) { selector = Functions.Identity; }\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            if (!selector)\n                throw new ArgumentNullException_1.ArgumentNullException(\"selector\");\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(!selector);\n                    index = 0;\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var i = index++;\n                        var result = selector(enumerator.current, i);\n                        if (!filter || filter(result, i++))\n                            return yielder.yieldReturn(result);\n                    }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                }, _._isEndless);\n            }, function () {\n                disposed = false;\n            }, _._isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.choose = function (selector) {\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this._filterSelected(selector, isNotNullOrUndefined);\n        };\n        InfiniteLinqEnumerable.prototype.where = function (predicate) {\n            return this._filterSelected(Functions.Identity, predicate);\n        };\n        InfiniteLinqEnumerable.prototype.filter = function (predicate) {\n            return this._filterSelected(Functions.Identity, predicate);\n        };\n        InfiniteLinqEnumerable.prototype.nonNull = function () {\n            return this.where(function (v) { return v != null && v != VOID0; });\n        };\n        InfiniteLinqEnumerable.prototype.ofType = function (type) {\n            var typeName;\n            switch (type) {\n                case Number:\n                    typeName = Types_1.Type.NUMBER;\n                    break;\n                case String:\n                    typeName = Types_1.Type.STRING;\n                    break;\n                case Boolean:\n                    typeName = Types_1.Type.BOOLEAN;\n                    break;\n                case Function:\n                    typeName = Types_1.Type.FUNCTION;\n                    break;\n                default:\n                    return this\n                        .where(function (x) { return x instanceof type; });\n            }\n            return this\n                .where(function (x) { return isNotNullOrUndefined(x) && typeof x === typeName; });\n        };\n        InfiniteLinqEnumerable.prototype.except = function (second, compareSelector) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var keys;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector);\n                    if (second)\n                        enumUtil.forEach(second, function (key) { keys.addByKeyValue(key, true); });\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.current;\n                        if (!keys.containsKey(current)) {\n                            keys.addByKeyValue(current, true);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    keys.clear();\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.distinct = function (compareSelector) {\n            return this.except(NULL, compareSelector);\n        };\n        // [0,0,0,1,1,1,2,2,2,0,0,0,1,1] results in [0,1,2,0,1];\n        InfiniteLinqEnumerable.prototype.distinctUntilChanged = function (compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var compareKey;\n                var initial = true;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (enumerator.moveNext()) {\n                        var key = compareSelector(enumerator.current);\n                        if (initial) {\n                            initial = false;\n                        }\n                        else if (Compare_1.areEqual(compareKey, key)) {\n                            continue;\n                        }\n                        compareKey = key;\n                        return yielder.yieldReturn(enumerator.current);\n                    }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        /**\n         * Returns a single default value if empty.\n         * @param defaultValue\n         * @returns {Enumerable}\n         */\n        InfiniteLinqEnumerable.prototype.defaultIfEmpty = function (defaultValue) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var isFirst;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    isFirst = true;\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    if (enumerator.moveNext()) {\n                        isFirst = false;\n                        return yielder.yieldReturn(enumerator.current);\n                    }\n                    else if (isFirst) {\n                        isFirst = false;\n                        return yielder.yieldReturn(defaultValue);\n                    }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.zip = function (second, resultSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            return new LinqEnumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = enumUtil.from(second);\n                }, function (yielder) { return firstEnumerator.moveNext()\n                    && secondEnumerator.moveNext()\n                    && yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++)); }, function () {\n                    if (firstEnumerator)\n                        firstEnumerator.dispose();\n                    if (secondEnumerator)\n                        secondEnumerator.dispose();\n                    firstEnumerator = NULL;\n                    secondEnumerator = NULL;\n                });\n            });\n        };\n        InfiniteLinqEnumerable.prototype.zipMultiple = function (second, resultSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!second.length)\n                return Enumerable.empty();\n            return new LinqEnumerable(function () {\n                var secondTemp;\n                var firstEnumerator;\n                var secondEnumerator;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    secondTemp = new Queue_1.Queue(second);\n                    index = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = NULL;\n                }, function (yielder) {\n                    if (firstEnumerator.moveNext()) {\n                        while (true) {\n                            while (!secondEnumerator) {\n                                if (secondTemp.count) {\n                                    var next = secondTemp.dequeue();\n                                    if (next)\n                                        secondEnumerator = enumUtil.from(next);\n                                }\n                                else\n                                    return yielder.yieldBreak();\n                            }\n                            if (secondEnumerator.moveNext())\n                                return yielder.yieldReturn(resultSelector(firstEnumerator.current, secondEnumerator.current, index++));\n                            secondEnumerator.dispose();\n                            secondEnumerator = NULL;\n                        }\n                    }\n                    return yielder.yieldBreak();\n                }, function () {\n                    if (firstEnumerator)\n                        firstEnumerator.dispose();\n                    if (secondEnumerator)\n                        secondEnumerator.dispose();\n                    if (secondTemp)\n                        secondTemp.dispose();\n                    firstEnumerator = NULL;\n                    secondEnumerator = NULL;\n                    secondTemp = NULL;\n                });\n            });\n        };\n        // #region Join Methods\n        InfiniteLinqEnumerable.prototype.join = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            return new LinqEnumerable(function () {\n                var outerEnumerator;\n                var lookup;\n                var innerElements;\n                var innerCount = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    outerEnumerator = _.getEnumerator();\n                    lookup = Enumerable.from(inner)\n                        .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n                }, function (yielder) {\n                    while (true) {\n                        if (innerElements) {\n                            var innerElement = innerElements[innerCount++];\n                            if (innerElement !== VOID0)\n                                return yielder.yieldReturn(resultSelector(outerEnumerator.current, innerElement));\n                            innerElements = null;\n                            innerCount = 0;\n                        }\n                        if (outerEnumerator.moveNext()) {\n                            var key = outerKeySelector(outerEnumerator.current);\n                            innerElements = lookup.get(key);\n                        }\n                        else {\n                            return yielder.yieldBreak();\n                        }\n                    }\n                }, function () {\n                    if (outerEnumerator)\n                        outerEnumerator.dispose();\n                    innerElements = null;\n                    outerEnumerator = NULL;\n                    lookup = NULL;\n                });\n            });\n        };\n        InfiniteLinqEnumerable.prototype.groupJoin = function (inner, outerKeySelector, innerKeySelector, resultSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var lookup;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    lookup = Enumerable.from(inner)\n                        .toLookup(innerKeySelector, Functions.Identity, compareSelector);\n                }, function (yielder) {\n                    return enumerator.moveNext()\n                        && yielder.yieldReturn(resultSelector(enumerator.current, lookup.get(outerKeySelector(enumerator.current))));\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    lookup = NULL;\n                });\n            });\n        };\n        InfiniteLinqEnumerable.prototype.merge = function (enumerables) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            if (!enumerables || enumerables.length == 0)\n                return _;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var queue;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    // 1) First get our values...\n                    enumerator = _.getEnumerator();\n                    queue = new Queue_1.Queue(enumerables);\n                }, function (yielder) {\n                    while (true) {\n                        while (!enumerator && queue.tryDequeue(function (value) {\n                            enumerator = enumUtil.from(value); // 4) Keep going and on to step 2.  Else fall through to yieldBreak().\n                        })) { }\n                        if (enumerator && enumerator.moveNext())\n                            return yielder.yieldReturn(enumerator.current);\n                        if (enumerator) {\n                            enumerator.dispose();\n                            enumerator = NULL;\n                            continue;\n                        }\n                        return yielder.yieldBreak();\n                    }\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    if (queue)\n                        queue.dispose();\n                    queue = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.concat = function () {\n            var enumerables = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                enumerables[_i] = arguments[_i];\n            }\n            return this.merge(enumerables);\n        };\n        InfiniteLinqEnumerable.prototype.union = function (second, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var keys;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    firstEnumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector); // Acting as a HashSet.\n                }, function (yielder) {\n                    var current;\n                    if (secondEnumerator === VOID0) {\n                        while (firstEnumerator.moveNext()) {\n                            current = firstEnumerator.current;\n                            if (!keys.containsKey(current)) {\n                                keys.addByKeyValue(current, null);\n                                return yielder.yieldReturn(current);\n                            }\n                        }\n                        secondEnumerator = enumUtil.from(second);\n                    }\n                    while (secondEnumerator.moveNext()) {\n                        current = secondEnumerator.current;\n                        if (!keys.containsKey(current)) {\n                            keys.addByKeyValue(current, null);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return false;\n                }, function () {\n                    if (firstEnumerator)\n                        firstEnumerator.dispose();\n                    if (secondEnumerator)\n                        secondEnumerator.dispose();\n                    firstEnumerator = NULL;\n                    secondEnumerator = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.insertAt = function (index, other) {\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var n = index;\n            var _ = this;\n            _.throwIfDisposed();\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var firstEnumerator;\n                var secondEnumerator;\n                var count = 0;\n                var isEnumerated = false;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    count = 0;\n                    firstEnumerator = _.getEnumerator();\n                    secondEnumerator = enumUtil.from(other);\n                    isEnumerated = false;\n                }, function (yielder) {\n                    if (count == n) {\n                        isEnumerated = true;\n                        if (secondEnumerator.moveNext())\n                            return yielder.yieldReturn(secondEnumerator.current);\n                    }\n                    if (firstEnumerator.moveNext()) {\n                        count++;\n                        return yielder.yieldReturn(firstEnumerator.current);\n                    }\n                    return !isEnumerated\n                        && secondEnumerator.moveNext()\n                        && yielder.yieldReturn(secondEnumerator.current);\n                }, function () {\n                    if (firstEnumerator)\n                        firstEnumerator.dispose();\n                    firstEnumerator = NULL;\n                    if (secondEnumerator)\n                        secondEnumerator.dispose();\n                    secondEnumerator = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.alternateMultiple = function (sequence) {\n            var _ = this;\n            var isEndless = _._isEndless;\n            return new LinqEnumerable(function () {\n                var buffer, mode, enumerator, alternateEnumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    // Instead of recalling getEnumerator every time, just reset the existing one.\n                    alternateEnumerator = new ArrayEnumerator_1.ArrayEnumerator(Enumerable.toArray(sequence)); // Freeze\n                    enumerator = _.getEnumerator();\n                    var hasAtLeastOne = enumerator.moveNext();\n                    mode = hasAtLeastOne\n                        ? 1 /* Return */\n                        : 0 /* Break */;\n                    if (hasAtLeastOne)\n                        buffer = enumerator.current;\n                }, function (yielder) {\n                    switch (mode) {\n                        case 0 /* Break */:\n                            return yielder.yieldBreak();\n                        case 2 /* Skip */:\n                            if (alternateEnumerator.moveNext())\n                                return yielder.yieldReturn(alternateEnumerator.current);\n                            alternateEnumerator.reset();\n                            mode = 1 /* Return */;\n                            break;\n                    }\n                    var latest = buffer;\n                    // Set up the next round...\n                    // Is there another one?  Set the buffer and setup instruct for the next one to be the alternate.\n                    var another = enumerator.moveNext();\n                    mode = another\n                        ? 2 /* Skip */\n                        : 0 /* Break */;\n                    if (another)\n                        buffer = enumerator.current;\n                    return yielder.yieldReturn(latest);\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    if (alternateEnumerator)\n                        alternateEnumerator.dispose();\n                    enumerator = NULL;\n                    alternateEnumerator = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.alternateSingle = function (value) {\n            return this.alternateMultiple(Enumerable.make(value));\n        };\n        InfiniteLinqEnumerable.prototype.alternate = function () {\n            var sequence = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                sequence[_i] = arguments[_i];\n            }\n            return this.alternateMultiple(sequence);\n        };\n        // #region Error Handling\n        InfiniteLinqEnumerable.prototype.catchError = function (handler) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new LinqEnumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    try {\n                        throwIfDisposed(disposed);\n                        enumerator = _.getEnumerator();\n                    }\n                    catch (e) {\n                        // Don't init...\n                    }\n                }, function (yielder) {\n                    if (enumerator)\n                        try {\n                            throwIfDisposed(disposed);\n                            if (enumerator.moveNext())\n                                return yielder.yieldReturn(enumerator.current);\n                        }\n                        catch (e) {\n                            handler(e);\n                        }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                });\n            });\n        };\n        InfiniteLinqEnumerable.prototype.finallyAction = function (action) {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new LinqEnumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    return (enumerator.moveNext())\n                        ? yielder.yieldReturn(enumerator.current)\n                        : false;\n                }, function () {\n                    try {\n                        if (enumerator)\n                            enumerator.dispose();\n                        enumerator = NULL;\n                    }\n                    finally {\n                        action();\n                    }\n                });\n            });\n        };\n        // #endregion\n        InfiniteLinqEnumerable.prototype.buffer = function (size) {\n            if (size < 1 || !isFinite(size))\n                throw new Error(\"Invalid buffer size.\");\n            Integer_1.Integer.assert(size, \"size\");\n            var _ = this;\n            var isEndless = _._isEndless;\n            var len;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                }, function (yielder) {\n                    var array = initialize_1.initialize(size);\n                    len = 0;\n                    while (len < size && enumerator.moveNext()) {\n                        array[len++] = enumerator.current;\n                    }\n                    array.length = len;\n                    return !!len && yielder.yieldReturn(array);\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                }, isEndless);\n            }, null, isEndless);\n        };\n        InfiniteLinqEnumerable.prototype.share = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var sharedEnumerator;\n            return new LinqEnumerable(function () {\n                return sharedEnumerator || (sharedEnumerator = _.getEnumerator());\n            }, function () {\n                if (sharedEnumerator)\n                    sharedEnumerator.dispose();\n                sharedEnumerator = NULL;\n            }, _._isEndless);\n        };\n        return InfiniteLinqEnumerable;\n    }(DisposableBase_1.DisposableBase));\n    exports.InfiniteLinqEnumerable = InfiniteLinqEnumerable;\n    /**\n     * Enumerable<T> is a wrapper class that allows more primitive enumerables to exhibit LINQ behavior.\n     *\n     * In C# Enumerable<T> is not an instance but has extensions for IEnumerable<T>.\n     * In this case, we use Enumerable<T> as the underlying class that is being chained.\n     */\n    var LinqEnumerable = (function (_super) {\n        __extends(LinqEnumerable, _super);\n        function LinqEnumerable(enumeratorFactory, finalizer, isEndless) {\n            var _this = _super.call(this, enumeratorFactory, finalizer) || this;\n            _this._isEndless = isEndless;\n            _this._disposableObjectName = \"LinqEnumerable\";\n            return _this;\n        }\n        // Return a default (unfiltered) enumerable.\n        LinqEnumerable.prototype.asEnumerable = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return new LinqEnumerable(function () { return _.getEnumerator(); });\n        };\n        // #region Indexing/Paging methods.\n        LinqEnumerable.prototype.skip = function (count) {\n            return _super.prototype.skip.call(this, count);\n        };\n        LinqEnumerable.prototype.skipWhile = function (predicate) {\n            this.throwIfDisposed();\n            return this.doAction(function (element, index) {\n                return predicate(element, index)\n                    ? 2 /* Skip */\n                    : 1 /* Return */;\n            });\n        };\n        LinqEnumerable.prototype.takeWhile = function (predicate) {\n            this.throwIfDisposed();\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException('predicate');\n            return this.doAction(function (element, index) {\n                return predicate(element, index)\n                    ? 1 /* Return */\n                    : 0 /* Break */;\n            }, null, null // We don't know the state if it is endless or not.\n            );\n        };\n        // Is like the inverse of take While with the ability to return the value identified by the predicate.\n        LinqEnumerable.prototype.takeUntil = function (predicate, includeUntilValue) {\n            this.throwIfDisposed();\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException('predicate');\n            if (!includeUntilValue)\n                return this.doAction(function (element, index) {\n                    return predicate(element, index)\n                        ? 0 /* Break */\n                        : 1 /* Return */;\n                }, null, null // We don't know the state if it is endless or not.\n                );\n            var found = false;\n            return this.doAction(function (element, index) {\n                if (found)\n                    return 0 /* Break */;\n                found = predicate(element, index);\n                return 1 /* Return */;\n            }, function () {\n                found = false;\n            }, null // We don't know the state if it is endless or not.\n            );\n        };\n        LinqEnumerable.prototype.traverseBreadthFirst = function (childrenSelector, resultSelector) {\n            if (resultSelector === void 0) { resultSelector = Functions.Identity; }\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            var isEndless = _._isEndless; // Is endless is not affirmative if false.\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var nestLevel = 0;\n                var buffer, len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    enumerator = _.getEnumerator();\n                    nestLevel = 0;\n                    buffer = [];\n                    len = 0;\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    while (true) {\n                        if (enumerator.moveNext()) {\n                            buffer[len++] = enumerator.current;\n                            return yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\n                        }\n                        if (!len)\n                            return yielder.yieldBreak();\n                        var next = Enumerable\n                            .from(buffer)\n                            .selectMany(childrenSelector);\n                        if (!next.any()) {\n                            return yielder.yieldBreak();\n                        }\n                        else {\n                            nestLevel++;\n                            buffer = [];\n                            len = 0;\n                            enumerator.dispose();\n                            enumerator = next.getEnumerator();\n                        }\n                    }\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    buffer.length = 0;\n                }, isEndless);\n            }, function () {\n                disposed = true;\n            }, isEndless);\n        };\n        LinqEnumerable.prototype.forEach = function (action, max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this;\n            _.throwIfDisposed();\n            if (!action)\n                throw new ArgumentNullException_1.ArgumentNullException(\"action\");\n            Enumerator_1.throwIfEndless(_.isEndless);\n            /*\n            // It could be just as easy to do the following:\n            return enumUtil.forEach(_, action, max);\n            // But to be more active about checking for disposal, we use this instead:\n            */\n            // Return value of action can be anything, but if it is (===) false then the enumUtil.forEach will discontinue.\n            return max > 0 ? dispose_1.using(_.getEnumerator(), function (e) {\n                Enumerator_1.throwIfEndless(!isFinite(max) && e.isEndless);\n                var i = 0;\n                // It is possible that subsequently 'action' could cause the enumeration to dispose, so we have to check each time.\n                while (max > i && _.throwIfDisposed() && e.moveNext()) {\n                    if (action(e.current, i++) === false)\n                        break;\n                }\n                return i;\n            }) : 0;\n        };\n        // #region Conversion Methods\n        LinqEnumerable.prototype.toArray = function (predicate) {\n            return predicate\n                ? this.where(predicate).toArray()\n                : this.copyTo([]);\n        };\n        LinqEnumerable.prototype.copyTo = function (target, index, count) {\n            if (index === void 0) { index = 0; }\n            if (count === void 0) { count = Infinity; }\n            this.throwIfDisposed();\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(\"target\");\n            Integer_1.Integer.assertZeroOrGreater(index);\n            // If not exposing an action that could cause dispose, then use enumUtil.forEach utility instead.\n            enumUtil.forEach(this, function (x, i) {\n                target[i + index] = x;\n            }, count);\n            return target;\n        };\n        LinqEnumerable.prototype.toLookup = function (keySelector, elementSelector, compareSelector) {\n            if (elementSelector === void 0) { elementSelector = Functions.Identity; }\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var dict = new Dictionary_1.Dictionary(compareSelector);\n            this.forEach(function (x, i) {\n                var key = keySelector(x, i);\n                var element = elementSelector(x, i);\n                var array = dict.getValue(key);\n                if (array !== VOID0)\n                    array.push(element);\n                else\n                    dict.addByKeyValue(key, [element]);\n            });\n            return new Lookup(dict);\n        };\n        LinqEnumerable.prototype.toMap = function (keySelector, elementSelector) {\n            var obj = {};\n            this.forEach(function (x, i) {\n                obj[keySelector(x, i)] = elementSelector(x, i);\n            });\n            return obj;\n        };\n        LinqEnumerable.prototype.toDictionary = function (keySelector, elementSelector, compareSelector) {\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var dict = new Dictionary_1.Dictionary(compareSelector);\n            this.forEach(function (x, i) { return dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)); });\n            return dict;\n        };\n        LinqEnumerable.prototype.toJoinedString = function (separator, selector) {\n            if (separator === void 0) { separator = \"\"; }\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this\n                .select(selector)\n                .toArray()\n                .join(separator);\n        };\n        // #endregion\n        LinqEnumerable.prototype.takeExceptLast = function (count) {\n            if (count === void 0) { count = 1; }\n            var _ = this;\n            if (!(count > 0))\n                return _;\n            if (!isFinite(count))\n                return Enumerable.empty();\n            Integer_1.Integer.assert(count, \"count\");\n            var c = count;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var q;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    enumerator = _.getEnumerator();\n                    q = new Queue_1.Queue();\n                }, function (yielder) {\n                    while (enumerator.moveNext()) {\n                        // Add the next one to the queue.\n                        q.enqueue(enumerator.current);\n                        // Did we reach our quota?\n                        if (q.count > c)\n                            // Okay then, start returning results.\n                            return yielder.yieldReturn(q.dequeue());\n                    }\n                    return false;\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    if (q)\n                        q.dispose();\n                    q = NULL;\n                });\n            });\n        };\n        LinqEnumerable.prototype.skipToLast = function (count) {\n            if (!(count > 0))\n                return Enumerable.empty();\n            var _ = this;\n            if (!isFinite(count))\n                return _;\n            Integer_1.Integer.assert(count, \"count\");\n            // This sets up the query so nothing is done until move next is called.\n            return _.reverse()\n                .take(count)\n                .reverse();\n        };\n        // To help with type guarding.\n        LinqEnumerable.prototype.select = function (selector) {\n            return _super.prototype.select.call(this, selector);\n        };\n        LinqEnumerable.prototype.map = function (selector) {\n            return _super.prototype.select.call(this, selector);\n        };\n        LinqEnumerable.prototype.selectMany = function (collectionSelector, resultSelector) {\n            return this._selectMany(collectionSelector, resultSelector);\n        };\n        LinqEnumerable.prototype.choose = function (selector) {\n            if (selector === void 0) { selector = Functions.Identity; }\n            return this._filterSelected(selector, isNotNullOrUndefined);\n        };\n        LinqEnumerable.prototype.reverse = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            Enumerator_1.throwIfEndless(_._isEndless); // Cannot reverse an endless collection...\n            return new LinqEnumerable(function () {\n                var buffer;\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    _.throwIfDisposed();\n                    buffer = _.toArray();\n                    index = buffer.length;\n                }, function (yielder) { return !!index && yielder.yieldReturn(buffer[--index]); }, function () {\n                    buffer.length = 0;\n                });\n            }, function () {\n                disposed = true;\n            });\n        };\n        LinqEnumerable.prototype.shuffle = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            Enumerator_1.throwIfEndless(_._isEndless); // Cannot shuffle an endless collection...\n            return new LinqEnumerable(function () {\n                var buffer;\n                var capacity;\n                var len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    buffer = _.toArray();\n                    capacity = len = buffer.length;\n                }, function (yielder) {\n                    // Avoid using major array operations like .slice();\n                    if (!len)\n                        return yielder.yieldBreak();\n                    var selectedIndex = Random_1.Random.integer(len);\n                    var selectedValue = buffer[selectedIndex];\n                    buffer[selectedIndex] = buffer[--len]; // Take the last one and put it here.\n                    buffer[len] = NULL; // clear possible reference.\n                    if (len % 32 == 0)\n                        buffer.length = len;\n                    return yielder.yieldReturn(selectedValue);\n                }, function () {\n                    buffer.length = 0;\n                });\n            }, function () {\n                disposed = true;\n            });\n        };\n        LinqEnumerable.prototype.count = function (predicate) {\n            var count = 0;\n            this.forEach(predicate\n                ? function (x, i) {\n                    if (predicate(x, i))\n                        ++count;\n                }\n                : function () {\n                    ++count;\n                });\n            return count;\n        };\n        // Akin to '.every' on an array.\n        LinqEnumerable.prototype.all = function (predicate) {\n            if (!predicate)\n                throw new ArgumentNullException_1.ArgumentNullException(\"predicate\");\n            var result = true;\n            this.forEach(function (x, i) {\n                if (!predicate(x, i)) {\n                    result = false;\n                    return false; // break\n                }\n            });\n            return result;\n        };\n        // 'every' has been added here for parity/compatibility with an array.\n        LinqEnumerable.prototype.every = function (predicate) {\n            return this.all(predicate);\n        };\n        // Akin to '.some' on an array.\n        LinqEnumerable.prototype.any = function (predicate) {\n            if (!predicate)\n                return _super.prototype.any.call(this);\n            var result = false;\n            // Splitting the forEach up this way reduces iterative processing.\n            // forEach handles the generation and disposal of the enumerator.\n            this.forEach(function (x, i) {\n                result = predicate(x, i); // false = not found and therefore it should continue.  true = found and break;\n                return !result;\n            });\n            return result;\n        };\n        // 'some' has been added here for parity/compatibility with an array.\n        LinqEnumerable.prototype.some = function (predicate) {\n            return this.any(predicate);\n        };\n        LinqEnumerable.prototype.contains = function (value, compareSelector) {\n            if (compareSelector) {\n                var s_1 = compareSelector(value);\n                return this.any(function (v) { return Compare_1.areEqual(compareSelector(v), s_1); });\n            }\n            return this.any(function (v) { return Compare_1.areEqual(v, value); });\n        };\n        // Originally has an overload for a predicate,\n        // but that's a bad idea since this could be an enumeration of functions and therefore fail the intent.\n        // Better to chain a where statement first to be more explicit.\n        LinqEnumerable.prototype.indexOf = function (value, compareSelector) {\n            var found = -1;\n            this.forEach(compareSelector\n                ? function (element, i) {\n                    if (Compare_1.areEqual(compareSelector(element, i), compareSelector(value, i), true)) {\n                        found = i;\n                        return false;\n                    }\n                }\n                : function (element, i) {\n                    // Why?  Because NaN doesn't equal NaN. :P\n                    if (Compare_1.areEqual(element, value, true)) {\n                        found = i;\n                        return false;\n                    }\n                });\n            return found;\n        };\n        LinqEnumerable.prototype.lastIndexOf = function (value, compareSelector) {\n            var result = -1;\n            this.forEach(compareSelector\n                ? function (element, i) {\n                    if (Compare_1.areEqual(compareSelector(element, i), compareSelector(value, i), true))\n                        result\n                            = i;\n                }\n                : function (element, i) {\n                    if (Compare_1.areEqual(element, value, true))\n                        result = i;\n                });\n            return result;\n        };\n        LinqEnumerable.prototype.intersect = function (second, compareSelector) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!second)\n                throw new ArgumentNullException_1.ArgumentNullException(\"second\");\n            var isEndless = _.isEndless;\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var keys;\n                var outs;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(!second);\n                    enumerator = _.getEnumerator();\n                    keys = new Dictionary_1.Dictionary(compareSelector);\n                    outs = new Dictionary_1.Dictionary(compareSelector);\n                    enumUtil.forEach(second, function (key) {\n                        keys.addByKeyValue(key, true);\n                    });\n                }, function (yielder) {\n                    while (enumerator.moveNext()) {\n                        var current = enumerator.current;\n                        if (!outs.containsKey(current) && keys.containsKey(current)) {\n                            outs.addByKeyValue(current, true);\n                            return yielder.yieldReturn(current);\n                        }\n                    }\n                    return yielder.yieldBreak();\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    if (keys)\n                        enumerator.dispose();\n                    if (outs)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    keys = NULL;\n                    outs = NULL;\n                }, isEndless);\n            }, function () {\n                second = NULL;\n            }, isEndless);\n        };\n        LinqEnumerable.prototype.sequenceEqual = function (second, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Compare_1.areEqual; }\n            this.throwIfDisposed();\n            return dispose_1.using(this.getEnumerator(), function (e1) { return dispose_1.using(enumUtil.from(second), function (e2) {\n                // if both are endless, this will never evaluate.\n                Enumerator_1.throwIfEndless(e1.isEndless && e2.isEndless);\n                while (e1.moveNext()) {\n                    if (!e2.moveNext() || !equalityComparer(e1.current, e2.current))\n                        return false;\n                }\n                return !e2.moveNext();\n            }); });\n        };\n        LinqEnumerable.prototype.ofType = function (type) {\n            this.throwIfDisposed();\n            return _super.prototype.ofType.call(this, type);\n        };\n        // #region Ordering Methods\n        LinqEnumerable.prototype.orderBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            this.throwIfDisposed();\n            return new OrderedEnumerable(this, keySelector, 1 /* Ascending */);\n        };\n        LinqEnumerable.prototype.orderUsing = function (comparison) {\n            this.throwIfDisposed();\n            return new OrderedEnumerable(this, null, 1 /* Ascending */, null, comparison);\n        };\n        LinqEnumerable.prototype.orderUsingReversed = function (comparison) {\n            this.throwIfDisposed();\n            return new OrderedEnumerable(this, null, -1 /* Descending */, null, comparison);\n        };\n        LinqEnumerable.prototype.orderByDescending = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            this.throwIfDisposed();\n            return new OrderedEnumerable(this, keySelector, -1 /* Descending */);\n        };\n        /*\n             weightedSample(weightSelector) {\n             weightSelector = Utils.createLambda(weightSelector);\n             var source = this;\n    \r\n             return new LinqEnumerable<T>(() => {\n             var sortedByBound;\n             var totalWeight = 0;\n    \r\n             return new EnumeratorBase<T>(\n             () => {\n             sortedByBound = source\n             .choose(function (x) {\n             var weight = weightSelector(x);\n             if (weight <= 0) return null; // ignore 0\n    \r\n             totalWeight += weight;\n             return { value: x, bound: totalWeight }\n             })\n             .toArray();\n             },\n             () => {\n             if (sortedByBound.length > 0) {\n             var draw = (Math.random() * totalWeight) + 1;\n    \r\n             var lower = -1;\n             var upper = sortedByBound.length;\n             while (upper - lower > 1) {\n             var index = ((lower + upper) / 2);\n             if (sortedByBound[index].bound >= draw) {\n             upper = index;\n             }\n             else {\n             lower = index;\n             }\n             }\n    \r\n             return (<any>this).yieldReturn(sortedByBound[upper].value);\n             }\n    \r\n             return (<any>this).yieldBreak();\n             },\n             Functions.Blank);\n             });\n             }\n             */\n        // #endregion\n        LinqEnumerable.prototype.buffer = function (size) {\n            return _super.prototype.buffer.call(this, size);\n        };\n        LinqEnumerable.prototype.groupBy = function (keySelector, elementSelector, compareSelector) {\n            var _this = this;\n            if (!elementSelector)\n                elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\n            return new LinqEnumerable(function () { return _this\n                .toLookup(keySelector, elementSelector, compareSelector)\n                .getEnumerator(); });\n        };\n        LinqEnumerable.prototype.partitionBy = function (keySelector, elementSelector, resultSelector, compareSelector) {\n            if (resultSelector === void 0) { resultSelector = function (key, elements) { return new Grouping(key, elements); }; }\n            if (compareSelector === void 0) { compareSelector = Functions.Identity; }\n            var _ = this;\n            if (!elementSelector)\n                elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\n            return new LinqEnumerable(function () {\n                var enumerator;\n                var key;\n                var compareKey;\n                var group;\n                var len;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(!elementSelector);\n                    enumerator = _.getEnumerator();\n                    if (enumerator.moveNext()) {\n                        var v = enumerator.current;\n                        key = keySelector(v);\n                        compareKey = compareSelector(key);\n                        group = [elementSelector(v)];\n                        len = 1;\n                    }\n                    else\n                        group = null;\n                }, function (yielder) {\n                    throwIfDisposed(!elementSelector);\n                    if (!group)\n                        return yielder.yieldBreak();\n                    var hasNext, c;\n                    while ((hasNext = enumerator.moveNext())) {\n                        c = enumerator.current;\n                        if (Compare_1.areEqual(compareKey, compareSelector(keySelector(c))))\n                            group[len++] = elementSelector(c);\n                        else\n                            break;\n                    }\n                    var result = resultSelector(key, group);\n                    if (hasNext) {\n                        c = enumerator.current;\n                        key = keySelector(c);\n                        compareKey = compareSelector(key);\n                        group = [elementSelector(c)];\n                        len = 1;\n                    }\n                    else {\n                        group = null;\n                    }\n                    return yielder.yieldReturn(result);\n                }, function () {\n                    if (enumerator)\n                        enumerator.dispose();\n                    enumerator = NULL;\n                    group = null;\n                });\n            }, function () {\n                elementSelector = NULL;\n            });\n        };\n        LinqEnumerable.prototype.flatten = function () {\n            return _super.prototype.flatten.call(this);\n        };\n        LinqEnumerable.prototype.pairwise = function (selector) {\n            return _super.prototype.pairwise.call(this, selector);\n        };\n        LinqEnumerable.prototype.aggregate = function (reduction, initialValue) {\n            if (initialValue == VOID0) {\n                this.forEach(function (value, i) {\n                    initialValue = i\n                        ? reduction(initialValue, value, i)\n                        : value;\n                });\n            }\n            else {\n                this.forEach(function (value, i) {\n                    initialValue = reduction(initialValue, value, i);\n                });\n            }\n            return initialValue;\n        };\n        /**\n         * Provided as an analog for array.reduce.  Simply a shortcut for aggregate.\n         * @param reduction\n         * @param initialValue\n         */\n        LinqEnumerable.prototype.reduce = function (reduction, initialValue) {\n            return this.aggregate(reduction, initialValue);\n        };\n        LinqEnumerable.prototype.average = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var count = 0;\n            var sum = this.sum(function (e, i) {\n                count++;\n                return selector(e, i);\n            });\n            return (isNaN(sum) || !count)\n                ? NaN\n                : (sum / count);\n        };\n        // If using numbers, it may be useful to call .takeUntil(v=>v==Infinity,true) before calling max. See static versions for numbers.\n        LinqEnumerable.prototype.max = function () {\n            return this.aggregate(Functions.Greater);\n        };\n        LinqEnumerable.prototype.min = function () {\n            return this.aggregate(Functions.Lesser);\n        };\n        LinqEnumerable.prototype.maxBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return this.aggregate(function (a, b) { return (keySelector(a) > keySelector(b)) ? a : b; });\n        };\n        LinqEnumerable.prototype.minBy = function (keySelector) {\n            if (keySelector === void 0) { keySelector = Functions.Identity; }\n            return this.aggregate(function (a, b) { return (keySelector(a) < keySelector(b)) ? a : b; });\n        };\n        // Addition...  Only works with numerical enumerations.\n        LinqEnumerable.prototype.sum = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var sum = 0;\n            // This allows for infinity math that doesn't destroy the other values.\n            var sumInfinite = 0; // Needs more investigation since we are really trying to retain signs.\n            this.forEach(function (x, i) {\n                var value = selector(x, i);\n                if (isNaN(value)) {\n                    sum = NaN;\n                    return false;\n                }\n                if (isFinite(value))\n                    sum += value;\n                else\n                    sumInfinite +=\n                        value > 0 ? (+1) : (-1);\n            });\n            return isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite * Infinity) : sum);\n        };\n        // Multiplication...\n        LinqEnumerable.prototype.product = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var result = 1, exists = false;\n            this.forEach(function (x, i) {\n                exists = true;\n                var value = selector(x, i);\n                if (isNaN(value)) {\n                    result = NaN;\n                    return false;\n                }\n                if (value == 0) {\n                    result = 0; // Multiplying by zero will always end in zero.\n                    return false;\n                }\n                // Multiplication can never recover from infinity and simply must retain signs.\n                // You could cancel out infinity with 1/infinity but no available representation exists.\n                result *= value;\n            });\n            return (exists && isNaN(result)) ? NaN : result;\n        };\n        /**\n         * Takes the first number and divides it by all following.\n         * @param selector\n         * @returns {number}\n         */\n        LinqEnumerable.prototype.quotient = function (selector) {\n            if (selector === void 0) { selector = Types_1.Type.numberOrNaN; }\n            var count = 0;\n            var result = NaN;\n            this.forEach(function (x, i) {\n                var value = selector(x, i);\n                count++;\n                if (count === 1) {\n                    result = value;\n                }\n                else {\n                    if (isNaN(value) || value === 0 || !isFinite(value)) {\n                        result = NaN;\n                        return false;\n                    }\n                    result /= value;\n                }\n            });\n            if (count === 1)\n                result = NaN;\n            return result;\n        };\n        // #endregion\n        // #region Single Value Return...\n        LinqEnumerable.prototype.last = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var value = VOID0;\n            var found = false;\n            _.forEach(function (x) {\n                found = true;\n                value = x;\n            });\n            if (!found)\n                throw new Error(\"last:No element satisfies the condition.\");\n            return value;\n        };\n        LinqEnumerable.prototype.lastOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            var value = VOID0;\n            var found = false;\n            _.forEach(function (x) {\n                found = true;\n                value = x;\n            });\n            return (!found) ? defaultValue : value;\n        };\n        // #endregion\n        LinqEnumerable.prototype.memoize = function () {\n            var source = new LazyList_1.LazyList(this);\n            return (new LinqEnumerable(function () { return source.getEnumerator(); }, function () {\n                source.dispose();\n                source = null;\n            }, this.isEndless));\n        };\n        LinqEnumerable.prototype.throwWhenEmpty = function () {\n            return this.doAction(RETURN, null, this.isEndless, function (count) {\n                if (!count)\n                    throw \"Collection is empty.\";\n            });\n        };\n        return LinqEnumerable;\n    }(InfiniteLinqEnumerable));\n    exports.LinqEnumerable = LinqEnumerable;\n    // Provided for type guarding.\n    var FiniteEnumerable = (function (_super) {\n        __extends(FiniteEnumerable, _super);\n        function FiniteEnumerable(enumeratorFactory, finalizer) {\n            var _this = _super.call(this, enumeratorFactory, finalizer, false) || this;\n            _this._disposableObjectName = \"FiniteEnumerable\";\n            return _this;\n        }\n        return FiniteEnumerable;\n    }(LinqEnumerable));\n    exports.FiniteEnumerable = FiniteEnumerable;\n    var ArrayEnumerable = (function (_super) {\n        __extends(ArrayEnumerable, _super);\n        function ArrayEnumerable(source) {\n            var _this = _super.call(this, function () {\n                _.throwIfDisposed();\n                return new ArrayEnumerator_1.ArrayEnumerator(function () {\n                    _.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\n                    return _._source; // Should never be null, but ArrayEnumerable if not disposed simply treats null as empty array.\n                });\n            }) || this;\n            var _ = _this;\n            _._disposableObjectName = \"ArrayEnumerable\";\n            _._source = source;\n            return _this;\n        }\n        ArrayEnumerable.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._source = NULL;\n        };\n        Object.defineProperty(ArrayEnumerable.prototype, \"source\", {\n            get: function () {\n                return this._source;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ArrayEnumerable.prototype.toArray = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return enumUtil.toArray(_._source);\n        };\n        ArrayEnumerable.prototype.asEnumerable = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            return new ArrayEnumerable(this._source);\n        };\n        ArrayEnumerable.prototype.forEach = function (action, max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this;\n            _.throwIfDisposed();\n            return enumUtil.forEach(_._source, action, max);\n        };\n        // These methods should ALWAYS check for array length before attempting anything.\n        ArrayEnumerable.prototype.any = function (predicate) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source;\n            var len = source.length;\n            return !!len && (!predicate || _super.prototype.any.call(this, predicate));\n        };\n        ArrayEnumerable.prototype.count = function (predicate) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return len && (predicate ? _super.prototype.count.call(this, predicate) : len);\n        };\n        ArrayEnumerable.prototype.elementAtOrDefault = function (index, defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            Integer_1.Integer.assertZeroOrGreater(index, 'index');\n            var source = _._source;\n            return index < source.length\n                ? source[index]\n                : defaultValue;\n        };\n        ArrayEnumerable.prototype.last = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return (len)\n                ? source[len - 1]\n                : _super.prototype.last.call(this);\n        };\n        ArrayEnumerable.prototype.lastOrDefault = function (defaultValue) {\n            var _ = this;\n            _.throwIfDisposed();\n            var source = _._source, len = source.length;\n            return len\n                ? source[len - 1]\n                : defaultValue;\n        };\n        ArrayEnumerable.prototype.skip = function (count) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!(count > 0))\n                return _;\n            return new LinqEnumerable(function () { return new ArrayEnumerator_1.ArrayEnumerator(function () { return _._source; }, count); });\n        };\n        ArrayEnumerable.prototype.takeExceptLast = function (count) {\n            if (count === void 0) { count = 1; }\n            var _ = this;\n            _.throwIfDisposed();\n            return _.take(_._source.length - count);\n        };\n        ArrayEnumerable.prototype.skipToLast = function (count) {\n            var _ = this;\n            _.throwIfDisposed();\n            if (!(count > 0))\n                return Enumerable.empty();\n            if (!isFinite(count))\n                return _;\n            var len = _._source\n                ? _._source.length\n                : 0;\n            return _.skip(len - count);\n        };\n        ArrayEnumerable.prototype.reverse = function () {\n            var _ = this;\n            var disposed = !_.throwIfDisposed();\n            return new LinqEnumerable(function () {\n                _.throwIfDisposed();\n                return new IndexEnumerator_1.IndexEnumerator(function () {\n                    var s = _._source;\n                    throwIfDisposed(disposed || !s);\n                    return {\n                        source: s,\n                        pointer: (s.length - 1),\n                        length: s.length,\n                        step: -1\n                    };\n                });\n            }, function () {\n                disposed = true;\n            });\n        };\n        ArrayEnumerable.prototype.memoize = function () {\n            return this.asEnumerable();\n        };\n        ArrayEnumerable.prototype.sequenceEqual = function (second, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Compare_1.areEqual; }\n            if (Types_1.Type.isArrayLike(second))\n                return Arrays.areEqual(this.source, second, true, equalityComparer);\n            if (second instanceof ArrayEnumerable)\n                return second.sequenceEqual(this.source, equalityComparer);\n            return _super.prototype.sequenceEqual.call(this, second, equalityComparer);\n        };\n        ArrayEnumerable.prototype.toJoinedString = function (separator, selector) {\n            if (separator === void 0) { separator = \"\"; }\n            if (selector === void 0) { selector = Functions.Identity; }\n            var s = this._source;\n            return !selector && (s) instanceof (Array)\n                ? s.join(separator)\n                : _super.prototype.toJoinedString.call(this, separator, selector);\n        };\n        return ArrayEnumerable;\n    }(FiniteEnumerable));\n    var Grouping = (function (_super) {\n        __extends(Grouping, _super);\n        function Grouping(_groupKey, elements) {\n            var _this = _super.call(this, elements) || this;\n            _this._groupKey = _groupKey;\n            _this._disposableObjectName = \"Grouping\";\n            return _this;\n        }\n        Object.defineProperty(Grouping.prototype, \"key\", {\n            get: function () {\n                return this._groupKey;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return Grouping;\n    }(ArrayEnumerable));\n    var Lookup = (function () {\n        function Lookup(_dictionary) {\n            this._dictionary = _dictionary;\n        }\n        Object.defineProperty(Lookup.prototype, \"count\", {\n            get: function () {\n                return this._dictionary.count;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Lookup.prototype.get = function (key) {\n            return this._dictionary.getValue(key) || null;\n        };\n        Lookup.prototype.contains = function (key) {\n            return this._dictionary.containsKey(key);\n        };\n        Lookup.prototype.getEnumerator = function () {\n            var _ = this;\n            var enumerator;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                enumerator = _._dictionary.getEnumerator();\n            }, function (yielder) {\n                if (!enumerator.moveNext())\n                    return false;\n                var current = enumerator.current;\n                return yielder.yieldReturn(new Grouping(current.key, current.value));\n            }, function () {\n                if (enumerator)\n                    enumerator.dispose();\n                enumerator = NULL;\n            });\n        };\n        return Lookup;\n    }());\n    var OrderedEnumerable = (function (_super) {\n        __extends(OrderedEnumerable, _super);\n        function OrderedEnumerable(source, keySelector, order, parent, comparer) {\n            if (comparer === void 0) { comparer = Compare_1.compare; }\n            var _this = _super.call(this, NULL) || this;\n            _this.source = source;\n            _this.keySelector = keySelector;\n            _this.order = order;\n            _this.parent = parent;\n            _this.comparer = comparer;\n            Enumerator_1.throwIfEndless(source && source.isEndless);\n            _this._disposableObjectName = \"OrderedEnumerable\";\n            return _this;\n        }\n        OrderedEnumerable.prototype.createOrderedEnumerable = function (keySelector, order) {\n            this.throwIfDisposed();\n            return new OrderedEnumerable(this.source, keySelector, order, this);\n        };\n        OrderedEnumerable.prototype.thenBy = function (keySelector) {\n            return this.createOrderedEnumerable(keySelector, 1 /* Ascending */);\n        };\n        OrderedEnumerable.prototype.thenUsing = function (comparison) {\n            return new OrderedEnumerable(this.source, null, 1 /* Ascending */, this, comparison);\n        };\n        OrderedEnumerable.prototype.thenByDescending = function (keySelector) {\n            return this.createOrderedEnumerable(keySelector, -1 /* Descending */);\n        };\n        OrderedEnumerable.prototype.thenUsingReversed = function (comparison) {\n            return new OrderedEnumerable(this.source, null, -1 /* Descending */, this, comparison);\n        };\n        OrderedEnumerable.prototype.getEnumerator = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var buffer;\n            var indexes;\n            var index = 0;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                _.throwIfDisposed();\n                index = 0;\n                buffer = Enumerable.toArray(_.source);\n                indexes = createSortContext(_)\n                    .generateSortedIndexes(buffer);\n            }, function (yielder) {\n                _.throwIfDisposed();\n                return (index < indexes.length)\n                    ? yielder.yieldReturn(buffer[indexes[index++]])\n                    : false;\n            }, function () {\n                if (buffer)\n                    buffer.length = 0;\n                buffer = NULL;\n                if (indexes)\n                    indexes.length = 0;\n                indexes = NULL;\n            }, false);\n        };\n        OrderedEnumerable.prototype._onDispose = function () {\n            var _ = this;\n            _super.prototype._onDispose.call(this);\n            _.source = NULL;\n            _.keySelector = NULL;\n            _.order = NULL;\n            _.parent = NULL;\n        };\n        return OrderedEnumerable;\n    }(FiniteEnumerable));\n    // A private static helper for the weave function.\n    function nextEnumerator(queue, e) {\n        if (e) {\n            if (e.moveNext()) {\n                queue.enqueue(e);\n            }\n            else {\n                if (e)\n                    e.dispose();\n                return null;\n            }\n        }\n        return e;\n    }\n    /**\n     * Recursively builds a SortContext chain.\n     * @param orderedEnumerable\n     * @param currentContext\n     * @returns {any}\n     */\n    function createSortContext(orderedEnumerable, currentContext) {\n        if (currentContext === void 0) { currentContext = null; }\n        var context = new KeySortedContext_1.KeySortedContext(currentContext, orderedEnumerable.keySelector, orderedEnumerable.order, orderedEnumerable.comparer);\n        if (orderedEnumerable.parent)\n            return createSortContext(orderedEnumerable.parent, context);\n        return context;\n    }\n    //noinspection JSUnusedLocalSymbols\n    function throwIfDisposed(disposed) {\n        if (disposed)\n            throw new ObjectDisposedException_1.ObjectDisposedException(\"Enumerable\");\n        return true;\n    }\n    function Enumerable(source) {\n        var additional = [];\n        for (var _i = 1; _i < arguments.length; _i++) {\n            additional[_i - 1] = arguments[_i];\n        }\n        return enumerableFrom(source, additional);\n    }\n    exports.Enumerable = Enumerable;\n    function enumerableFrom(source, additional) {\n        var e = Enumerable.fromAny(source);\n        if (!e)\n            throw new UnsupportedEnumerableException_1.UnsupportedEnumerableException();\n        return (additional && additional.length)\n            ? e.merge(additional)\n            : e;\n    }\n    (function (Enumerable) {\n        function from(source) {\n            var additional = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                additional[_i - 1] = arguments[_i];\n            }\n            return enumerableFrom(source, additional);\n        }\n        Enumerable.from = from;\n        function fromAny(source, defaultEnumerable) {\n            if (Types_1.Type.isObject(source) || Types_1.Type.isString(source)) {\n                if (source instanceof InfiniteLinqEnumerable)\n                    return source;\n                if (Types_1.Type.isArrayLike(source))\n                    return new ArrayEnumerable(source);\n                if (Enumerator_1.isEnumerable(source))\n                    return new LinqEnumerable(function () { return source.getEnumerator(); }, null, source.isEndless);\n                if (Enumerator_1.isEnumerator(source))\n                    return new LinqEnumerable(function () { return source; }, null, source.isEndless);\n                if (Enumerator_1.isIterator(source))\n                    return fromAny(new IteratorEnumerator_1.IteratorEnumerator(source));\n            }\n            else if (Types_1.Type.isFunction(source)) {\n                return new InfiniteLinqEnumerable(function () { return new InfiniteEnumerator_1.InfiniteEnumerator(source); });\n            }\n            return defaultEnumerable;\n        }\n        Enumerable.fromAny = fromAny;\n        function fromThese(sources) {\n            switch (sources ? sources.length : 0) {\n                case 0:\n                    return empty();\n                case 1:\n                    // Allow for validation and throwing...\n                    return enumerableFrom(sources[0]);\n                default:\n                    return empty().merge(sources);\n            }\n        }\n        Enumerable.fromThese = fromThese;\n        function fromOrEmpty(source) {\n            return fromAny(source) || empty();\n        }\n        Enumerable.fromOrEmpty = fromOrEmpty;\n        /**\n         * Static helper for converting enumerables to an array.\n         * @param source\n         * @returns {any}\n         */\n        function toArray(source) {\n            if (source instanceof LinqEnumerable)\n                return source.toArray();\n            return enumUtil.toArray(source);\n        }\n        Enumerable.toArray = toArray;\n        function _choice(values) {\n            return new InfiniteLinqEnumerable(function () { return new EnumeratorBase_1.EnumeratorBase(null, function (yielder) {\n                throwIfDisposed(!values);\n                return yielder.yieldReturn(Random_1.Random.select.one(values));\n            }, true // Is endless!\n            ); }, function () {\n                values.length = 0;\n                values = NULL;\n            });\n        }\n        Enumerable._choice = _choice;\n        function choice(values) {\n            var len = values && values.length;\n            // We could return empty if no length, but that would break the typing and produce unexpected results.\n            // Enforcing that there must be at least 1 choice is key.\n            if (!len || !isFinite(len))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            return _choice(copy_1.copy(values));\n        }\n        Enumerable.choice = choice;\n        function chooseFrom() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            // We could return empty if no length, but that would break the typing and produce unexpected results.\n            // Enforcing that there must be at least 1 choice is key.\n            if (!args.length)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            return _choice(args);\n        }\n        Enumerable.chooseFrom = chooseFrom;\n        function _cycle(values) {\n            return new InfiniteLinqEnumerable(function () {\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                }, // Reinitialize the value just in case the enumerator is restarted.\n                function (yielder) {\n                    throwIfDisposed(!values);\n                    if (index >= values.length)\n                        index = 0;\n                    return yielder.yieldReturn(values[index++]);\n                }, true // Is endless!\n                );\n            }, function () {\n                values.length = 0;\n                values = NULL;\n            });\n        }\n        function cycle(values) {\n            var len = values && values.length;\n            // We could return empty if no length, but that would break the typing and produce unexpected results.\n            // Enforcing that there must be at least 1 choice is key.\n            if (!len || !isFinite(len))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            // Make a copy to avoid modifying the collection as we go.\n            return _cycle(copy_1.copy(values));\n        }\n        Enumerable.cycle = cycle;\n        function cycleThrough() {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            // We could return empty if no length, but that would break the typing and produce unexpected results.\n            // Enforcing that there must be at least 1 choice is key.\n            if (!args.length)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException('length', length);\n            return _cycle(args);\n        }\n        Enumerable.cycleThrough = cycleThrough;\n        function empty() {\n            // Could be single export function instance, but for safety, we'll make a new one.\n            return new FiniteEnumerable(getEmptyEnumerator);\n        }\n        Enumerable.empty = empty;\n        function repeat(element, count) {\n            if (count === void 0) { count = Infinity; }\n            if (!(count > 0))\n                return Enumerable.empty();\n            return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n                ? new FiniteEnumerable(function () {\n                    var c = count;\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(function () { index = 0; }, function (yielder) { return (index++ < c) && yielder.yieldReturn(element); }, null, false);\n                })\n                : new LinqEnumerable(function () {\n                    return new EnumeratorBase_1.EnumeratorBase(null, function (yielder) { return yielder.yieldReturn(element); }, true // Is endless!\n                    );\n                });\n        }\n        Enumerable.repeat = repeat;\n        function repeatWithFinalize(initializer, finalizer) {\n            if (!initializer)\n                throw new ArgumentNullException_1.ArgumentNullException(\"initializer\");\n            return new InfiniteLinqEnumerable(function () {\n                var element;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    if (initializer)\n                        element = initializer();\n                }, function (yielder) {\n                    return initializer\n                        ? yielder.yieldReturn(element)\n                        : yielder.yieldBreak();\n                }, function () {\n                    element = NULL;\n                    if (finalizer)\n                        finalizer(element);\n                }, true // Is endless!\n                );\n            }, function () {\n                initializer = NULL;\n                finalizer = VOID0;\n            });\n        }\n        Enumerable.repeatWithFinalize = repeatWithFinalize;\n        /**\n         * Creates an enumerable of one element.\n         * @param element\n         * @returns {FiniteEnumerable<T>}\n         */\n        function make(element) {\n            return repeat(element, 1);\n        }\n        Enumerable.make = make;\n        // start and step can be other than integer.\n        function range(start, count, step) {\n            if (step === void 0) { step = 1; }\n            if (!isFinite(start))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n            if (!(count > 0))\n                return empty();\n            if (!step)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n            if (!isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n            Integer_1.Integer.assert(count, \"count\");\n            return new FiniteEnumerable(function () {\n                var value;\n                var c = count; // Force integer evaluation.\n                var index = 0;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    value = start;\n                }, function (yielder) {\n                    var result = index++ < c\n                        && yielder.yieldReturn(value);\n                    if (result && index < count)\n                        value += step;\n                    return result;\n                }, false);\n            });\n        }\n        Enumerable.range = range;\n        function rangeDown(start, count, step) {\n            if (step === void 0) { step = 1; }\n            step = Math.abs(step) * -1;\n            return range(start, count, step);\n        }\n        Enumerable.rangeDown = rangeDown;\n        // step = -1 behaves the same as toNegativeInfinity;\n        function toInfinity(start, step) {\n            if (start === void 0) { start = 0; }\n            if (step === void 0) { step = 1; }\n            if (!isFinite(start))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\n            if (!step)\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\n            if (!isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\n            return new InfiniteLinqEnumerable(function () {\n                var value;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    value = start;\n                }, function (yielder) {\n                    var current = value;\n                    value += step;\n                    return yielder.yieldReturn(current);\n                }, true // Is endless!\n                );\n            });\n        }\n        Enumerable.toInfinity = toInfinity;\n        function toNegativeInfinity(start, step) {\n            if (start === void 0) { start = 0; }\n            if (step === void 0) { step = 1; }\n            return toInfinity(start, -step);\n        }\n        Enumerable.toNegativeInfinity = toNegativeInfinity;\n        function rangeTo(start, to, step) {\n            if (step === void 0) { step = 1; }\n            if (isNaN(to) || !isFinite(to))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\n            if (step && !isFinite(step))\n                throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\n            // This way we adjust for the delta from start and to so the user can say +/- step and it will work as expected.\n            step = Math.abs(step);\n            return new FiniteEnumerable(function () {\n                var value;\n                return new EnumeratorBase_1.EnumeratorBase(function () { value = start; }, start < to\n                    ? function (yielder) {\n                        var result = value <= to && yielder.yieldReturn(value);\n                        if (result)\n                            value += step;\n                        return result;\n                    }\n                    : function (yielder) {\n                        var result = value >= to && yielder.yieldReturn(value);\n                        if (result)\n                            value -= step;\n                        return result;\n                    }, false);\n            });\n        }\n        Enumerable.rangeTo = rangeTo;\n        function matches(input, pattern, flags) {\n            if (flags === void 0) { flags = \"\"; }\n            if (input == null)\n                throw new ArgumentNullException_1.ArgumentNullException(\"input\");\n            var type = typeof input;\n            if (type != Types_1.Type.STRING)\n                throw new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\n            if (pattern instanceof RegExp) {\n                flags += (pattern.ignoreCase) ? \"i\" : \"\";\n                flags += (pattern.multiline) ? \"m\" : \"\";\n                pattern = pattern.source;\n            }\n            if (flags.indexOf(\"g\") === -1)\n                flags += \"g\";\n            return new FiniteEnumerable(function () {\n                var regex;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    regex = new RegExp(pattern, flags);\n                }, function (yielder) {\n                    // Calling regex.exec consecutively on the same input uses the lastIndex to start the next match.\n                    var match = regex.exec(input);\n                    return match != null\n                        ? yielder.yieldReturn(match)\n                        : yielder.yieldBreak();\n                });\n            });\n        }\n        Enumerable.matches = matches;\n        function generate(factory, count) {\n            if (count === void 0) { count = Infinity; }\n            if (!factory)\n                throw new ArgumentNullException_1.ArgumentNullException(\"factory\");\n            if (isNaN(count) || count <= 0)\n                return Enumerable.empty();\n            return isFinite(count) && Integer_1.Integer.assert(count, \"count\")\n                ? new FiniteEnumerable(function () {\n                    var c = count;\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(function () {\n                        index = 0;\n                    }, function (yielder) {\n                        throwIfDisposed(!factory);\n                        var current = index++;\n                        return current < c && yielder.yieldReturn(factory(current));\n                    }, false);\n                }, function () {\n                    factory = NULL;\n                })\n                : new InfiniteLinqEnumerable(function () {\n                    var index = 0;\n                    return new EnumeratorBase_1.EnumeratorBase(function () {\n                        index = 0;\n                    }, function (yielder) {\n                        throwIfDisposed(!factory);\n                        return yielder.yieldReturn(factory(index++));\n                    }, true // Is endless!\n                    );\n                }, function () {\n                    factory = NULL;\n                });\n        }\n        Enumerable.generate = generate;\n        var random;\n        (function (random) {\n            function floats(maxExclusive) {\n                if (maxExclusive === void 0) { maxExclusive = 1; }\n                return generate(Random_1.Random.generate(maxExclusive));\n            }\n            random.floats = floats;\n            function integers(boundary, inclusive) {\n                return generate(Random_1.Random.generate.integers(boundary, inclusive));\n            }\n            random.integers = integers;\n        })(random = Enumerable.random || (Enumerable.random = {}));\n        function unfold(seed, valueFactory, skipSeed) {\n            if (skipSeed === void 0) { skipSeed = false; }\n            if (!valueFactory)\n                throw new ArgumentNullException_1.ArgumentNullException(\"factory\");\n            return new InfiniteLinqEnumerable(function () {\n                var index = 0;\n                var value;\n                var isFirst;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    index = 0;\n                    value = seed;\n                    isFirst = !skipSeed;\n                }, function (yielder) {\n                    throwIfDisposed(!valueFactory);\n                    var i = index++;\n                    if (isFirst)\n                        isFirst = false;\n                    else\n                        value = valueFactory(value, i);\n                    return yielder.yieldReturn(value);\n                }, true // Is endless!\n                );\n            }, function () {\n                valueFactory = NULL;\n            });\n        }\n        Enumerable.unfold = unfold;\n        function forEach(enumerable, action, max) {\n            if (max === void 0) { max = Infinity; }\n            // Will properly dispose created enumerable.\n            // Will throw if enumerable is endless.\n            return enumUtil.forEach(enumerable, action, max);\n        }\n        Enumerable.forEach = forEach;\n        function map(enumerable, selector) {\n            // Will properly dispose created enumerable.\n            // Will throw if enumerable is endless.\n            return enumUtil.map(enumerable, selector);\n        }\n        Enumerable.map = map;\n        // Slightly optimized versions for numbers.\n        function max(values) {\n            var v = values\n                .takeUntil(function (v) { return v == +Infinity; }, true)\n                .aggregate(Functions.Greater);\n            return v === VOID0 ? NaN : v;\n        }\n        Enumerable.max = max;\n        function min(values) {\n            var v = values\n                .takeUntil(function (v) { return v == -Infinity; }, true)\n                .aggregate(Functions.Lesser);\n            return v === VOID0 ? NaN : v;\n        }\n        Enumerable.min = min;\n        /**\n         * Takes any set of collections of the same type and weaves them together.\n         * @param enumerables\n         * @returns {Enumerable<T>}\n         */\n        function weave(enumerables) {\n            if (!enumerables)\n                throw new ArgumentNullException_1.ArgumentNullException('enumerables');\n            var disposed = false;\n            return new LinqEnumerable(function () {\n                var queue;\n                var mainEnumerator;\n                var index;\n                return new EnumeratorBase_1.EnumeratorBase(function () {\n                    throwIfDisposed(disposed);\n                    index = 0;\n                    queue = new Queue_1.Queue();\n                    mainEnumerator = enumUtil.from(enumerables);\n                }, function (yielder) {\n                    throwIfDisposed(disposed);\n                    var e = null;\n                    // First pass...\n                    if (mainEnumerator) {\n                        while (!e && mainEnumerator.moveNext()) {\n                            var c = mainEnumerator.current;\n                            e = nextEnumerator(queue, c ? enumUtil.from(c) : NULL);\n                        }\n                        if (!e)\n                            mainEnumerator = null;\n                    }\n                    while (!e && queue.tryDequeue(function (value) {\n                        e = nextEnumerator(queue, enumUtil.from(value));\n                    })) { }\n                    return e\n                        ? yielder.yieldReturn(e.current)\n                        : yielder.yieldBreak();\n                }, function () {\n                    if (queue) {\n                        dispose_1.dispose.these.noCopy(queue.dump());\n                        queue = NULL;\n                    }\n                    if (mainEnumerator)\n                        mainEnumerator.dispose();\n                    mainEnumerator = null;\n                });\n            }, function () {\n                disposed = true;\n            });\n        }\n        Enumerable.weave = weave;\n    })(Enumerable = exports.Enumerable || (exports.Enumerable = {}));\n    exports.default = Enumerable;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Original: http://linqjs.codeplex.com/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual as areEqualValues, compare as compareValues} from \"../System/Compare\";\r\nimport {copy} from \"../System/Collections/Array/copy\";\r\nimport * as Arrays from \"../System/Collections/Array/Compare\";\r\nimport * as enumUtil from \"../System/Collections/Enumeration/Enumerator\";\r\nimport {\r\n\tisEnumerable,\r\n\tisEnumerator,\r\n\tisIterator,\r\n\tthrowIfEndless\r\n} from \"../System/Collections/Enumeration/Enumerator\";\r\nimport {EmptyEnumerator} from \"../System/Collections/Enumeration/EmptyEnumerator\";\r\nimport {Type} from \"../System/Types\";\r\nimport {Integer} from \"../System/Integer\";\r\nimport {Functions as BaseFunctions} from \"../System/Functions\";\r\nimport {ArrayEnumerator} from \"../System/Collections/Enumeration/ArrayEnumerator\";\r\nimport {EnumeratorBase} from \"../System/Collections/Enumeration/EnumeratorBase\";\r\nimport {Dictionary} from \"../System/Collections/Dictionaries/Dictionary\";\r\nimport {Queue} from \"../System/Collections/Queue\";\r\nimport {dispose, using} from \"../System/Disposable/dispose\";\r\nimport {DisposableBase} from \"../System/Disposable/DisposableBase\";\r\nimport {UnsupportedEnumerableException} from \"../System/Collections/Enumeration/UnsupportedEnumerableException\";\r\nimport {ObjectDisposedException} from \"../System/Disposable/ObjectDisposedException\";\r\nimport {KeySortedContext} from \"../System/Collections/Sorting/KeySortedContext\";\r\nimport {ArgumentNullException} from \"../System/Exceptions/ArgumentNullException\";\r\nimport {ArgumentOutOfRangeException} from \"../System/Exceptions/ArgumentOutOfRangeException\";\r\nimport {IEnumerator} from \"../System/Collections/Enumeration/IEnumerator\";\r\nimport {IEnumerable} from \"../System/Collections/Enumeration/IEnumerable\";\r\nimport {\r\n\tAction,\r\n\tActionWithIndex,\r\n\tClosure,\r\n\tComparison,\r\n\tEqualityComparison,\r\n\tPredicate,\r\n\tPredicateWithIndex,\r\n\tSelector,\r\n\tSelectorWithIndex\r\n} from \"../System/FunctionTypes\";\r\nimport {IDictionary, IMap} from \"../System/Collections/Dictionaries/IDictionary\";\r\nimport {Comparable} from \"../System/IComparable\";\r\nimport {IComparer} from \"../System/IComparer\";\r\nimport {IKeyValuePair} from \"../System/KeyValuePair\";\r\nimport {Order} from \"../System/Collections/Sorting/Order\";\r\nimport {\r\n\tIFiniteEnumerable,\r\n\tIGrouping,\r\n\tIInfiniteEnumerable,\r\n\tILinqEnumerable,\r\n\tILookup,\r\n\tIOrderedEnumerable,\r\n\tNotEmptyEnumerable\r\n} from \"./Enumerable\";\r\nimport {EnumerableAction} from \"./EnumerableAction\";\r\nimport {IndexEnumerator} from \"../System/Collections/Enumeration/IndexEnumerator\";\r\nimport {Primitive} from \"../System/Primitive\";\r\nimport {IteratorEnumerator} from \"../System/Collections/Enumeration/IteratorEnumerator\";\r\nimport {ForEachEnumerable} from \"../System/Collections/Enumeration/ForEachEnumerable\";\r\nimport {initialize} from \"../System/Collections/Array/initialize\";\r\nimport {Random} from \"../System/Random\";\r\nimport {\r\n\tInfiniteEnumerator,\r\n\tInfiniteValueFactory\r\n} from \"../System/Collections/Enumeration/InfiniteEnumerator\";\r\nimport __extendsImport from \"../extends\";\r\nimport {LazyList} from \"../System/Collections/LazyList\";\r\nimport disposeSingle = dispose.single;\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n// #region Local Constants.\r\n\r\nconst INVALID_DEFAULT:any = {}; // create a private unique instance for referencing.\r\nconst VOID0:undefined = void 0;\r\nconst NULL:any = null;\r\nfunction BREAK():EnumerableAction\r\n{\r\n\treturn EnumerableAction.Break;\r\n}\r\nfunction RETURN():EnumerableAction\r\n{\r\n\treturn EnumerableAction.Return;\r\n}\r\nfunction isNotNullOrUndefined(e:any):boolean\r\n{\r\n\treturn e!=null;\r\n}\r\n\r\n\r\n// Leave internal to avoid accidental overwriting.\r\nclass LinqFunctions\r\n\textends BaseFunctions\r\n{\r\n\t// noinspection JSMethodCanBeStatic\r\n\tGreater<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a>b ? a : b;\r\n\t}\r\n\r\n\r\n\t// noinspection JSMethodCanBeStatic\r\n\tLesser<T>(a:T, b:T)\r\n\t{\r\n\t\treturn a<b ? a : b;\r\n\t}\r\n}\r\n\r\nconst Functions = Object.freeze(new LinqFunctions());\r\n\r\n// For re-use as a factory.\r\nfunction getEmptyEnumerator():IEnumerator<any>\r\n{\r\n\treturn EmptyEnumerator;\r\n}\r\n\r\n// #endregion\r\n\r\n\r\n/*\r\n * NOTE: About InfiniteEnumerable<T> and Enumerable<T>.\r\n * There may seem like there's extra overrides here and they may seem unnecessary.\r\n * But after closer inspection you'll see the type chain is retained and\r\n * infinite enumerables are prevented from having features that finite ones have.\r\n *\r\n * I'm not sure if it's the best option to just use overrides, but it honors the typing properly.\r\n */\r\n\r\nexport class InfiniteLinqEnumerable<T>\r\n\textends DisposableBase\r\n\timplements IInfiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tprotected _enumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure | null)\r\n\t{\r\n\t\tsuper(finalizer);\r\n\t\tthis._isEndless = true;\r\n\t\tthis._disposableObjectName = \"InfiniteLinqEnumerable\";\r\n\t}\r\n\r\n\tprotected _isEndless:boolean | undefined;\r\n\tget isEndless():boolean | undefined\r\n\t{\r\n\t\treturn this._isEndless;\r\n\t}\r\n\r\n\t// #region IEnumerable<T> Implementation...\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn this._enumeratorFactory();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region IDisposable override...\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose(); // Just in case.\r\n\t\t(<any>this)._enumeratorFactory = null;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// Return a default (unfiltered) enumerable.\r\n\tasEnumerable():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\treturn <any> new InfiniteLinqEnumerable<T>(() => _.getEnumerator());\r\n\t}\r\n\r\n\t/**\r\n\t * Similar to forEach, but executes an action for each time a value is enumerated.\r\n\t * If the action explicitly returns false or 0 (EnumerationAction.Break), the enumeration will complete.\r\n\t * If it returns a 2 (EnumerationAction.Skip) it will move on to the next item.\r\n\t * This also automatically handles disposing the enumerator.\r\n\t * @param action\r\n\t * @param initializer\r\n\t * @param isEndless Special case where isEndless can be null in order to negate inheritance.\r\n\t * @param onComplete Executes just before the enumerator releases when there is no more entries.\r\n\t * @returns {any}\r\n\t */\r\n\r\n\tdoAction(\r\n\t\taction:ActionWithIndex<T> | PredicateWithIndex<T> | SelectorWithIndex<T, number> | SelectorWithIndex<T, EnumerableAction>,\r\n\t\tinitializer:Closure | null,\r\n\t\tisEndless:true,\r\n\t\tonComplete?:Action<number>):InfiniteLinqEnumerable<T>\r\n\r\n\tdoAction(\r\n\t\taction:ActionWithIndex<T> | PredicateWithIndex<T> | SelectorWithIndex<T, number> | SelectorWithIndex<T, EnumerableAction>,\r\n\t\tinitializer?:Closure | null,\r\n\t\tisEndless?:boolean | null | undefined,\r\n\t\tonComplete?:Action<number>):LinqEnumerable<T>\r\n\r\n\tdoAction(\r\n\t\taction:ActionWithIndex<T> | PredicateWithIndex<T> | SelectorWithIndex<T, number> | SelectorWithIndex<T, EnumerableAction>,\r\n\t\tinitializer?:Closure | null,\r\n\t\tisEndless:boolean | null | undefined = this.isEndless,\r\n\t\tonComplete?:Action<number>):LinqEnumerable<T>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tconst isE:boolean | undefined = isEndless || undefined; // In case it's null.\r\n\t\tif(!action)\r\n\t\t\tthrow new ArgumentNullException(\"action\");\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!action);\r\n\r\n\t\t\t\t\t\tif(initializer) initializer();\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t// May need a way to propagate isEndless\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!action);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet c = enumerator.current!;\r\n\t\t\t\t\t\t\tlet actionResult = <any>action(c, index++);\r\n\r\n\t\t\t\t\t\t\tif(actionResult===false || actionResult===EnumerableAction.Break)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tif(actionResult!==EnumerableAction.Skip) // || !== 2\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(c);\r\n\r\n\t\t\t\t\t\t\t// If actionResult===2, then a signal for skip is received.\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(onComplete) onComplete(index);\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisE\r\n\t\t\t\t);\r\n\r\n\t\t\t},\r\n\t\t\t// Using a finalizer value reduces the chance of a circular reference\r\n\t\t\t// since we could simply reference the enumeration and check e.wasDisposed.\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\taction = NULL;\r\n\t\t\t},\r\n\r\n\t\t\tisE\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforce():void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tthis.doAction(BREAK)\r\n\t\t\t.getEnumerator()\r\n\t\t\t.moveNext();\r\n\r\n\t}\r\n\r\n\t// #region Indexing/Paging methods.\r\n\tskip(count:number):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn <any> new InfiniteLinqEnumerable<T>(getEmptyEnumerator);\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn this.where((element, index) => index>=count);\r\n\t}\r\n\r\n\r\n\ttake(count:number):FiniteEnumerable<T>\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!isFinite(count))\r\n\t\t\tthrow new ArgumentOutOfRangeException('count', count, 'Must be finite.');\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// Once action returns false, the enumeration will stop.\r\n\t\treturn <any> _.doAction((element, index) => index<count, null, false);\r\n\t}\r\n\r\n\t// #region Single Value Return...\r\n\r\n\telementAt(index:number):T\r\n\t{\r\n\t\tconst v = this.elementAtOrDefault(index, INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new ArgumentOutOfRangeException('index', index, \"is greater than or equal to the number of elements in source\");\r\n\t\treturn <T>v;\r\n\t}\r\n\r\n\telementAtOrDefault(index:number):T | undefined\r\n\telementAtOrDefault(index:number, defaultValue:T):T\r\n\telementAtOrDefault(index:number, defaultValue?:T):T | undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tconst n:number = index;\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te =>\r\n\t\t\t{\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\twhile(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(i==n) return e.current;\r\n\t\t\t\t\ti++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t});\r\n\t}\r\n\r\n\t/* Note: Unlike previous implementations, you could pass a predicate into these methods.\r\n\t * But since under the hood it ends up calling .where(predicate) anyway,\r\n\t * it may be better to remove this to allow for a cleaner signature/override.\r\n\t * JavaScript/TypeScript does not easily allow for a strict method interface like C#.\r\n\t * Having to write extra override logic is error prone and confusing to the consumer.\r\n\t * Removing the predicate here may also cause the consumer of this method to think more about how they structure their query.\r\n\t * The end all difference is that the user must declare .where(predicate) before .first(), .single(), or .last().\r\n\t * Otherwise there would need to be much more code to handle these cases (.first(predicate), etc);\r\n\t * */\r\n\r\n\tfirst():T\r\n\t{\r\n\t\tconst v = this.firstOrDefault(INVALID_DEFAULT);\r\n\t\tif(v===INVALID_DEFAULT) throw new Error(\"first:The sequence is empty.\");\r\n\t\treturn <T>v;\r\n\t}\r\n\r\n\tfirstOrDefault():T | undefined\r\n\tfirstOrDefault(defaultValue:T):T\r\n\tfirstOrDefault(defaultValue?:T):T | undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te => e.moveNext() ? e.current : defaultValue\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tsingle():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn <T>using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te =>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t\tthrow new Error(\"single:sequence contains more than one element.\");\r\n\t\t\t\t}\r\n\t\t\t\tthrow new Error(\"single:The sequence is empty.\");\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tsingleOrDefault():T | undefined\r\n\tsingleOrDefault(defaultValue:T):T\r\n\tsingleOrDefault(defaultValue?:T):T | undefined\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te =>\r\n\t\t\t{\r\n\t\t\t\tif(e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tlet value = e.current;\r\n\t\t\t\t\tif(!e.moveNext()) return value;\r\n\t\t\t\t}\r\n\t\t\t\treturn defaultValue;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tany():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te => e.moveNext()\r\n\t\t);\r\n\t}\r\n\r\n\tisEmpty():boolean\r\n\t{\r\n\t\treturn !this.any();\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\t// #region Projection and Filtering Methods\r\n\r\n\r\n\ttraverseDepthFirst(\r\n\t\tchildrenSelector:(element:T) => ForEachEnumerable<T> | null | undefined):LinqEnumerable<T>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined):LinqEnumerable<TNode>;\r\n\r\n\ttraverseDepthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => ForEachEnumerable<T> | null | undefined,\r\n\t\tresultSelector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined,\r\n\t\tresultSelector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>;\r\n\r\n\ttraverseDepthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel:number) => any = Functions.Identity):LinqEnumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\r\n\t\tconst isEndless = _._isEndless; // Is endless is not affirmative if false.\r\n\r\n\t\treturn new LinqEnumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t// Dev Note: May want to consider using an actual stack and not an array.\r\n\t\t\t\tlet enumeratorStack:IEnumerator<any>[];\r\n\t\t\t\tlet enumerator:IEnumerator<any>;\r\n\t\t\t\tlet len:number;  // Avoid using push/pop since they query .length every time and can be slower.\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tenumeratorStack = [];\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet value = resultSelector(<TNode>enumerator.current, len);\r\n\t\t\t\t\t\t\t\tenumeratorStack[len++] = enumerator;\r\n\t\t\t\t\t\t\t\tlet c = childrenSelector(<T | TNode>enumerator.current);\r\n\t\t\t\t\t\t\t\tlet e = !Type.isString(c) && Enumerable.fromAny(c);\r\n\t\t\t\t\t\t\t\tenumerator = e ? e.getEnumerator() : EmptyEnumerator;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(len==0) return false;\r\n\r\n\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\tenumerator = enumeratorStack[--len];\r\n\t\t\t\t\t\t\tenumeratorStack.length = len;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumeratorStack)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tdispose.these.noCopy(enumeratorStack);\r\n\t\t\t\t\t\t\t\tenumeratorStack.length = 0;\r\n\t\t\t\t\t\t\t\tenumeratorStack = NULL;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tflatten<TFlat>():InfiniteLinqEnumerable<TFlat>\r\n\tflatten():InfiniteLinqEnumerable<any>\r\n\tflatten():InfiniteLinqEnumerable<any>\r\n\t{\r\n\t\treturn this.selectMany(entry =>\r\n\t\t{\r\n\t\t\tlet e = !Type.isString(entry) && Enumerable.fromAny(entry);\r\n\t\t\treturn e ? e.flatten() : [entry];\r\n\t\t});\r\n\t}\r\n\r\n\r\n\tpairwise<TSelect>(\r\n\t\tselector:(\r\n\t\t\tprevious:T, current:T,\r\n\t\t\tindex:number) => TSelect):InfiniteLinqEnumerable<TSelect>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!selector)\r\n\t\t\tthrow new ArgumentNullException(\"selector\");\r\n\r\n\t\tlet previous:T;\r\n\t\treturn this.select<TSelect>((value, i) =>\r\n\t\t{\r\n\t\t\tconst result:any = i ? selector(previous!, value, i) : NULL;\r\n\t\t\tprevious = value;\r\n\t\t\treturn result;\r\n\t\t}).skip(1);\r\n\t}\r\n\r\n\tscan(func:(previous:T, current:T, index:number) => T, seed?:T):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!func)\r\n\t\t\tthrow new ArgumentNullException(\"func\");\r\n\r\n\t\treturn <this>(\r\n\t\t\tseed===VOID0\r\n\t\t\t\t? this.select((value, i) => seed = i ? func(seed!, value, i) : value)\r\n\t\t\t\t: this.select((value, i) => seed = func(seed!, value, i))\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tselect<TResult>(selector:SelectorWithIndex<T, TResult>):InfiniteLinqEnumerable<TResult>\r\n\t{\r\n\t\treturn this._filterSelected(selector);\r\n\t}\r\n\r\n\tmap<TResult>(selector:SelectorWithIndex<T, TResult>):InfiniteLinqEnumerable<TResult>\r\n\t{\r\n\t\treturn this._filterSelected(selector);\r\n\t}\r\n\r\n\t/*\r\n\tpublic static IEnumerable<TResult> SelectMany<TSource, TCollection, TResult>(\r\n\t\tthis IEnumerable<TSource> source,\r\n\t\tFunc<TSource,IEnumerable<TCollection>> collectionSelector,\r\n\t\tFunc<TSource,TCollection,TResult> resultSelector)\r\n\t */\r\n\r\n\tprotected _selectMany<TElement, TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<TElement> | null | undefined>,\r\n\t\tresultSelector?:(collection:T, element:TElement) => TResult):LinqEnumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!collectionSelector)\r\n\t\t\tthrow new ArgumentNullException(\"collectionSelector\");\r\n\r\n\t\tconst isEndless = _._isEndless; // Do second enumeration, it will be indeterminate if false.\r\n\t\tif(!resultSelector)\r\n\t\t\tresultSelector = (a:T, b:any) => <TResult>b;\r\n\r\n\t\treturn new LinqEnumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet middleEnumerator:IEnumerator<any> | null | undefined;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!collectionSelector);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tmiddleEnumerator = VOID0;\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!collectionSelector);\r\n\t\t\t\t\t\t// Just started, and nothing to enumerate? End.\r\n\t\t\t\t\t\tif(middleEnumerator===VOID0 && !enumerator.moveNext())\r\n\t\t\t\t\t\t\treturn false;\r\n\r\n\t\t\t\t\t\t// moveNext has been called at least once...\r\n\t\t\t\t\t\tdo\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\t// Initialize middle if there isn't one.\r\n\t\t\t\t\t\t\tif(!middleEnumerator)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet middleSeq = collectionSelector(<T>enumerator.current, index++);\r\n\r\n\t\t\t\t\t\t\t\t// Collection is null?  Skip it...\r\n\t\t\t\t\t\t\t\tif(!middleSeq)\r\n\t\t\t\t\t\t\t\t\tcontinue;\r\n\r\n\t\t\t\t\t\t\t\tmiddleEnumerator = enumUtil.from(middleSeq);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(middleEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\tresultSelector!(\r\n\t\t\t\t\t\t\t\t\t\t<T>enumerator.current, <TElement>middleEnumerator.current\r\n\t\t\t\t\t\t\t\t\t)\r\n\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t// else no more in this middle?  Then clear and reset for next...\r\n\r\n\t\t\t\t\t\t\tmiddleEnumerator.dispose();\r\n\t\t\t\t\t\t\tmiddleEnumerator = null;\r\n\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(enumerator.moveNext());\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tdisposeSingle(middleEnumerator);\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tmiddleEnumerator = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tcollectionSelector = NULL;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<TResult> | null | undefined>):InfiniteLinqEnumerable<TResult>;\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<TElement> | null | undefined>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):InfiniteLinqEnumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<any> | null | undefined>,\r\n\t\tresultSelector?:(collection:T, element:any) => TResult):InfiniteLinqEnumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tprotected _filterSelected(\r\n\t\tselector?:SelectorWithIndex<T, T>,\r\n\t\tfilter?:PredicateWithIndex<T>):LinqEnumerable<T>\r\n\tprotected _filterSelected<TResult>(\r\n\t\tselector:SelectorWithIndex<T, TResult>,\r\n\t\tfilter?:PredicateWithIndex<TResult>):LinqEnumerable<TResult>\r\n\tprotected _filterSelected(\r\n\t\tselector:SelectorWithIndex<T, any> = Functions.Identity,\r\n\t\tfilter?:PredicateWithIndex<any>):LinqEnumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\t\tif(!selector)\r\n\t\t\tthrow new ArgumentNullException(\"selector\");\r\n\r\n\t\treturn new LinqEnumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\r\n\t\t\t\treturn new EnumeratorBase<any>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!selector);\r\n\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet i = index++;\r\n\t\t\t\t\t\t\tlet result = selector(enumerator.current!, i);\r\n\t\t\t\t\t\t\tif(!filter || filter(result, i++))\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t_._isEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = false;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns selected values that are not null or undefined.\r\n\t */\r\n\tchoose():InfiniteLinqEnumerable<T>;\r\n\tchoose<TResult>(selector?:Selector<T, TResult>):InfiniteLinqEnumerable<TResult>\r\n\tchoose(selector:Selector<T, any> = Functions.Identity):InfiniteLinqEnumerable<any>\r\n\t{\r\n\t\treturn this._filterSelected(selector, isNotNullOrUndefined);\r\n\t}\r\n\r\n\twhere(predicate:PredicateWithIndex<T>):this\r\n\t{\r\n\t\treturn <any>this._filterSelected(Functions.Identity, predicate);\r\n\t}\r\n\r\n\tfilter(predicate:PredicateWithIndex<T>):this\r\n\t{\r\n\t\treturn <any>this._filterSelected(Functions.Identity, predicate);\r\n\t}\r\n\r\n\tnonNull():this\r\n\t{\r\n\t\treturn this.where(v => v!=null && v!=VOID0);\r\n\t}\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):InfiniteLinqEnumerable<TType>;\r\n\tofType<TType>(type:any):InfiniteLinqEnumerable<TType>\r\n\t{\r\n\t\tlet typeName:string;\r\n\t\tswitch(<any>type)\r\n\t\t{\r\n\t\t\tcase Number:\r\n\t\t\t\ttypeName = Type.NUMBER;\r\n\t\t\t\tbreak;\r\n\t\t\tcase String:\r\n\t\t\t\ttypeName = Type.STRING;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Boolean:\r\n\t\t\t\ttypeName = Type.BOOLEAN;\r\n\t\t\t\tbreak;\r\n\t\t\tcase Function:\r\n\t\t\t\ttypeName = Type.FUNCTION;\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\treturn <any> this\r\n\t\t\t\t\t.where(x => x instanceof type);\r\n\t\t}\r\n\t\treturn <any>this\r\n\t\t\t.where(x => isNotNullOrUndefined(x) && typeof x===typeName);\r\n\t}\r\n\r\n\texcept(\r\n\t\tsecond:ForEachEnumerable<T>,\r\n\t\tcompareSelector?:Selector<T, string | number | symbol>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T, boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\tif(second)\r\n\t\t\t\t\t\t\tenumUtil.forEach(second, key => { keys.addByKeyValue(key, true) });\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet current = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tkeys.clear();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tdistinct(compareSelector?:Selector<T, string | number | symbol>):this\r\n\t{\r\n\t\treturn this.except(NULL, compareSelector);\r\n\t}\r\n\r\n\t// [0,0,0,1,1,1,2,2,2,0,0,0,1,1] results in [0,1,2,0,1];\r\n\tdistinctUntilChanged(compareSelector:Selector<T, any> = Functions.Identity):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet compareKey:any;\r\n\t\t\t\tlet initial:boolean = true;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet key = compareSelector(<T>enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(initial)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tinitial = false;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse if(areEqualValues(compareKey, key))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tcompareKey = key;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a single default value if empty.\r\n\t * @param defaultValue\r\n\t * @returns {Enumerable}\r\n\t */\r\n\tdefaultIfEmpty(defaultValue?:T):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst disposed:boolean = !_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet isFirst:boolean;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tisFirst = true;\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse if(isFirst)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(defaultValue);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tzip<TSecond, TResult>(\r\n\t\tsecond:ForEachEnumerable<TSecond>,\r\n\t\tresultSelector:(first:T, second:TSecond, index:number) => TResult):LinqEnumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\r\n\t\treturn new LinqEnumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumUtil.from<TSecond>(second);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) => firstEnumerator.moveNext()\r\n\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(resultSelector(<T>firstEnumerator.current, <TSecond>secondEnumerator.current, index++)),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator) firstEnumerator.dispose();\r\n\t\t\t\t\t\tif(secondEnumerator) secondEnumerator.dispose();\r\n\t\t\t\t\t\tfirstEnumerator = NULL;\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tzipMultiple<TSecond, TResult>(\r\n\t\tsecond:ArrayLike<ForEachEnumerable<TSecond>>,\r\n\t\tresultSelector:(first:T, second:TSecond, index:number) => TResult):LinqEnumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!second.length)\r\n\t\t\treturn Enumerable.empty<TResult>();\r\n\r\n\t\treturn new LinqEnumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet secondTemp:Queue<any>;\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<TSecond>;\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tsecondTemp = new Queue<any>(second);\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\twhile(!secondEnumerator)\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(secondTemp.count)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\tlet next = secondTemp.dequeue();\r\n\t\t\t\t\t\t\t\t\t\tif(next) // In case by chance next is null, then try again.\r\n\t\t\t\t\t\t\t\t\t\t\tsecondEnumerator = enumUtil.from<TSecond>(next);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(\r\n\t\t\t\t\t\t\t\t\t\tresultSelector(<T>firstEnumerator.current, <TSecond>secondEnumerator.current, index++)\r\n\t\t\t\t\t\t\t\t\t);\r\n\r\n\t\t\t\t\t\t\t\tsecondEnumerator.dispose();\r\n\t\t\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator) firstEnumerator.dispose();\r\n\t\t\t\t\t\tif(secondEnumerator) secondEnumerator.dispose();\r\n\t\t\t\t\t\tif(secondTemp) secondTemp.dispose();\r\n\t\t\t\t\t\tfirstEnumerator = NULL;\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t\tsecondTemp = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\t// #region Join Methods\r\n\r\n\tjoin<TInner, TKey, TResult>(\r\n\t\tinner:ForEachEnumerable<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner) => TResult,\r\n\t\tcompareSelector:Selector<TKey, string | number | symbol> = Functions.Identity):LinqEnumerable<TResult>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\treturn new LinqEnumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet outerEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet lookup:ILookup<TKey, TInner>;\r\n\t\t\t\tlet innerElements:TInner[] | null;\r\n\t\t\t\tlet innerCount:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\touterEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(innerElements)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet innerElement = innerElements[innerCount++];\r\n\t\t\t\t\t\t\t\tif(innerElement!==VOID0)\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(<T>outerEnumerator.current, innerElement));\r\n\r\n\t\t\t\t\t\t\t\tinnerElements = null;\r\n\t\t\t\t\t\t\t\tinnerCount = 0;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(outerEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet key = outerKeySelector(<T>outerEnumerator.current);\r\n\t\t\t\t\t\t\t\tinnerElements = lookup.get(key);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(outerEnumerator) outerEnumerator.dispose();\r\n\t\t\t\t\t\tinnerElements = null;\r\n\t\t\t\t\t\touterEnumerator = NULL;\r\n\t\t\t\t\t\tlookup = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tgroupJoin<TInner, TKey, TResult>(\r\n\t\tinner:ForEachEnumerable<TInner>,\r\n\t\touterKeySelector:Selector<T, TKey>,\r\n\t\tinnerKeySelector:Selector<TInner, TKey>,\r\n\t\tresultSelector:(outer:T, inner:TInner[] | null) => TResult,\r\n\t\tcompareSelector:Selector<TKey, string | number | symbol> = Functions.Identity):LinqEnumerable<TResult>\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\treturn new LinqEnumerable<TResult>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet lookup:ILookup<TKey, TInner>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<TResult>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tlookup = Enumerable.from(inner)\r\n\t\t\t\t\t\t\t.toLookup(innerKeySelector, Functions.Identity, compareSelector);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\tenumerator.moveNext()\r\n\t\t\t\t\t&& yielder.yieldReturn(\r\n\t\t\t\t\t\tresultSelector(\r\n\t\t\t\t\t\t\t<T>enumerator.current,\r\n\t\t\t\t\t\t\tlookup.get(outerKeySelector(<T>enumerator.current))\r\n\t\t\t\t\t\t)\r\n\t\t\t\t\t),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tlookup = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tmerge(enumerables:ArrayLike<ForEachEnumerable<T>>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\tif(!enumerables || enumerables.length==0)\r\n\t\t\treturn _;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet queue:Queue<ForEachEnumerable<T>>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// 1) First get our values...\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tqueue = new Queue<ForEachEnumerable<T>>(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\r\n\t\t\t\t\t\t\twhile(!enumerator && queue.tryDequeue(value =>\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator = enumUtil.from<T>(value); // 4) Keep going and on to step 2.  Else fall through to yieldBreak().\r\n\t\t\t\t\t\t\t}))\r\n\t\t\t\t\t\t\t{ }\r\n\r\n\t\t\t\t\t\t\tif(enumerator && enumerator.moveNext()) // 2) Keep returning until done.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\r\n\t\t\t\t\t\t\tif(enumerator) // 3) Dispose and reset for next.\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tif(queue) queue.dispose();\r\n\t\t\t\t\t\tqueue = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tconcat(...enumerables:Array<ForEachEnumerable<T>>):this\r\n\t{\r\n\t\treturn this.merge(enumerables);\r\n\t}\r\n\r\n\r\n\tunion(\r\n\t\tsecond:ForEachEnumerable<T>,\r\n\t\tcompareSelector:Selector<T, string | number | symbol> = Functions.Identity):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T, any>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tkeys = new Dictionary<T, any>(compareSelector); // Acting as a HashSet.\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet current:T;\r\n\t\t\t\t\t\tif(secondEnumerator===VOID0)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tcurrent = <T>firstEnumerator.current;\r\n\t\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tsecondEnumerator = enumUtil.from(second);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\twhile(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcurrent = <T>secondEnumerator.current;\r\n\t\t\t\t\t\t\tif(!keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tkeys.addByKeyValue(current, null);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator) firstEnumerator.dispose();\r\n\t\t\t\t\t\tif(secondEnumerator) secondEnumerator.dispose();\r\n\t\t\t\t\t\tfirstEnumerator = NULL;\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tinsertAt(index:number, other:ForEachEnumerable<T>):this\r\n\t{\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\t\tconst n:number = index;\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\r\n\t\t\t\tlet firstEnumerator:IEnumerator<T>;\r\n\t\t\t\tlet secondEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\tlet count:number = 0;\r\n\t\t\t\tlet isEnumerated:boolean = false;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcount = 0;\r\n\t\t\t\t\t\tfirstEnumerator = _.getEnumerator();\r\n\t\t\t\t\t\tsecondEnumerator = enumUtil.from<T>(other);\r\n\t\t\t\t\t\tisEnumerated = false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(count==n)\r\n\t\t\t\t\t\t{ // Inserting?\r\n\t\t\t\t\t\t\tisEnumerated = true;\r\n\t\t\t\t\t\t\tif(secondEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif(firstEnumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcount++;\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(firstEnumerator.current);\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn !isEnumerated\r\n\t\t\t\t\t\t\t&& secondEnumerator.moveNext()\r\n\t\t\t\t\t\t\t&& yielder.yieldReturn(secondEnumerator.current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(firstEnumerator) firstEnumerator.dispose();\r\n\t\t\t\t\t\tfirstEnumerator = NULL;\r\n\t\t\t\t\t\tif(secondEnumerator) secondEnumerator.dispose();\r\n\t\t\t\t\t\tsecondEnumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\talternateMultiple(sequence:ForEachEnumerable<T>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T,\r\n\t\t\t\t    mode:EnumerableAction,\r\n\t\t\t\t    enumerator:IEnumerator<T>,\r\n\t\t\t\t    alternateEnumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Instead of recalling getEnumerator every time, just reset the existing one.\r\n\t\t\t\t\t\talternateEnumerator = new ArrayEnumerator(\r\n\t\t\t\t\t\t\tEnumerable.toArray<T>(sequence)\r\n\t\t\t\t\t\t); // Freeze\r\n\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tlet hasAtLeastOne = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = hasAtLeastOne\r\n\t\t\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(hasAtLeastOne)\r\n\t\t\t\t\t\t\tbuffer = <T>enumerator.current;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tswitch(mode)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tcase EnumerableAction.Break: // We're done?\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tcase EnumerableAction.Skip:\r\n\t\t\t\t\t\t\t\tif(alternateEnumerator.moveNext())\r\n\t\t\t\t\t\t\t\t\treturn yielder.yieldReturn(alternateEnumerator.current);\r\n\t\t\t\t\t\t\t\talternateEnumerator.reset();\r\n\t\t\t\t\t\t\t\tmode = EnumerableAction.Return;\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet latest = buffer;\r\n\r\n\t\t\t\t\t\t// Set up the next round...\r\n\r\n\t\t\t\t\t\t// Is there another one?  Set the buffer and setup instruct for the next one to be the alternate.\r\n\t\t\t\t\t\tlet another = enumerator.moveNext();\r\n\t\t\t\t\t\tmode = another\r\n\t\t\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t\t\t: EnumerableAction.Break;\r\n\r\n\t\t\t\t\t\tif(another)\r\n\t\t\t\t\t\t\tbuffer = <T>enumerator.current;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(latest);\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tif(alternateEnumerator) alternateEnumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\talternateEnumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\talternateSingle(value:T):this\r\n\t{\r\n\t\treturn this.alternateMultiple(Enumerable.make(value));\r\n\t}\r\n\r\n\talternate(...sequence:T[]):this\r\n\t{\r\n\t\treturn this.alternateMultiple(sequence);\r\n\t}\r\n\r\n\r\n\t// #region Error Handling\r\n\tcatchError(handler:(e:any) => void):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst disposed = !_.throwIfDisposed();\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Don't init...\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) try\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(enumerator.current);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tcatch(e)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\thandler(e);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tfinallyAction(action:Closure):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\treturn (enumerator.moveNext())\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(enumerator.current)\r\n\t\t\t\t\t\t\t: false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\ttry\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tfinally\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\taction();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tbuffer(size:number):InfiniteLinqEnumerable<T[]>\r\n\t{\r\n\t\tif(size<1 || !isFinite(size))\r\n\t\t\tthrow new Error(\"Invalid buffer size.\");\r\n\r\n\t\tInteger.assert(size, \"size\");\r\n\r\n\t\tconst _ = this;\r\n\t\tconst isEndless = _._isEndless;\r\n\t\tlet len:number;\r\n\r\n\t\treturn new LinqEnumerable<T[]>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\treturn new EnumeratorBase<T[]>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet array:T[] = initialize<T>(size);\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\twhile(len<size && enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tarray[len++] = <T>enumerator.current;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tarray.length = len;\r\n\t\t\t\t\t\treturn !!len && yielder.yieldReturn(array);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\tnull,\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tshare():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet sharedEnumerator:IEnumerator<T>;\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\treturn sharedEnumerator || (sharedEnumerator = _.getEnumerator());\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(sharedEnumerator) sharedEnumerator.dispose();\r\n\t\t\t\tsharedEnumerator = NULL;\r\n\t\t\t},\r\n\r\n\t\t\t_._isEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\n/**\r\n * Enumerable<T> is a wrapper class that allows more primitive enumerables to exhibit LINQ behavior.\r\n *\r\n * In C# Enumerable<T> is not an instance but has extensions for IEnumerable<T>.\r\n * In this case, we use Enumerable<T> as the underlying class that is being chained.\r\n */\r\nexport class LinqEnumerable<T>\r\n\textends InfiniteLinqEnumerable<T>\r\n\timplements ILinqEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure | null,\r\n\t\tisEndless?:boolean)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer);\r\n\t\tthis._isEndless = isEndless;\r\n\t\tthis._disposableObjectName = \"LinqEnumerable\";\r\n\t}\r\n\r\n\t// Return a default (unfiltered) enumerable.\r\n\tasEnumerable():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\treturn <any> new LinqEnumerable<T>(() => _.getEnumerator());\r\n\t}\r\n\r\n// #region Indexing/Paging methods.\r\n\r\n\tskip(count:number):LinqEnumerable<T>\r\n\t{\r\n\t\treturn <any>super.skip(count);\r\n\t}\r\n\r\n\tskipWhile(predicate:PredicateWithIndex<T>):LinqEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.doAction(\r\n\t\t\t(element:T, index:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Skip\r\n\t\t\t\t\t: EnumerableAction.Return\r\n\t\t);\r\n\t}\r\n\r\n\ttakeWhile(predicate:PredicateWithIndex<T>):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\treturn <any>this.doAction(\r\n\t\t\t(element:T, index:number) =>\r\n\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t? EnumerableAction.Return\r\n\t\t\t\t\t: EnumerableAction.Break,\r\n\t\t\tnull,\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\t// Is like the inverse of take While with the ability to return the value identified by the predicate.\r\n\ttakeUntil(predicate:PredicateWithIndex<T>, includeUntilValue?:boolean):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException('predicate');\r\n\r\n\t\tif(!includeUntilValue)\r\n\t\t\treturn <any>this.doAction(\r\n\t\t\t\t(element:T, index:number) =>\r\n\t\t\t\t\tpredicate(element, index)\r\n\t\t\t\t\t\t? EnumerableAction.Break\r\n\t\t\t\t\t\t: EnumerableAction.Return,\r\n\t\t\t\tnull,\r\n\t\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t\t);\r\n\r\n\t\tlet found:boolean = false;\r\n\t\treturn <any>this.doAction(\r\n\t\t\t(element:T, index:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(found)\r\n\t\t\t\t\treturn EnumerableAction.Break;\r\n\r\n\t\t\t\tfound = predicate(element, index);\r\n\t\t\t\treturn EnumerableAction.Return;\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tfound = false;\r\n\t\t\t},\r\n\t\t\tnull // We don't know the state if it is endless or not.\r\n\t\t);\r\n\t}\r\n\r\n\t// Since an infinite enumerable will always end up traversing breadth first, we have this only here for regular enumerable.\r\n\ttraverseBreadthFirst(\r\n\t\tchildrenSelector:(element:T) => ForEachEnumerable<T> | null | undefined):LinqEnumerable<T>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined):LinqEnumerable<TNode>;\r\n\r\n\ttraverseBreadthFirst<TResult>(\r\n\t\tchildrenSelector:(element:T) => ForEachEnumerable<T> | null | undefined,\r\n\t\tresultSelector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode, TResult>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined,\r\n\t\tresultSelector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>;\r\n\r\n\ttraverseBreadthFirst<TNode>(\r\n\t\tchildrenSelector:(element:T | TNode) => ForEachEnumerable<TNode> | null | undefined,\r\n\t\tresultSelector:(\r\n\t\t\telement:TNode,\r\n\t\t\tnestLevel:number) => any = Functions.Identity):LinqEnumerable<any>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\r\n\t\tconst isEndless = _._isEndless; // Is endless is not affirmative if false.\r\n\r\n\r\n\t\treturn new LinqEnumerable<any>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<any>;\r\n\t\t\t\tlet nestLevel:number = 0;\r\n\t\t\t\tlet buffer:any[], len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<any>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tnestLevel = 0;\r\n\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\r\n\t\t\t\t\t\twhile(true)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tbuffer[len++] = enumerator.current;\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(resultSelector(enumerator.current, nestLevel));\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\t\tlet next = Enumerable\r\n\t\t\t\t\t\t\t\t.from(buffer)\r\n\t\t\t\t\t\t\t\t.selectMany(childrenSelector);\r\n\r\n\t\t\t\t\t\t\tif(!next.any())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tnestLevel++;\r\n\t\t\t\t\t\t\t\tbuffer = [];\r\n\t\t\t\t\t\t\t\tlen = 0;\r\n\t\t\t\t\t\t\t\tenumerator.dispose();\r\n\t\t\t\t\t\t\t\tenumerator = next.getEnumerator();\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t},\r\n\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\r\n\tforEach(action:ActionWithIndex<T>, max?:number):number\r\n\tforEach(action:PredicateWithIndex<T>, max?:number):number\r\n\tforEach(action:ActionWithIndex<T> | PredicateWithIndex<T>, max:number = Infinity):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tif(!action)\r\n\t\t\tthrow new ArgumentNullException(\"action\");\r\n\t\tthrowIfEndless(_.isEndless);\r\n\r\n\t\t/*\r\n\t\t// It could be just as easy to do the following:\r\n\t\treturn enumUtil.forEach(_, action, max);\r\n\t\t// But to be more active about checking for disposal, we use this instead:\r\n\t\t*/\r\n\r\n\r\n\t\t// Return value of action can be anything, but if it is (===) false then the enumUtil.forEach will discontinue.\r\n\t\treturn max>0 ? using(\r\n\t\t\t_.getEnumerator(), e =>\r\n\t\t\t{\r\n\r\n\t\t\t\tthrowIfEndless(!isFinite(max) && e.isEndless);\r\n\r\n\t\t\t\tlet i = 0;\r\n\t\t\t\t// It is possible that subsequently 'action' could cause the enumeration to dispose, so we have to check each time.\r\n\t\t\t\twhile(max>i && _.throwIfDisposed() && e.moveNext())\r\n\t\t\t\t{\r\n\t\t\t\t\tif(action(<T>e.current, i++)===false)\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\treturn i;\r\n\t\t\t}\r\n\t\t) : 0;\r\n\t}\r\n\r\n\t// #region Conversion Methods\r\n\ttoArray(predicate?:PredicateWithIndex<T>):T[]\r\n\t{\r\n\t\treturn predicate\r\n\t\t\t? this.where(predicate).toArray()\r\n\t\t\t: this.copyTo([]);\r\n\t}\r\n\r\n\tcopyTo(target:T[], index:number = 0, count:number = Infinity):T[]\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(!target) throw new ArgumentNullException(\"target\");\r\n\t\tInteger.assertZeroOrGreater(index);\r\n\r\n\t\t// If not exposing an action that could cause dispose, then use enumUtil.forEach utility instead.\r\n\t\tenumUtil.forEach<T>(this, (x, i) =>\r\n\t\t{\r\n\t\t\ttarget[i + index] = x\r\n\t\t}, count);\r\n\r\n\t\treturn target;\r\n\t}\r\n\r\n\r\n\ttoLookup<TKey, TValue>(\r\n\t\tkeySelector:SelectorWithIndex<T, TKey>,\r\n\t\telementSelector:SelectorWithIndex<T, TValue>             = Functions.Identity,\r\n\t\tcompareSelector:Selector<TKey, string | number | symbol> = Functions.Identity):ILookup<TKey, TValue>\r\n\t{\r\n\t\tconst dict:Dictionary<TKey, TValue[]> = new Dictionary<TKey, TValue[]>(compareSelector);\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tlet key = keySelector(x, i);\r\n\t\t\t\tlet element = elementSelector(x, i);\r\n\r\n\t\t\t\tlet array = dict.getValue(key);\r\n\t\t\t\tif(array!==VOID0) array.push(element);\r\n\t\t\t\telse dict.addByKeyValue(key, [element]);\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn new Lookup<TKey, TValue>(dict);\r\n\t}\r\n\r\n\ttoMap<TResult>(\r\n\t\tkeySelector:SelectorWithIndex<T, string | number | symbol>,\r\n\t\telementSelector:SelectorWithIndex<T, TResult>):IMap<TResult>\r\n\t{\r\n\t\tconst obj:IMap<TResult> = {};\r\n\t\tthis.forEach((x, i) =>\r\n\t\t{\r\n\t\t\tobj[keySelector(x, i)] = elementSelector(x, i);\r\n\t\t});\r\n\t\treturn obj;\r\n\t}\r\n\r\n\r\n\ttoDictionary<TKey, TValue>(\r\n\t\tkeySelector:SelectorWithIndex<T, TKey>,\r\n\t\telementSelector:SelectorWithIndex<T, TValue>,\r\n\t\tcompareSelector:Selector<TKey, string | number | symbol> = Functions.Identity):IDictionary<TKey, TValue>\r\n\t{\r\n\t\tconst dict:Dictionary<TKey, TValue> = new Dictionary<TKey, TValue>(compareSelector);\r\n\t\tthis.forEach((x, i) => dict.addByKeyValue(keySelector(x, i), elementSelector(x, i)));\r\n\t\treturn dict;\r\n\t}\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\treturn this\r\n\t\t\t.select(selector)\r\n\t\t\t.toArray()\r\n\t\t\t.join(separator);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\r\n\ttakeExceptLast(count:number = 1):this\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!(count>0)) // Out of bounds?\r\n\t\t\treturn _;\r\n\r\n\t\tif(!isFinite(count)) // +Infinity equals skip all so return empty.\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\t\tconst c = count;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet q:Queue<T>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tq = new Queue<T>();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t// Add the next one to the queue.\r\n\t\t\t\t\t\t\tq.enqueue(<T>enumerator.current);\r\n\r\n\t\t\t\t\t\t\t// Did we reach our quota?\r\n\t\t\t\t\t\t\tif(q.count>c)\r\n\t\t\t\t\t\t\t// Okay then, start returning results.\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(q.dequeue());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tif(q) q.dispose();\r\n\t\t\t\t\t\tq = NULL;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tskipToLast(count:number):this\r\n\t{\r\n\t\tif(!(count>0)) // Out of bounds? Empty.\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!isFinite(count)) // Infinity means return all.\r\n\t\t\treturn _;\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\t// This sets up the query so nothing is done until move next is called.\r\n\t\treturn <any> _.reverse()\r\n\t\t\t.take(count)\r\n\t\t\t.reverse();\r\n\t}\r\n\r\n\t// To help with type guarding.\r\n\r\n\tselect<TResult>(selector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>\r\n\t{\r\n\t\treturn <LinqEnumerable<TResult>>super.select(selector);\r\n\t}\r\n\r\n\tmap<TResult>(selector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>\r\n\t{\r\n\t\treturn <LinqEnumerable<TResult>>super.select(selector);\r\n\t}\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<TResult> | null | undefined>):LinqEnumerable<TResult>;\r\n\r\n\tselectMany<TElement, TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<TElement> | null | undefined>,\r\n\t\tresultSelector:(collection:T, element:TElement) => TResult):LinqEnumerable<TResult>;\r\n\r\n\tselectMany<TResult>(\r\n\t\tcollectionSelector:SelectorWithIndex<T, ForEachEnumerable<any> | null | undefined>,\r\n\t\tresultSelector?:(collection:T, element:any) => TResult):LinqEnumerable<TResult>\r\n\t{\r\n\t\treturn this._selectMany(collectionSelector, resultSelector);\r\n\t}\r\n\r\n\tchoose():LinqEnumerable<T>;\r\n\tchoose<TResult>(selector:SelectorWithIndex<T, TResult>):LinqEnumerable<TResult>\r\n\tchoose(selector:SelectorWithIndex<T, any> = Functions.Identity):LinqEnumerable<any>\r\n\t{\r\n\t\treturn this._filterSelected(selector, isNotNullOrUndefined);\r\n\t}\r\n\r\n\treverse():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot reverse an endless collection...\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T[];\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tindex = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) => !!index && yielder.yieldReturn(buffer[--index]),\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tshuffle():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\t\tthrowIfEndless(_._isEndless); // Cannot shuffle an endless collection...\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet buffer:T[];\r\n\t\t\t\tlet capacity:number;\r\n\t\t\t\tlet len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tbuffer = _.toArray();\r\n\t\t\t\t\t\tcapacity = len = buffer.length;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Avoid using major array operations like .slice();\r\n\t\t\t\t\t\tif(!len)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tlet selectedIndex = Random.integer(len);\r\n\t\t\t\t\t\tlet selectedValue = buffer[selectedIndex];\r\n\r\n\t\t\t\t\t\tbuffer[selectedIndex] = buffer[--len]; // Take the last one and put it here.\r\n\t\t\t\t\t\tbuffer[len] = NULL; // clear possible reference.\r\n\r\n\t\t\t\t\t\tif(len%32==0) // Shrink?\r\n\t\t\t\t\t\t\tbuffer.length = len;\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(selectedValue);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tcount(predicate?:PredicateWithIndex<T>):number\r\n\t{\r\n\t\tlet count:number = 0;\r\n\t\tthis.forEach(\r\n\t\t\tpredicate\r\n\r\n\t\t\t\t? (x, i) =>\r\n\t\t\t{\r\n\t\t\t\tif(predicate(x, i)) ++count;\r\n\t\t\t}\r\n\r\n\t\t\t\t: () =>\r\n\t\t\t{\r\n\t\t\t\t++count;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn count;\r\n\t}\r\n\r\n\t// Akin to '.every' on an array.\r\n\tall(predicate:PredicateWithIndex<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\tthrow new ArgumentNullException(\"predicate\");\r\n\r\n\t\tlet result = true;\r\n\t\tthis.forEach((x, i) =>\r\n\t\t{\r\n\t\t\tif(!predicate(x, i))\r\n\t\t\t{\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn false; // break\r\n\t\t\t}\r\n\t\t});\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// 'every' has been added here for parity/compatibility with an array.\r\n\tevery(predicate:PredicateWithIndex<T>):boolean\r\n\t{\r\n\t\treturn this.all(predicate);\r\n\t}\r\n\r\n\t// Akin to '.some' on an array.\r\n\tany(predicate?:PredicateWithIndex<T>):boolean\r\n\t{\r\n\t\tif(!predicate)\r\n\t\t\treturn super.any();\r\n\r\n\t\tlet result = false;\r\n\t\t// Splitting the forEach up this way reduces iterative processing.\r\n\t\t// forEach handles the generation and disposal of the enumerator.\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tresult = predicate(x, i); // false = not found and therefore it should continue.  true = found and break;\r\n\t\t\t\treturn !result;\r\n\t\t\t});\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n\t// 'some' has been added here for parity/compatibility with an array.\r\n\tsome(predicate?:PredicateWithIndex<T>):boolean\r\n\t{\r\n\t\treturn this.any(predicate);\r\n\t}\r\n\r\n\r\n\tcontains(value:T, compareSelector?:Selector<T, any>):boolean\r\n\t{\r\n\t\tif(compareSelector)\r\n\t\t{\r\n\t\t\tconst s = compareSelector(value);\r\n\t\t\treturn this.any(v => areEqualValues(compareSelector(v), s));\r\n\t\t}\r\n\t\treturn this.any(v => areEqualValues(v, value));\r\n\t}\r\n\r\n\t// Originally has an overload for a predicate,\r\n\t// but that's a bad idea since this could be an enumeration of functions and therefore fail the intent.\r\n\t// Better to chain a where statement first to be more explicit.\r\n\tindexOf(value:T, compareSelector?:SelectorWithIndex<T, any>):number\r\n\t{\r\n\t\tlet found:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t? (element:T, i:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(areEqualValues(compareSelector(element, i), compareSelector(value, i), true))\r\n\t\t\t\t{\r\n\t\t\t\t\tfound = i;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\t: (element:T, i:number) =>\r\n\t\t\t{\r\n\t\t\t\t// Why?  Because NaN doesn't equal NaN. :P\r\n\t\t\t\tif(areEqualValues(element, value, true))\r\n\t\t\t\t{\r\n\t\t\t\t\tfound = i;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t});\r\n\r\n\r\n\t\treturn found;\r\n\t}\r\n\r\n\tlastIndexOf(value:T, compareSelector?:SelectorWithIndex<T, any>):number\r\n\t{\r\n\t\tlet result:number = -1;\r\n\t\tthis.forEach(\r\n\t\t\tcompareSelector\r\n\t\t\t\t? (element:T, i:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(areEqualValues(compareSelector(element, i), compareSelector(value, i), true)) result\r\n\t\t\t\t\t= i;\r\n\t\t\t}\r\n\r\n\t\t\t\t: (element:T, i:number) =>\r\n\t\t\t{\r\n\t\t\t\tif(areEqualValues(element, value, true)) result = i;\r\n\t\t\t});\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\r\n\tintersect(\r\n\t\tsecond:ForEachEnumerable<T>,\r\n\t\tcompareSelector?:Selector<T, string | number | symbol>):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!second)\r\n\t\t\tthrow new ArgumentNullException(\"second\");\r\n\r\n\t\tconst isEndless = _.isEndless;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet keys:Dictionary<T, boolean>;\r\n\t\t\t\tlet outs:Dictionary<T, boolean>;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!second);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\r\n\t\t\t\t\t\tkeys = new Dictionary<T, boolean>(compareSelector);\r\n\t\t\t\t\t\touts = new Dictionary<T, boolean>(compareSelector);\r\n\r\n\t\t\t\t\t\tenumUtil.forEach(second, key =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tkeys.addByKeyValue(key, true);\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\twhile(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet current = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(!outs.containsKey(current) && keys.containsKey(current))\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\touts.addByKeyValue(current, true);\r\n\t\t\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tif(keys) enumerator.dispose();\r\n\t\t\t\t\t\tif(outs) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tkeys = NULL;\r\n\t\t\t\t\t\touts = NULL;\r\n\t\t\t\t\t},\r\n\t\t\t\t\tisEndless\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tsecond = NULL;\r\n\t\t\t},\r\n\t\t\tisEndless\r\n\t\t);\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:ForEachEnumerable<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqualValues):boolean\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn using(\r\n\t\t\tthis.getEnumerator(),\r\n\t\t\te1 => using(\r\n\t\t\t\tenumUtil.from(second),\r\n\t\t\t\te2 =>\r\n\t\t\t\t{\r\n\t\t\t\t\t// if both are endless, this will never evaluate.\r\n\t\t\t\t\tthrowIfEndless(e1.isEndless && e2.isEndless);\r\n\r\n\t\t\t\t\twhile(e1.moveNext())\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(!e2.moveNext() || !equalityComparer(<T>e1.current, <T>e2.current))\r\n\t\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn !e2.moveNext();\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n\r\n\t//isEquivalent(second:ForEachEnumerable<T>,\r\n\t//\tequalityComparer:EqualityComparison<T> = valuesAreEqual):boolean\r\n\t//{\r\n\t//\treturn this\r\n\t//\t\t.orderBy(keySelector)\r\n\t//\t\t.sequenceEqual(Enumerable.from(second).orderBy(keySelector))\r\n\t//}\r\n\r\n\r\n\t// #endregion\r\n\r\n\r\n\tofType<TType>(type:{ new (...params:any[]):TType }):LinqEnumerable<TType>;\r\n\tofType<TType>(type:any):LinqEnumerable<TType>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn <LinqEnumerable<TType>>super.ofType(type);\r\n\t}\r\n\r\n// #region Ordering Methods\r\n\r\n\torderBy<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new OrderedEnumerable<T, TKey>(this, keySelector, Order.Ascending);\r\n\t}\r\n\r\n\torderUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new OrderedEnumerable<T, any>(this, null, Order.Ascending, null, comparison);\r\n\t}\r\n\r\n\torderUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new OrderedEnumerable<T, any>(this, null, Order.Descending, null, comparison);\r\n\t}\r\n\r\n\torderByDescending<TKey extends Comparable>(keySelector:Selector<T, TKey> = Functions.Identity):IOrderedEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new OrderedEnumerable<T, TKey>(this, keySelector, Order.Descending);\r\n\t}\r\n\r\n\t/*\r\n\t\t weightedSample(weightSelector) {\r\n\t\t weightSelector = Utils.createLambda(weightSelector);\r\n\t\t var source = this;\r\n\r\n\t\t return new LinqEnumerable<T>(() => {\r\n\t\t var sortedByBound;\r\n\t\t var totalWeight = 0;\r\n\r\n\t\t return new EnumeratorBase<T>(\r\n\t\t () => {\r\n\t\t sortedByBound = source\r\n\t\t .choose(function (x) {\r\n\t\t var weight = weightSelector(x);\r\n\t\t if (weight <= 0) return null; // ignore 0\r\n\r\n\t\t totalWeight += weight;\r\n\t\t return { value: x, bound: totalWeight }\r\n\t\t })\r\n\t\t .toArray();\r\n\t\t },\r\n\t\t () => {\r\n\t\t if (sortedByBound.length > 0) {\r\n\t\t var draw = (Math.random() * totalWeight) + 1;\r\n\r\n\t\t var lower = -1;\r\n\t\t var upper = sortedByBound.length;\r\n\t\t while (upper - lower > 1) {\r\n\t\t var index = ((lower + upper) / 2);\r\n\t\t if (sortedByBound[index].bound >= draw) {\r\n\t\t upper = index;\r\n\t\t }\r\n\t\t else {\r\n\t\t lower = index;\r\n\t\t }\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldReturn(sortedByBound[upper].value);\r\n\t\t }\r\n\r\n\t\t return (<any>this).yieldBreak();\r\n\t\t },\r\n\t\t Functions.Blank);\r\n\t\t });\r\n\t\t }\r\n\t\t */\r\n\t// #endregion\r\n\r\n\tbuffer(size:number):LinqEnumerable<T[]>\r\n\t{\r\n\t\treturn <LinqEnumerable<T[]>>super.buffer(size);\r\n\t}\r\n\r\n\t// #region Grouping Methods\r\n\r\n\t// Originally contained a result selector (not common use), but this could be done simply by a select statement after.\r\n\r\n\tgroupBy<TKey>(keySelector:SelectorWithIndex<T, TKey>):LinqEnumerable<IGrouping<TKey, T>>;\r\n\r\n\tgroupBy<TKey>(\r\n\t\tkeySelector:SelectorWithIndex<T, TKey>,\r\n\t\telementSelector:SelectorWithIndex<T, T>,\r\n\t\tcompareSelector?:Selector<TKey, string | number | symbol>):LinqEnumerable<IGrouping<TKey, T>>;\r\n\r\n\tgroupBy<TKey, TElement>(\r\n\t\tkeySelector:SelectorWithIndex<T, TKey>,\r\n\t\telementSelector:SelectorWithIndex<T, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, string | number | symbol>):LinqEnumerable<IGrouping<TKey, TElement>>\r\n\r\n\r\n\tgroupBy<TKey, TElement>(\r\n\t\tkeySelector:SelectorWithIndex<T, TKey> | Selector<T, TKey>,\r\n\t\telementSelector?:SelectorWithIndex<T, TElement> | Selector<T, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, string | number | symbol>):LinqEnumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new LinqEnumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() => this\r\n\t\t\t\t.toLookup(keySelector, elementSelector, compareSelector)\r\n\t\t\t\t.getEnumerator()\r\n\t\t);\r\n\t}\r\n\r\n\tpartitionBy<TKey>(keySelector:Selector<T, TKey>):LinqEnumerable<IGrouping<TKey, T>>;\r\n\tpartitionBy<TKey, TElement>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tresultSelector?:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>,\r\n\t\tcompareSelector?:Selector<TKey, any>):LinqEnumerable<IGrouping<TKey, TElement>>;\r\n\tpartitionBy<TKey, TElement>(\r\n\t\tkeySelector:Selector<T, TKey>,\r\n\t\telementSelector?:Selector<T, TElement>,\r\n\t\tresultSelector:(key:TKey, element:TElement[]) => IGrouping<TKey, TElement>\r\n\t\t\t= (key:TKey, elements:TElement[]) => new Grouping<TKey, TElement>(key, elements),\r\n\t\tcompareSelector:Selector<TKey, any>\r\n\t\t\t= Functions.Identity):LinqEnumerable<IGrouping<TKey, T>> | LinqEnumerable<IGrouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tif(!elementSelector) elementSelector = Functions.Identity; // Allow for 'null' and not just undefined.\r\n\t\treturn new LinqEnumerable<IGrouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet enumerator:IEnumerator<T>;\r\n\t\t\t\tlet key:TKey;\r\n\t\t\t\tlet compareKey:any;\r\n\t\t\t\tlet group:TElement[] | null;\r\n\t\t\t\tlet len:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<IGrouping<TKey, TElement>>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!elementSelector);\r\n\t\t\t\t\t\tenumerator = _.getEnumerator();\r\n\t\t\t\t\t\tif(enumerator.moveNext())\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet v = <T>enumerator.current;\r\n\t\t\t\t\t\t\tkey = keySelector(v);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector!(v)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!elementSelector);\r\n\r\n\t\t\t\t\t\tif(!group)\r\n\t\t\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\t\t\tlet hasNext:boolean, c:T;\r\n\t\t\t\t\t\twhile((hasNext = enumerator.moveNext()))\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = <T>enumerator.current;\r\n\t\t\t\t\t\t\tif(areEqualValues(compareKey, compareSelector(keySelector(c))))\r\n\t\t\t\t\t\t\t\tgroup[len++] = elementSelector!(c);\r\n\t\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tlet result:IGrouping<TKey, TElement>\r\n\t\t\t\t\t\t\t    = resultSelector(key, group);\r\n\r\n\t\t\t\t\t\tif(hasNext)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tc = <T>enumerator.current;\r\n\t\t\t\t\t\t\tkey = keySelector(c);\r\n\t\t\t\t\t\t\tcompareKey = compareSelector(key);\r\n\t\t\t\t\t\t\tgroup = [elementSelector!(c)];\r\n\t\t\t\t\t\t\tlen = 1;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\treturn yielder.yieldReturn(result);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\t\t\tenumerator = NULL;\r\n\t\t\t\t\t\tgroup = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\telementSelector = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Aggregate Methods\r\n\r\n\tflatten<TFlat>():LinqEnumerable<TFlat>\r\n\tflatten():LinqEnumerable<any>\r\n\tflatten():LinqEnumerable<any>\r\n\t{\r\n\t\treturn <any>super.flatten();\r\n\t}\r\n\r\n\tpairwise<TSelect>(\r\n\t\tselector:(\r\n\t\t\tprevious:T, current:T,\r\n\t\t\tindex:number) => TSelect):LinqEnumerable<TSelect>\r\n\t{\r\n\t\treturn <any>super.pairwise(selector);\r\n\t}\r\n\r\n\taggregate(\r\n\t\treduction:(previous:T, current:T, index?:number) => T):T | undefined;\r\n\r\n\taggregate<U>(\r\n\t\treduction:(previous:U, current:T, index?:number) => U,\r\n\t\tinitialValue:U):U;\r\n\r\n\taggregate<U>(\r\n\t\treduction:(previous:U, current:T, index?:number) => U,\r\n\t\tinitialValue?:U):U | undefined\r\n\t{\r\n\t\tif(initialValue==VOID0)\r\n\t\t{\r\n\t\t\tthis.forEach((value, i) =>\r\n\t\t\t{\r\n\t\t\t\tinitialValue = i\r\n\t\t\t\t\t? reduction(initialValue!, value, i)\r\n\t\t\t\t\t: <any>value\r\n\t\t\t});\r\n\t\t} else {\r\n\r\n\t\t\tthis.forEach((value, i) =>\r\n\t\t\t{\r\n\t\t\t\tinitialValue = reduction(initialValue!, value, i)\r\n\t\t\t});\r\n\r\n\t\t}\r\n\t\treturn initialValue;\r\n\t}\r\n\r\n\treduce<T>(\r\n\t\treduction:(previous:T, current:T, index?:number) => T):T | undefined;\r\n\r\n\treduce<U>(\r\n\t\treduction:(previous:U, current:T, index?:number) => U,\r\n\t\tinitialValue:U):U;\r\n\r\n\t/**\r\n\t * Provided as an analog for array.reduce.  Simply a shortcut for aggregate.\r\n\t * @param reduction\r\n\t * @param initialValue\r\n\t */\r\n\treduce<U>(\r\n\t\treduction:(previous:U, current:T, index?:number) => U,\r\n\t\tinitialValue?:U):U | undefined\r\n\t{\r\n\t\treturn this.aggregate(reduction, initialValue);\r\n\t}\r\n\r\n\taverage(selector:SelectorWithIndex<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tlet count = 0;\r\n\t\tconst sum = this.sum((e, i) =>\r\n\t\t{\r\n\t\t\tcount++;\r\n\t\t\treturn selector(e, i);\r\n\t\t});\r\n\r\n\t\treturn (isNaN(sum) || !count)\r\n\t\t\t? NaN\r\n\t\t\t: (sum/count);\r\n\t}\r\n\r\n\t// If using numbers, it may be useful to call .takeUntil(v=>v==Infinity,true) before calling max. See static versions for numbers.\r\n\tmax():T | undefined\r\n\t{\r\n\t\treturn this.aggregate(Functions.Greater);\r\n\t}\r\n\r\n\tmin():T | undefined\r\n\t{\r\n\t\treturn this.aggregate(Functions.Lesser);\r\n\t}\r\n\r\n\tmaxBy(keySelector:Selector<T, Primitive> = Functions.Identity):T | undefined\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)>keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\tminBy(keySelector:Selector<T, Primitive> = Functions.Identity):T | undefined\r\n\t{\r\n\t\treturn this.aggregate((a:T, b:T) => (keySelector(a)<keySelector(b)) ? a : b);\r\n\t}\r\n\r\n\t// Addition...  Only works with numerical enumerations.\r\n\tsum(selector:SelectorWithIndex<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tlet sum = 0;\r\n\r\n\t\t// This allows for infinity math that doesn't destroy the other values.\r\n\t\tlet sumInfinite = 0; // Needs more investigation since we are really trying to retain signs.\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tlet value = selector(x, i);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tsum = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\t\t\t\tif(isFinite(value))\r\n\t\t\t\t\tsum += value;\r\n\t\t\t\telse\r\n\t\t\t\t\tsumInfinite +=\r\n\t\t\t\t\t\tvalue>0 ? (+1) : (-1);\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn isNaN(sum) ? NaN : (sumInfinite ? (sumInfinite*Infinity) : sum);\r\n\t}\r\n\r\n\t// Multiplication...\r\n\tproduct(selector:SelectorWithIndex<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tlet result = 1, exists:boolean = false;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\texists = true;\r\n\t\t\t\tlet value = selector(x, i);\r\n\t\t\t\tif(isNaN(value))\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(value==0)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = 0; // Multiplying by zero will always end in zero.\r\n\t\t\t\t\treturn false;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// Multiplication can never recover from infinity and simply must retain signs.\r\n\t\t\t\t// You could cancel out infinity with 1/infinity but no available representation exists.\r\n\t\t\t\tresult *= value;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\treturn (exists && isNaN(result)) ? NaN : result;\r\n\t}\r\n\r\n\t/**\r\n\t * Takes the first number and divides it by all following.\r\n\t * @param selector\r\n\t * @returns {number}\r\n\t */\r\n\tquotient(selector:SelectorWithIndex<T, number> = Type.numberOrNaN):number\r\n\t{\r\n\t\tlet count = 0;\r\n\t\tlet result:number = NaN;\r\n\r\n\t\tthis.forEach(\r\n\t\t\t(x, i) =>\r\n\t\t\t{\r\n\t\t\t\tlet value = selector(x, i);\r\n\t\t\t\tcount++;\r\n\r\n\t\t\t\tif(count===1)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult = value;\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tif(isNaN(value) || value===0 || !isFinite(value))\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tresult = NaN;\r\n\t\t\t\t\t\treturn false;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tresult /= value;\r\n\t\t\t\t}\r\n\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(count===1)\r\n\t\t\tresult = NaN;\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t// #region Single Value Return...\r\n\r\n\tlast():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet value:T | undefined = VOID0;\r\n\t\tlet found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx =>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\r\n\t\tif(!found) throw new Error(\"last:No element satisfies the condition.\");\r\n\t\treturn <any>value;\r\n\t}\r\n\r\n\tlastOrDefault():T | undefined\r\n\tlastOrDefault(defaultValue:T):T\r\n\tlastOrDefault(defaultValue?:T):T | undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet value:T | undefined = VOID0;\r\n\t\tlet found:boolean = false;\r\n\t\t_.forEach(\r\n\t\t\tx =>\r\n\t\t\t{\r\n\t\t\t\tfound = true;\r\n\t\t\t\tvalue = x;\r\n\t\t\t}\r\n\t\t);\r\n\t\treturn (!found) ? defaultValue : value;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\tmemoize():this\r\n\t{\r\n\t\tlet source = new LazyList(this);\r\n\t\treturn <this>(new LinqEnumerable(() => source.getEnumerator(), () =>\r\n\t\t{\r\n\t\t\tsource.dispose();\r\n\t\t\tsource = <any>null\r\n\t\t}, this.isEndless));\r\n\t}\r\n\r\n\tthrowWhenEmpty():NotEmptyEnumerable<T>\r\n\t{\r\n\t\treturn <any>this.doAction(RETURN, null, this.isEndless, count =>\r\n\t\t{\r\n\t\t\tif(!count) throw \"Collection is empty.\";\r\n\t\t});\r\n\t}\r\n}\r\n\r\n// Provided for type guarding.\r\nexport class FiniteEnumerable<T>\r\n\textends LinqEnumerable<T>\r\n\timplements IFiniteEnumerable<T>\r\n{\r\n\tconstructor(\r\n\t\tenumeratorFactory:() => IEnumerator<T>,\r\n\t\tfinalizer?:Closure)\r\n\t{\r\n\t\tsuper(enumeratorFactory, finalizer, false);\r\n\t\tthis._disposableObjectName = \"FiniteEnumerable\";\r\n\t}\r\n\r\n}\r\n\r\nclass ArrayEnumerable<T>\r\n\textends FiniteEnumerable<T>\r\n{\r\n\tprivate _source:ArrayLike<T>;\r\n\r\n\tconstructor(source:ArrayLike<T>)\r\n\t{\r\n\t\tsuper(() =>\r\n\t\t{\r\n\t\t\t_.throwIfDisposed();\r\n\t\t\treturn new ArrayEnumerator<T>(() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed(\"The underlying ArrayEnumerable was disposed.\", \"ArrayEnumerator\");\r\n\r\n\t\t\t\treturn _._source; // Should never be null, but ArrayEnumerable if not disposed simply treats null as empty array.\r\n\t\t\t});\r\n\t\t});\r\n\r\n\t\tconst _ = this;\r\n\t\t_._disposableObjectName = \"ArrayEnumerable\";\r\n\t\t_._source = source;\r\n\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._source = NULL;\r\n\t}\r\n\r\n\tget source():ArrayLike<T>\r\n\t{\r\n\t\treturn this._source;\r\n\t}\r\n\r\n\ttoArray():T[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn enumUtil.toArray(_._source);\r\n\t}\r\n\r\n\tasEnumerable():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn <any> new ArrayEnumerable<T>(this._source);\r\n\t}\r\n\r\n\t// Optimize forEach so that subsequent usage is optimized.\r\n\tforEach(action:ActionWithIndex<T>, max?:number):number\r\n\tforEach(action:PredicateWithIndex<T>, max?:number):number\r\n\tforEach(action:ActionWithIndex<T> | PredicateWithIndex<T>, max:number = Infinity):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn enumUtil.forEach(_._source, action, max);\r\n\t}\r\n\r\n\t// These methods should ALWAYS check for array length before attempting anything.\r\n\r\n\tany(predicate?:Predicate<T>):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tconst source = _._source;\r\n\t\tlet len = source.length;\r\n\t\treturn !!len && (!predicate || super.any(predicate));\r\n\t}\r\n\r\n\tcount(predicate?:Predicate<T>):number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tconst source = _._source, len = source.length;\r\n\t\treturn len && (predicate ? super.count(predicate) : len);\r\n\t}\r\n\r\n\telementAtOrDefault(index:number):T | undefined\r\n\telementAtOrDefault(index:number, defaultValue:T):T\r\n\telementAtOrDefault(index:number, defaultValue?:T):T | undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\t\tInteger.assertZeroOrGreater(index, 'index');\r\n\r\n\t\tconst source = _._source;\r\n\t\treturn index<source.length\r\n\t\t\t? source[index]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tlast():T\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tconst source = _._source, len = source.length;\r\n\t\treturn (len)\r\n\t\t\t? source[len - 1]\r\n\t\t\t: super.last();\r\n\t}\r\n\r\n\tlastOrDefault():T | undefined\r\n\tlastOrDefault(defaultValue:T):T\r\n\tlastOrDefault(defaultValue?:T):T | undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tconst source = _._source, len = source.length;\r\n\t\treturn len\r\n\t\t\t? source[len - 1]\r\n\t\t\t: defaultValue;\r\n\t}\r\n\r\n\tskip(count:number):this\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn _;\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() => new ArrayEnumerator<T>(() => _._source, count)\r\n\t\t);\r\n\t}\r\n\r\n\ttakeExceptLast(count:number = 1):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\treturn <any> _.take(_._source.length - count);\r\n\t}\r\n\r\n\tskipToLast(count:number):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn <any> Enumerable.empty<T>();\r\n\r\n\t\tif(!isFinite(count))\r\n\t\t\treturn _;\r\n\r\n\t\tconst len = _._source\r\n\t\t\t? _._source.length\r\n\t\t\t: 0;\r\n\r\n\t\treturn <any> _.skip(len - count);\r\n\t}\r\n\r\n\treverse():this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tlet disposed = !_.throwIfDisposed();\r\n\r\n\t\treturn <any> new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\treturn new IndexEnumerator<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet s = _._source;\r\n\t\t\t\t\t\tthrowIfDisposed(disposed || !s);\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tsource: s,\r\n\t\t\t\t\t\t\tpointer: (s.length - 1),\r\n\t\t\t\t\t\t\tlength: s.length,\r\n\t\t\t\t\t\t\tstep: -1\r\n\t\t\t\t\t\t};\r\n\t\t\t\t\t}\r\n\t\t\t\t)\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\tmemoize():this\r\n\t{\r\n\t\treturn this.asEnumerable();\r\n\t}\r\n\r\n\tsequenceEqual(\r\n\t\tsecond:ForEachEnumerable<T>,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqualValues):boolean\r\n\t{\r\n\t\tif(Type.isArrayLike(second))\r\n\t\t\treturn Arrays.areEqual(this.source, second, true, equalityComparer);\r\n\r\n\t\tif(second instanceof ArrayEnumerable)\r\n\t\t\treturn second.sequenceEqual(this.source, equalityComparer);\r\n\r\n\t\treturn super.sequenceEqual(second, equalityComparer);\r\n\t}\r\n\r\n\r\n\ttoJoinedString(separator:string = \"\", selector:Selector<T, string> = Functions.Identity)\r\n\t{\r\n\t\tconst s = this._source;\r\n\t\treturn !selector && (s) instanceof (Array)\r\n\t\t\t? (<Array<T>>s).join(separator)\r\n\t\t\t: super.toJoinedString(separator, selector);\r\n\t}\r\n\r\n}\r\n\r\n\r\nclass Grouping<TKey, TElement>\r\n\textends ArrayEnumerable<TElement>\r\n\timplements IGrouping<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _groupKey:TKey, elements:TElement[])\r\n\t{\r\n\t\tsuper(elements);\r\n\t\tthis._disposableObjectName = \"Grouping\";\r\n\t}\r\n\r\n\tget key():TKey\r\n\t{\r\n\t\treturn this._groupKey;\r\n\t}\r\n}\r\n\r\nclass Lookup<TKey, TElement>\r\n\timplements ILookup<TKey, TElement>\r\n{\r\n\r\n\tconstructor(private _dictionary:IDictionary<TKey, TElement[]>)\r\n\t{\r\n\t}\r\n\r\n\tget count():number\r\n\t{\r\n\t\treturn this._dictionary.count;\r\n\t}\r\n\r\n\tget(key:TKey):TElement[] | null\r\n\t{\r\n\t\treturn this._dictionary.getValue(key) || null;\r\n\t}\r\n\r\n\tcontains(key:TKey):boolean\r\n\t{\r\n\t\treturn this._dictionary.containsKey(key);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<Grouping<TKey, TElement>>\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\tlet enumerator:IEnumerator<IKeyValuePair<TKey, TElement[]>>;\r\n\r\n\t\treturn new EnumeratorBase<Grouping<TKey, TElement>>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tenumerator = _._dictionary.getEnumerator();\r\n\t\t\t},\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\r\n\t\t\t\tif(!enumerator.moveNext())\r\n\t\t\t\t\treturn false;\r\n\r\n\t\t\t\tlet current = <IKeyValuePair<TKey, TElement[]>>enumerator.current;\r\n\t\t\t\treturn yielder.yieldReturn(new Grouping<TKey, TElement>(current.key, current.value));\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(enumerator) enumerator.dispose();\r\n\t\t\t\tenumerator = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\n\r\nclass OrderedEnumerable<T, TOrderBy extends Comparable>\r\n\textends FiniteEnumerable<T>\r\n\timplements IOrderedEnumerable<T>\r\n{\r\n\r\n\tconstructor(\r\n\t\tprivate source:IEnumerable<T>,\r\n\t\tpublic keySelector:Selector<T, TOrderBy> | null,\r\n\t\tpublic order:Order,\r\n\t\tpublic parent?:OrderedEnumerable<T, any> | null,\r\n\t\tpublic comparer:Comparison<T> = compareValues)\r\n\t{\r\n\t\tsuper(NULL);\r\n\t\tthrowIfEndless(source && source.isEndless);\r\n\t\tthis._disposableObjectName = \"OrderedEnumerable\";\r\n\t}\r\n\r\n\tprivate createOrderedEnumerable(\r\n\t\tkeySelector:Selector<T, TOrderBy>,\r\n\t\torder:Order):IOrderedEnumerable<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new OrderedEnumerable<T, TOrderBy>(this.source, keySelector, order, this);\r\n\t}\r\n\r\n\tthenBy(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Ascending);\r\n\t}\r\n\r\n\tthenUsing(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T, any>(this.source, null, Order.Ascending, this, comparison);\r\n\t}\r\n\r\n\tthenByDescending(keySelector:(value:T) => TOrderBy):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn this.createOrderedEnumerable(keySelector, Order.Descending);\r\n\t}\r\n\r\n\tthenUsingReversed(comparison:Comparison<T>):IOrderedEnumerable<T>\r\n\t{\r\n\t\treturn new OrderedEnumerable<T, any>(this.source, null, Order.Descending, this, comparison);\r\n\t}\r\n\r\n\tgetEnumerator():EnumeratorBase<T>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet buffer:T[];\r\n\t\tlet indexes:number[];\r\n\t\tlet index:number = 0;\r\n\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tbuffer = Enumerable.toArray(_.source);\r\n\t\t\t\tindexes = createSortContext(_)\r\n\t\t\t\t\t.generateSortedIndexes(buffer);\r\n\t\t\t},\r\n\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\treturn (index<indexes.length)\r\n\t\t\t\t\t? yielder.yieldReturn(buffer[indexes[index++]])\r\n\t\t\t\t\t: false;\r\n\t\t\t},\r\n\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tif(buffer)\r\n\t\t\t\t\tbuffer.length = 0;\r\n\t\t\t\tbuffer = NULL;\r\n\t\t\t\tif(indexes)\r\n\t\t\t\t\tindexes.length = 0;\r\n\t\t\t\tindexes = NULL;\r\n\t\t\t},\r\n\r\n\t\t\tfalse\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tconst _:this = this;\r\n\t\tsuper._onDispose();\r\n\t\t_.source = NULL;\r\n\t\t_.keySelector = NULL;\r\n\t\t_.order = NULL;\r\n\t\t_.parent = NULL;\r\n\t}\r\n\r\n}\r\n\r\n// A private static helper for the weave function.\r\nfunction nextEnumerator<T>(queue:Queue<IEnumerator<T>>, e:IEnumerator<T>):IEnumerator<T> | null\r\n{\r\n\tif(e)\r\n\t{\r\n\t\tif(e.moveNext())\r\n\t\t{\r\n\t\t\tqueue.enqueue(e);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(e) e.dispose();\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\treturn e;\r\n}\r\n\r\n/**\r\n * Recursively builds a SortContext chain.\r\n * @param orderedEnumerable\r\n * @param currentContext\r\n * @returns {any}\r\n */\r\nfunction createSortContext<T, TOrderBy extends Comparable>(\r\n\torderedEnumerable:OrderedEnumerable<T, TOrderBy>,\r\n\tcurrentContext:IComparer<T> | null = null):KeySortedContext<T, TOrderBy>\r\n{\r\n\r\n\tconst context = new KeySortedContext<T, TOrderBy>(\r\n\t\tcurrentContext,\r\n\t\torderedEnumerable.keySelector,\r\n\t\torderedEnumerable.order,\r\n\t\torderedEnumerable.comparer);\r\n\r\n\tif(orderedEnumerable.parent)\r\n\t\treturn createSortContext(orderedEnumerable.parent, context);\r\n\r\n\treturn context;\r\n}\r\n\r\n// #region Helper Functions...\r\n// This allows for the use of a boolean instead of calling this.throwIfDisposed()\r\n// since there is a strong chance of introducing a circular reference.\r\n\r\nfunction throwIfDisposed(disposed:true):true\r\n//noinspection JSUnusedLocalSymbols\r\nfunction throwIfDisposed(disposed:false):never\r\n//noinspection JSUnusedLocalSymbols\r\nfunction throwIfDisposed(disposed:boolean):true | never\r\n//noinspection JSUnusedLocalSymbols\r\nfunction throwIfDisposed(disposed:boolean):true | never\r\n{\r\n\tif(disposed) throw new ObjectDisposedException(\"Enumerable\");\r\n\treturn true;\r\n}\r\n// #endregion\r\n\r\nexport function Enumerable<T>(\r\n\tsource:InfiniteValueFactory<T>):InfiniteLinqEnumerable<T>\r\nexport function Enumerable<T>(\r\n\tsource:ForEachEnumerable<T>,\r\n\t...additional:Array<ForEachEnumerable<T>>):LinqEnumerable<T>\r\nexport function Enumerable<T>(\r\n\tsource:ForEachEnumerable<T> | InfiniteValueFactory<T>,\r\n\t...additional:Array<ForEachEnumerable<T>>):LinqEnumerable<T>\r\n{\r\n\treturn enumerableFrom(source, additional);\r\n}\r\n\r\nfunction enumerableFrom<T>(\r\n\tsource:ForEachEnumerable<T> | InfiniteValueFactory<T>,\r\n\tadditional?:Array<ForEachEnumerable<T>>):LinqEnumerable<T>\r\n{\r\n\tlet e = Enumerable.fromAny<T>(<any>source);\r\n\tif(!e) throw new UnsupportedEnumerableException();\r\n\r\n\treturn (additional && additional.length)\r\n\t\t? <any>e.merge(additional)\r\n\t\t: <any>e;\r\n}\r\n\r\nexport module Enumerable\r\n{\r\n\t/**\r\n\t * Universal method for converting a primitive enumerables into a LINQ enabled ones.\r\n\t *\r\n\t * Is not limited to TypeScript usages.\r\n\t */\r\n\texport function from<T>(source:InfiniteValueFactory<T>):InfiniteLinqEnumerable<T>\r\n\texport function from<T>(\r\n\t\tsource:ForEachEnumerable<T>,\r\n\t\t...additional:Array<ForEachEnumerable<T>>):LinqEnumerable<T>\r\n\texport function from<T>(\r\n\t\tsource:ForEachEnumerable<T> | InfiniteValueFactory<T>,\r\n\t\t...additional:Array<ForEachEnumerable<T>>):LinqEnumerable<T>\r\n\t{\r\n\t\treturn enumerableFrom(source, additional);\r\n\t}\r\n\r\n\texport function fromAny<T>(\r\n\t\tsource:InfiniteValueFactory<T>):InfiniteLinqEnumerable<T>\r\n\r\n\texport function fromAny<T>(\r\n\t\tsource:ForEachEnumerable<T>):LinqEnumerable<T>\r\n\r\n\texport function fromAny(\r\n\t\tsource:any):LinqEnumerable<any> | undefined\r\n\r\n\texport function fromAny<T>(\r\n\t\tsource:ForEachEnumerable<T>,\r\n\t\tdefaultEnumerable:LinqEnumerable<T>):LinqEnumerable<T>\r\n\r\n\texport function fromAny<T>(\r\n\t\tsource:any,\r\n\t\tdefaultEnumerable?:LinqEnumerable<T>):LinqEnumerable<T> | InfiniteLinqEnumerable<T> | undefined\r\n\t{\r\n\t\tif(Type.isObject(source) || Type.isString(source))\r\n\t\t{\r\n\t\t\tif(source instanceof InfiniteLinqEnumerable)\r\n\t\t\t\treturn source;\r\n\r\n\t\t\tif(Type.isArrayLike<T>(source))\r\n\t\t\t\treturn new ArrayEnumerable<T>(source);\r\n\r\n\t\t\tif(isEnumerable<T>(source))\r\n\t\t\t\treturn new LinqEnumerable<T>(\r\n\t\t\t\t\t() => source.getEnumerator(),\r\n\t\t\t\t\tnull, source.isEndless);\r\n\r\n\t\t\tif(isEnumerator<T>(source))\r\n\t\t\t\treturn new LinqEnumerable<T>(\r\n\t\t\t\t\t() => source, null, source.isEndless);\r\n\r\n\t\t\tif(isIterator<T>(source))\r\n\t\t\t\treturn fromAny(new IteratorEnumerator(source));\r\n\t\t}\r\n\t\telse if(Type.isFunction(source))\r\n\t\t{\r\n\t\t\treturn new InfiniteLinqEnumerable<T>(\r\n\t\t\t\t() => new InfiniteEnumerator<T>(source));\r\n\t\t}\r\n\r\n\t\treturn defaultEnumerable;\r\n\t}\r\n\r\n\texport function fromThese<T>(sources:ForEachEnumerable<T>[]):LinqEnumerable<T>\r\n\t{\r\n\t\tswitch(sources ? sources.length : 0)\r\n\t\t{\r\n\t\t\tcase 0:\r\n\t\t\t\treturn empty<T>();\r\n\t\t\tcase 1:\r\n\t\t\t\t// Allow for validation and throwing...\r\n\t\t\t\treturn enumerableFrom<T>(sources[0]);\r\n\t\t\tdefault:\r\n\t\t\t\treturn empty<T>().merge(sources);\r\n\t\t}\r\n\t}\r\n\r\n\texport function fromOrEmpty<T>(source:ForEachEnumerable<T>):LinqEnumerable<T>\r\n\t{\r\n\t\treturn fromAny(source) || empty<T>();\r\n\t}\r\n\r\n\t/**\r\n\t * Static helper for converting enumerables to an array.\r\n\t * @param source\r\n\t * @returns {any}\r\n\t */\r\n\texport function toArray<T>(source:ForEachEnumerable<T>):T[]\r\n\t{\r\n\t\tif(source instanceof LinqEnumerable)\r\n\t\t\treturn source.toArray();\r\n\r\n\t\treturn enumUtil.toArray(source);\r\n\t}\r\n\r\n\r\n\texport function _choice<T>(values:T[]):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\treturn new InfiniteLinqEnumerable<T>(\r\n\t\t\t() => new EnumeratorBase<T>(\r\n\t\t\t\tnull,\r\n\t\t\t\t(yielder) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tthrowIfDisposed(!values);\r\n\t\t\t\t\treturn yielder.yieldReturn(Random.select.one(values));\r\n\t\t\t\t},\r\n\t\t\t\ttrue // Is endless!\r\n\t\t\t),\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvalues.length = 0;\r\n\t\t\t\tvalues = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function choice<T>(values:ArrayLike<T>):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tlet len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn _choice(copy(values));\r\n\t}\r\n\r\n\texport function chooseFrom<T>(arg:T, ...args:T[]):InfiniteLinqEnumerable<T>\r\n\texport function chooseFrom<T>(...args:T[]):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!args.length)\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn _choice(args);\r\n\t}\r\n\r\n\tfunction _cycle<T>(values:T[]):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\treturn new InfiniteLinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet index:number = 0;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t}, // Reinitialize the value just in case the enumerator is restarted.\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!values);\r\n\t\t\t\t\t\tif(index>=values.length) index = 0;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(values[index++]);\r\n\t\t\t\t\t},\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvalues.length = 0;\r\n\t\t\t\tvalues = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function cycle<T>(values:ArrayLike<T>):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tlet len = values && values.length;\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!len || !isFinite(len))\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\t// Make a copy to avoid modifying the collection as we go.\r\n\t\treturn _cycle(copy(values));\r\n\t}\r\n\r\n\texport function cycleThrough<T>(arg:T, ...args:T[]):InfiniteLinqEnumerable<T>\r\n\texport function cycleThrough<T>(...args:T[]):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\t// We could return empty if no length, but that would break the typing and produce unexpected results.\r\n\t\t// Enforcing that there must be at least 1 choice is key.\r\n\t\tif(!args.length)\r\n\t\t\tthrow new ArgumentOutOfRangeException('length', length);\r\n\r\n\t\treturn _cycle(args);\r\n\t}\r\n\r\n\texport function empty<T>():FiniteEnumerable<T>\r\n\t{\r\n\t\t// Could be single export function instance, but for safety, we'll make a new one.\r\n\t\treturn new FiniteEnumerable<T>(getEmptyEnumerator);\r\n\t}\r\n\r\n\texport function repeat<T>(element:T):InfiniteLinqEnumerable<T>;\r\n\texport function repeat<T>(element:T, count:number):FiniteEnumerable<T>;\r\n\texport function repeat<T>(element:T, count:number = Infinity):LinqEnumerable<T>\r\n\t{\r\n\t\tif(!(count>0))\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t? new FiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet c:number = count;\r\n\t\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() => { index = 0; },\r\n\t\t\t\t\t\t(yielder) => (index++<c) && yielder.yieldReturn(element),\r\n\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\t);\r\n\t\t\t\t}\r\n\t\t\t)\r\n\t\t\t: new LinqEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t\tnew EnumeratorBase<T>(\r\n\t\t\t\t\t\tnull,\r\n\t\t\t\t\t\t(yielder) => yielder.yieldReturn(element),\r\n\t\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t\t)\r\n\t\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * DEPRECATED This method began to not make sense in so many ways.\r\n\t * @deprecated since version 4.2\r\n\t * @param initializer\r\n\t * @param finalizer\r\n\t */\r\n\t// Note: this enumeration is endless but can be disposed/cancelled and finalized.\r\n\texport function repeatWithFinalize<T>(\r\n\t\tinitializer:() => T,\r\n\t\tfinalizer:Closure):InfiniteLinqEnumerable<T>\r\n\texport function repeatWithFinalize<T>(\r\n\t\tinitializer:() => T,\r\n\t\tfinalizer?:Action<T>):InfiniteLinqEnumerable<T>\r\n\texport function repeatWithFinalize<T>(\r\n\t\tinitializer:() => T,\r\n\t\tfinalizer?:Action<T>):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tif(!initializer)\r\n\t\t\tthrow new ArgumentNullException(\"initializer\");\r\n\r\n\t\treturn new InfiniteLinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet element:T;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(initializer)\r\n\t\t\t\t\t\t\telement = initializer();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn initializer\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(element)\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\telement = NULL;\r\n\t\t\t\t\t\tif(finalizer) finalizer(element);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tinitializer = NULL;\r\n\t\t\t\tfinalizer = VOID0;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates an enumerable of one element.\r\n\t * @param element\r\n\t * @returns {FiniteEnumerable<T>}\r\n\t */\r\n\texport function make<T>(element:T):FiniteEnumerable<T>\r\n\t{\r\n\t\treturn repeat<T>(element, 1);\r\n\t}\r\n\r\n// start and step can be other than integer.\r\n\r\n\texport function range(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!(count>0))\r\n\t\t\treturn empty<number>();\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\tInteger.assert(count, \"count\");\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\t\t\t\tlet c:number = count; // Force integer evaluation.\r\n\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet result:boolean =\r\n\t\t\t\t\t\t\t    index++<c\r\n\t\t\t\t\t\t\t    && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\tif(result && index<count)\r\n\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tfalse\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t}\r\n\r\n\texport function rangeDown(\r\n\t\tstart:number,\r\n\t\tcount:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tstep = Math.abs(step)* -1;\r\n\r\n\t\treturn range(start, count, step);\r\n\t}\r\n\r\n// step = -1 behaves the same as toNegativeInfinity;\r\n\texport function toInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number  = 1):InfiniteLinqEnumerable<number>\r\n\t{\r\n\t\tif(!isFinite(start))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"start\", start, \"Must be a finite number.\");\r\n\r\n\t\tif(!step)\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a valid value\");\r\n\r\n\t\tif(!isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite number.\");\r\n\r\n\t\treturn new InfiniteLinqEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tvalue = start;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet current:number = value;\r\n\t\t\t\t\t\tvalue += step;\r\n\t\t\t\t\t\treturn yielder.yieldReturn(current);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function toNegativeInfinity(\r\n\t\tstart:number = 0,\r\n\t\tstep:number  = 1):InfiniteLinqEnumerable<number>\r\n\t{\r\n\t\treturn toInfinity(start, -step);\r\n\t}\r\n\r\n\texport function rangeTo(\r\n\t\tstart:number,\r\n\t\tto:number,\r\n\t\tstep:number = 1):FiniteEnumerable<number>\r\n\t{\r\n\t\tif(isNaN(to) || !isFinite(to))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"to\", to, \"Must be a finite number.\");\r\n\r\n\t\tif(step && !isFinite(step))\r\n\t\t\tthrow new ArgumentOutOfRangeException(\"step\", step, \"Must be a finite non-zero number.\");\r\n\r\n// This way we adjust for the delta from start and to so the user can say +/- step and it will work as expected.\r\n\t\tstep = Math.abs(step);\r\n\r\n\t\treturn new FiniteEnumerable<number>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet value:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<number>(() => { value = start; },\r\n\t\t\t\t\tstart<to\r\n\t\t\t\t\t\t? yielder =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet result:boolean = value<=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\tvalue += step;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\t: yielder =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tlet result:boolean = value>=to && yielder.yieldReturn(value);\r\n\r\n\t\t\t\t\t\tif(result)\r\n\t\t\t\t\t\t\tvalue -= step;\r\n\r\n\t\t\t\t\t\treturn result;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t, false);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function matches(\r\n\t\tinput:string, pattern:any,\r\n\t\tflags:string = \"\"):FiniteEnumerable<RegExpExecArray>\r\n\t{\r\n\t\tif(input==null)\r\n\t\t\tthrow new ArgumentNullException(\"input\");\r\n\t\tconst type = typeof input;\r\n\t\tif(type!=Type.STRING)\r\n\t\t\tthrow new Error(\"Cannot exec RegExp matches of type '\" + type + \"'.\");\r\n\r\n\t\tif(pattern instanceof RegExp)\r\n\t\t{\r\n\t\t\tflags += (pattern.ignoreCase) ? \"i\" : \"\";\r\n\t\t\tflags += (pattern.multiline) ? \"m\" : \"\";\r\n\t\t\tpattern = pattern.source;\r\n\t\t}\r\n\r\n\t\tif(flags.indexOf(\"g\")=== -1) flags += \"g\";\r\n\r\n\t\treturn new FiniteEnumerable<RegExpExecArray>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet regex:RegExp;\r\n\t\t\t\treturn new EnumeratorBase<RegExpExecArray>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tregex = new RegExp(pattern, flags);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// Calling regex.exec consecutively on the same input uses the lastIndex to start the next match.\r\n\t\t\t\t\t\tlet match = regex.exec(input);\r\n\t\t\t\t\t\treturn match!=null\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(match)\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function generate<T>(factory:() => T):InfiniteLinqEnumerable<T>;\r\n\texport function generate<T>(factory:() => T, count:number):FiniteEnumerable<T>;\r\n\texport function generate<T>(factory:(index:number) => T):InfiniteLinqEnumerable<T>;\r\n\texport function generate<T>(factory:(index:number) => T, count:number):FiniteEnumerable<T>;\r\n\texport function generate<T>(\r\n\t\tfactory:(index?:number) => T,\r\n\t\tcount:number = Infinity):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tif(!factory)\r\n\t\t\tthrow new ArgumentNullException(\"factory\");\r\n\r\n\t\tif(isNaN(count) || count<=0)\r\n\t\t\treturn Enumerable.empty<T>();\r\n\r\n\t\treturn isFinite(count) && Integer.assert(count, \"count\")\r\n\t\t\t? new FiniteEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet c:number = count;\r\n\t\t\t\t\tlet index:number = 0;\r\n\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(!factory);\r\n\t\t\t\t\t\t\tlet current:number = index++;\r\n\t\t\t\t\t\t\treturn current<c && yielder.yieldReturn(factory(current));\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\tfalse\r\n\t\t\t\t\t);\r\n\t\t\t\t},\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tfactory = NULL;\r\n\t\t\t\t})\r\n\t\t\t: new InfiniteLinqEnumerable<T>(\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlet index:number = 0;\r\n\t\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t\t() =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tthrowIfDisposed(!factory);\r\n\t\t\t\t\t\t\treturn yielder.yieldReturn(factory(index++));\r\n\t\t\t\t\t\t},\r\n\r\n\t\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t\t);\r\n\t\t\t\t},\r\n\t\t\t\t() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tfactory = NULL;\r\n\t\t\t\t});\r\n\t}\r\n\r\n\r\n\texport module random\r\n\t{\r\n\t\texport function floats(maxExclusive:number = 1):InfiniteLinqEnumerable<number>\r\n\t\t{\r\n\t\t\treturn generate(Random.generate(maxExclusive));\r\n\t\t}\r\n\r\n\t\texport function integers(boundary:number, inclusive?:boolean):InfiniteLinqEnumerable<number>\r\n\t\t{\r\n\t\t\treturn generate(Random.generate.integers(boundary, inclusive));\r\n\t\t}\r\n\t}\r\n\r\n\texport function unfold<T>(\r\n\t\tseed:T,\r\n\t\tvalueFactory:SelectorWithIndex<T, T>,\r\n\t\tskipSeed:Boolean = false):InfiniteLinqEnumerable<T>\r\n\t{\r\n\t\tif(!valueFactory)\r\n\t\t\tthrow new ArgumentNullException(\"factory\");\r\n\r\n\t\treturn new InfiniteLinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet index:number = 0;\r\n\t\t\t\tlet value:T;\r\n\t\t\t\tlet isFirst:boolean;\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tvalue = seed;\r\n\t\t\t\t\t\tisFirst = !skipSeed;\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(!valueFactory);\r\n\t\t\t\t\t\tlet i = index++;\r\n\t\t\t\t\t\tif(isFirst)\r\n\t\t\t\t\t\t\tisFirst = false;\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t\tvalue = valueFactory(value, i);\r\n\t\t\t\t\t\treturn yielder.yieldReturn(value);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\ttrue // Is endless!\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tvalueFactory = NULL;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n\texport function forEach<T>(\r\n\t\te:ForEachEnumerable<T>,\r\n\t\taction:ActionWithIndex<T>,\r\n\t\tmax?:number):number\r\n\r\n\texport function forEach<T>(\r\n\t\te:ForEachEnumerable<T>,\r\n\t\taction:PredicateWithIndex<T>,\r\n\t\tmax?:number):number\r\n\r\n\texport function forEach<T>(\r\n\t\tenumerable:ForEachEnumerable<T>,\r\n\t\taction:ActionWithIndex<T> | PredicateWithIndex<T>,\r\n\t\tmax:number = Infinity):number\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn enumUtil.forEach(enumerable, action, max);\r\n\t}\r\n\r\n\texport function map<T, TResult>(\r\n\t\tenumerable:ForEachEnumerable<T>,\r\n\t\tselector:SelectorWithIndex<T, TResult>):TResult[]\r\n\t{\r\n\t\t// Will properly dispose created enumerable.\r\n\t\t// Will throw if enumerable is endless.\r\n\t\treturn enumUtil.map(enumerable, selector);\r\n\t}\r\n\r\n// Slightly optimized versions for numbers.\r\n\texport function max(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\tconst v = values\r\n\t\t\t.takeUntil(v => v== +Infinity, true)\r\n\t\t\t.aggregate(Functions.Greater);\r\n\r\n\t\treturn v===VOID0 ? NaN : v;\r\n\t}\r\n\r\n\texport function min(values:FiniteEnumerable<number>):number\r\n\t{\r\n\t\tconst v = values\r\n\t\t\t.takeUntil(v => v== -Infinity, true)\r\n\t\t\t.aggregate(Functions.Lesser);\r\n\r\n\t\treturn v===VOID0 ? NaN : v;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Takes any set of collections of the same type and weaves them together.\r\n\t * @param enumerables\r\n\t * @returns {Enumerable<T>}\r\n\t */\r\n\texport function weave<T>(\r\n\t\tenumerables:ForEachEnumerable<ForEachEnumerable<T>>):LinqEnumerable<T>\r\n\t{\r\n\t\tif(!enumerables)\r\n\t\t\tthrow new ArgumentNullException('enumerables');\r\n\r\n\t\tlet disposed = false;\r\n\t\treturn new LinqEnumerable<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tlet queue:Queue<IEnumerator<T>>;\r\n\t\t\t\tlet mainEnumerator:IEnumerator<ForEachEnumerable<T>> | null;\r\n\t\t\t\tlet index:number;\r\n\r\n\t\t\t\treturn new EnumeratorBase<T>(\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tindex = 0;\r\n\t\t\t\t\t\tqueue = new Queue<IEnumerator<T>>();\r\n\t\t\t\t\t\tmainEnumerator = enumUtil.from(enumerables);\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t(yielder) =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthrowIfDisposed(disposed);\r\n\t\t\t\t\t\tlet e:IEnumerator<T> | null = null;\r\n\r\n\t\t\t\t\t\t// First pass...\r\n\t\t\t\t\t\tif(mainEnumerator)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\twhile(!e && mainEnumerator.moveNext())\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tlet c = mainEnumerator.current;\r\n\t\t\t\t\t\t\t\te = nextEnumerator(queue, c ? enumUtil.from(c) : NULL);\r\n\t\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\t\tif(!e)\r\n\t\t\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\twhile(!e && queue.tryDequeue(value =>\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\te = nextEnumerator(queue, enumUtil.from<T>(value));\r\n\t\t\t\t\t\t}))\r\n\t\t\t\t\t\t{ }\r\n\r\n\t\t\t\t\t\treturn e\r\n\t\t\t\t\t\t\t? yielder.yieldReturn(e.current)\r\n\t\t\t\t\t\t\t: yielder.yieldBreak();\r\n\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\t() =>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(queue)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tdispose.these.noCopy(queue.dump());\r\n\t\t\t\t\t\t\tqueue = NULL;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tif(mainEnumerator) mainEnumerator.dispose();\r\n\t\t\t\t\t\tmainEnumerator = null;\r\n\t\t\t\t\t}\r\n\t\t\t\t);\r\n\t\t\t},\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tdisposed = true;\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n\r\n}\r\n\r\nexport default Enumerable;\r\n"]}