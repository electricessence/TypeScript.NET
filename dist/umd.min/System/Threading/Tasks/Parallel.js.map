{"version":3,"sources":["System/Threading/Tasks/Parallel.js","System/Threading/Tasks/Parallel.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","extend","from","to","_i","_a","Object","keys","length","i","VOID0","interact","w","onMessage","onError","message","onmessage","onerror","postMessage","defineProperty","value","workers","Promise_1","Types_1","Worker_1","deferImmediate_1","Environment_1","ObjectPool_1","extends_1","__extends","MAX_WORKERS","URL","self","Type","UNDEFINED","webkitURL","_supports","isNodeJS","Worker","defaults","evalPath","__dirname","maxConcurrency","cpus","navigator","hardwareConcurrency","allowSynchronous","env","envNamespace","WorkerPromise","_super","worker","data","call","this","resolve","reject","response","e","TSDNPromise","getPool","key","pool","workerPools","ObjectPool","autoClearTimeout","recycle","k","__key","add","deferImmediate","terminate","tryGet","tryTake","getNew","url","dispose","Parallel","options","_requiredScripts","_requiredFunctions","ensureClampedMaxConcurrency","max","prototype","_getWorkerSource","task","scripts","functions","preStr","join","functions_1","name_1","name","fn","source","toString","JSON","stringify","ns","required","arguments","requireThese","required_1","a","STRING","push","FUNCTION","OBJECT","TypeError","_spawnWorker","src","Error","blob","Blob","type","createObjectURL","startNew","_","finallyThis","startLocal","pipe","result","error_1","len_1","taskString","i_1","_loop_1","this_1","map","d","next","ii","p_1","wp_1","thenSynchronous","r","Math","min","state_1","PromiseCollection","console","warn","_this","slice","ArrayPromise","len","error","resolved","_loop_2","all","ii_1","wp_2","thenThis","state_2","fulfilled","get","enumerable","configurable"],"mappings":"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","file":"Parallel.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\n */\n(function (factory) {\n    if (typeof module === \"object\" && typeof module.exports === \"object\") {\n        var v = factory(require, exports);\n        if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === \"function\" && define.amd) {\n        define([\"require\", \"exports\", \"../../Promises/Promise\", \"../../Types\", \"../Worker\", \"../deferImmediate\", \"../../Environment\", \"../../Disposable/ObjectPool\", \"../../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    var Promise_1 = require(\"../../Promises/Promise\");\n    var Types_1 = require(\"../../Types\");\n    var Worker_1 = require(\"../Worker\");\n    var deferImmediate_1 = require(\"../deferImmediate\");\n    var Environment_1 = require(\"../../Environment\");\n    var ObjectPool_1 = require(\"../../Disposable/ObjectPool\");\n    var extends_1 = require(\"../../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    //noinspection JSUnusedAssignment\n    var MAX_WORKERS = 16, VOID0 = void 0, URL = typeof self !== Types_1.Type.UNDEFINED\n        ? (self.URL ? self.URL : self.webkitURL)\n        : null, _supports = Environment_1.isNodeJS || !!self.Worker; // node always supports parallel\n    //noinspection JSUnusedAssignment\n    var defaults = {\n        evalPath: Environment_1.isNodeJS ? __dirname + '/eval.js' : VOID0,\n        maxConcurrency: Environment_1.isNodeJS\n            ? require('os').cpus().length\n            : (navigator.hardwareConcurrency || 4),\n        allowSynchronous: true,\n        env: {},\n        envNamespace: 'env'\n    };\n    function extend(from, to) {\n        if (!to)\n            to = {};\n        for (var _i = 0, _a = Object.keys(from); _i < _a.length; _i++) {\n            var i = _a[_i];\n            if (to[i] === VOID0)\n                to[i] = from[i];\n        }\n        return to;\n    }\n    function interact(w, onMessage, onError, message) {\n        if (onMessage)\n            w.onmessage = onMessage;\n        if (onError)\n            w.onerror = onError;\n        if (message !== VOID0)\n            w.postMessage(message);\n    }\n    var WorkerPromise = (function (_super) {\n        __extends(WorkerPromise, _super);\n        function WorkerPromise(worker, data) {\n            return _super.call(this, function (resolve, reject) {\n                interact(worker, function (response) {\n                    resolve(response.data);\n                }, function (e) {\n                    reject(e);\n                }, data);\n            }, true) || this;\n        }\n        return WorkerPromise;\n    }(Promise_1.TSDNPromise));\n    var workers;\n    (function (workers) {\n        /*\n         * Note:\n         * Currently there is nothing preventing excessive numbers of workers from being generated.\n         * Eventually there will be a master pool count which will regulate these workers.\n         */\n        function getPool(key) {\n            var pool = workerPools[key];\n            if (!pool) {\n                workerPools[key] = pool = new ObjectPool_1.ObjectPool(8);\n                pool.autoClearTimeout = 3000; // Fast cleanup... 1s.\n            }\n            return pool;\n        }\n        var workerPools = {};\n        function recycle(w) {\n            if (w) {\n                w.onerror = null;\n                w.onmessage = null;\n                var k = w.__key;\n                if (k) {\n                    getPool(k).add(w);\n                }\n                else {\n                    deferImmediate_1.deferImmediate(function () { return w.terminate(); });\n                }\n            }\n            return null;\n        }\n        workers.recycle = recycle;\n        function tryGet(key) {\n            return getPool(key).tryTake();\n        }\n        workers.tryGet = tryGet;\n        function getNew(key, url) {\n            var worker = new Worker_1.default(url);\n            worker.__key = key;\n            if (!worker.dispose) {\n                worker.dispose = function () {\n                    worker.onmessage = null;\n                    worker.onerror = null;\n                    worker.dispose = null;\n                    worker.terminate();\n                };\n            }\n            return worker;\n        }\n        workers.getNew = getNew;\n    })(workers || (workers = {}));\n    var Parallel = (function () {\n        function Parallel(options) {\n            this.options = extend(defaults, options);\n            this._requiredScripts = [];\n            this._requiredFunctions = [];\n            this.ensureClampedMaxConcurrency();\n        }\n        Parallel.maxConcurrency = function (max) {\n            return new Parallel({ maxConcurrency: max });\n        };\n        Parallel.prototype._getWorkerSource = function (task, env) {\n            var scripts = this._requiredScripts, functions = this._requiredFunctions;\n            var preStr = '';\n            if (!Environment_1.isNodeJS && scripts.length) {\n                preStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\n            }\n            for (var _i = 0, functions_1 = functions; _i < functions_1.length; _i++) {\n                var _a = functions_1[_i], name_1 = _a.name, fn = _a.fn;\n                var source = fn.toString();\n                preStr += name_1\n                    ? \"var \" + name_1 + \" = \" + source + \";\"\n                    : source;\n            }\n            env = JSON.stringify(env || {});\n            var ns = this.options.envNamespace;\n            return preStr + (Environment_1.isNodeJS\n                ? \"process.on(\\\"message\\\", function(e) {global.\" + ns + \" = \" + env + \";process.send(JSON.stringify((\" + task.toString() + \")(JSON.parse(e).data)))})\"\n                : \"self.onmessage = function(e) {var global = {}; global.\" + ns + \" = \" + env + \";self.postMessage((\" + task.toString() + \")(e.data))}\");\n        };\n        Parallel.prototype.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i] = arguments[_i];\n            }\n            return this.requireThese(required);\n        };\n        Parallel.prototype.requireThese = function (required) {\n            for (var _i = 0, required_1 = required; _i < required_1.length; _i++) {\n                var a = required_1[_i];\n                switch (typeof a) {\n                    case Types_1.Type.STRING:\n                        this._requiredScripts.push(a);\n                        break;\n                    case Types_1.Type.FUNCTION:\n                        this._requiredFunctions.push({ fn: a });\n                        break;\n                    case Types_1.Type.OBJECT:\n                        this._requiredFunctions.push(a);\n                        break;\n                    default:\n                        throw new TypeError(\"Invalid type.\");\n                }\n            }\n            return this;\n        };\n        Parallel.prototype._spawnWorker = function (task, env) {\n            var src = this._getWorkerSource(task, env);\n            if (Worker_1.default === VOID0)\n                return VOID0;\n            var worker = workers.tryGet(src);\n            if (worker)\n                return worker;\n            var scripts = this._requiredScripts;\n            var evalPath = this.options.evalPath;\n            if (!evalPath) {\n                if (Environment_1.isNodeJS)\n                    throw new Error(\"Can't use NodeJS without eval.js!\");\n                if (scripts.length)\n                    throw new Error(\"Can't use required scripts without eval.js!\");\n                if (!URL)\n                    throw new Error(\"Can't create a blob URL in this browser!\");\n            }\n            if (Environment_1.isNodeJS || scripts.length || !URL) {\n                worker = workers.getNew(src, evalPath);\n                worker.postMessage(src);\n            }\n            else if (URL) {\n                var blob = new Blob([src], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                worker = workers.getNew(src, url);\n            }\n            return worker;\n        };\n        /**\n         * Schedules the task to be run in the worker pool.\n         * @param data\n         * @param task\n         * @param env\n         * @returns {TSDNPromise<U>|TSDNPromise}\n         */\n        Parallel.prototype.startNew = function (data, task, env) {\n            var _ = this;\n            var maxConcurrency = this.ensureClampedMaxConcurrency();\n            var worker = maxConcurrency ? _._spawnWorker(task, extend(_.options.env, env || {})) : null;\n            if (worker) {\n                return new WorkerPromise(worker, data)\n                    .finallyThis(function () { return workers.recycle(worker); });\n            }\n            if (_.options.allowSynchronous)\n                return this.startLocal(data, task);\n            throw new Error(maxConcurrency\n                ? \"Workers do not exist and synchronous operation not allowed!\"\n                : \"'maxConcurrency' set to 0 but 'allowSynchronous' is false.\");\n        };\n        /**\n         * Runs the task within the local thread/process.\n         * Is good for use with testing.\n         * @param data\n         * @param task\n         * @returns {TSDNPromise<U>|TSDNPromise}\n         */\n        Parallel.prototype.startLocal = function (data, task) {\n            return new Promise_1.TSDNPromise(function (resolve, reject) {\n                try {\n                    resolve(task(data));\n                }\n                catch (e) {\n                    reject(e);\n                }\n            });\n        };\n        /**\n         * Returns an array of promises that each resolve after their task completes.\n         * Provides a potential performance benefit by not waiting for all promises to resolve before proceeding to next step.\n         * @param data\n         * @param task\n         * @param env\n         * @returns {PromiseCollection}\n         */\n        Parallel.prototype.pipe = function (data, task, env) {\n            // The resultant promise collection will make an internal copy...\n            var result;\n            if (data && data.length) {\n                var len_1 = data.length;\n                var taskString = task.toString();\n                var maxConcurrency = this.ensureClampedMaxConcurrency();\n                var error_1;\n                var i_1 = 0;\n                var _loop_1 = function (w) {\n                    var worker = maxConcurrency ? this_1._spawnWorker(taskString, env) : null;\n                    if (!worker) {\n                        if (!this_1.options.allowSynchronous)\n                            throw new Error(maxConcurrency\n                                ? \"Workers do not exist and synchronous operation not allowed!\"\n                                : \"'maxConcurrency' set to 0 but 'allowSynchronous' is false.\");\n                        return { value: Promise_1.TSDNPromise.map(data, task) };\n                    }\n                    if (!result) {\n                        // There is a small risk that the consumer could call .resolve() which would result in a double resolution.\n                        // But it's important to minimize the number of objects created.\n                        result = data.map(function (d) { return new Promise_1.TSDNPromise(); });\n                    }\n                    var next = function () {\n                        if (error_1) {\n                            worker = workers.recycle(worker);\n                        }\n                        if (worker) {\n                            if (i_1 < len_1) {\n                                //noinspection JSReferencingMutableVariableFromClosure\n                                var ii = i_1++, p_1 = result[ii];\n                                var wp_1 = new WorkerPromise(worker, data[ii]);\n                                //noinspection JSIgnoredPromiseFromCall\n                                wp_1.thenSynchronous(function (r) {\n                                    //noinspection JSIgnoredPromiseFromCall\n                                    p_1.resolve(r);\n                                    next();\n                                }, function (e) {\n                                    if (!error_1) {\n                                        error_1 = e;\n                                        //noinspection JSIgnoredPromiseFromCall\n                                        p_1.reject(e);\n                                        worker = workers.recycle(worker);\n                                    }\n                                })\n                                    .finallyThis(function () {\n                                    return wp_1.dispose();\n                                });\n                            }\n                            else {\n                                worker = workers.recycle(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                var this_1 = this;\n                for (var w = 0; !error_1 && i_1 < Math.min(len_1, maxConcurrency); w++) {\n                    var state_1 = _loop_1(w);\n                    if (typeof state_1 === \"object\")\n                        return state_1.value;\n                }\n            }\n            return new Promise_1.PromiseCollection(result);\n        };\n        Parallel.prototype.ensureClampedMaxConcurrency = function () {\n            var maxConcurrency = this.options.maxConcurrency;\n            if (maxConcurrency && maxConcurrency > MAX_WORKERS) {\n                this.options.maxConcurrency = maxConcurrency = MAX_WORKERS;\n                console.warn(\"More than \" + MAX_WORKERS + \" workers can reach worker limits and cause unexpected results.  maxConcurrency reduced to \" + MAX_WORKERS + \".\");\n            }\n            return (maxConcurrency || maxConcurrency === 0) ? maxConcurrency : MAX_WORKERS;\n        };\n        /**\n         * Waits for all tasks to resolve and returns a promise with the results.\n         * @param data\n         * @param task\n         * @param env\n         * @returns {ArrayPromise}\n         */\n        Parallel.prototype.map = function (data, task, env) {\n            var _this = this;\n            if (!data || !data.length)\n                return Promise_1.ArrayPromise.fulfilled(data && []);\n            // Would return the same result, but has extra overhead.\n            // return this.pipe(data,task).all();\n            data = data.slice(); // Never use the original.\n            return new Promise_1.ArrayPromise(function (resolve, reject) {\n                var result = [], len = data.length;\n                result.length = len;\n                var taskString = task.toString();\n                var maxConcurrency = _this.ensureClampedMaxConcurrency(), error;\n                var i = 0, resolved = 0;\n                var _loop_2 = function (w) {\n                    var worker = _this._spawnWorker(taskString, env);\n                    if (!worker) {\n                        if (!_this.options.allowSynchronous)\n                            throw new Error('Workers do not exist and synchronous operation not allowed!');\n                        // Concurrency doesn't matter in a single thread... Just queue it all up.\n                        resolve(Promise_1.TSDNPromise.map(data, task).all());\n                        return { value: void 0 };\n                    }\n                    var next = function () {\n                        if (error) {\n                            worker = workers.recycle(worker);\n                        }\n                        if (worker) {\n                            if (i < len) {\n                                var ii_1 = i++;\n                                var wp_2 = new WorkerPromise(worker, data[ii_1]);\n                                //noinspection JSIgnoredPromiseFromCall\n                                wp_2.thenSynchronous(function (r) {\n                                    result[ii_1] = r;\n                                    next();\n                                }, function (e) {\n                                    if (!error) {\n                                        error = e;\n                                        reject(e);\n                                        worker = workers.recycle(worker);\n                                    }\n                                })\n                                    .thenThis(function () {\n                                    resolved++;\n                                    if (resolved > len)\n                                        throw Error(\"Resolved count exceeds data length.\");\n                                    if (resolved === len)\n                                        resolve(result);\n                                })\n                                    .finallyThis(function () {\n                                    return wp_2.dispose();\n                                });\n                            }\n                            else {\n                                worker = workers.recycle(worker);\n                            }\n                        }\n                    };\n                    next();\n                };\n                for (var w = 0; !error && i < Math.min(len, maxConcurrency); w++) {\n                    var state_2 = _loop_2(w);\n                    if (typeof state_2 === \"object\")\n                        return state_2.value;\n                }\n            });\n        };\n        Object.defineProperty(Parallel, \"isSupported\", {\n            get: function () { return _supports; },\n            enumerable: true,\n            configurable: true\n        });\n        Parallel.options = function (options) {\n            return new Parallel(options);\n        };\n        Parallel.require = function () {\n            var required = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                required[_i] = arguments[_i];\n            }\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.requireThese = function (required) {\n            return (new Parallel()).requireThese(required);\n        };\n        Parallel.startNew = function (data, task, env) {\n            return (new Parallel()).startNew(data, task, env);\n        };\n        //\n        // forEach<T>(data:T[], task:(data:T) => void, env?:any):PromiseBase<void>\n        // {}\n        Parallel.map = function (data, task, env) {\n            return (new Parallel()).map(data, task, env);\n        };\n        return Parallel;\n    }());\n    exports.Parallel = Parallel;\n    //\n    //\n    // \tprivate _spawnReduceWorker<N>(\n    // \t\tdata:any,\n    // \t\tcb:(data:N) => N,\n    // \t\tdone:(err?:any, wrk?:WorkerLike)=>void,\n    // \t\tenv?:any,\n    // \t\twrk?:WorkerLike)\n    // \t{\n    // \t\tconst _ = this;\n    // \t\tif(!wrk) wrk = _._spawnWorker(cb, env);\n    //\n    // \t\tif(wrk!==VOID0)\n    // \t\t{\n    // \t\t\tinteract(wrk,\n    // \t\t\t\tmsg=>\n    // \t\t\t\t{\n    // \t\t\t\t\t_.data[_.data.length] = msg.data;\n    // \t\t\t\t\tdone(null, wrk);\n    // \t\t\t\t},\n    // \t\t\t\te=>\n    // \t\t\t\t{\n    // \t\t\t\t\twrk.terminate();\n    // \t\t\t\t\tdone(e, null);\n    // \t\t\t\t},\n    // \t\t\t\tdata);\n    // \t\t}\n    // \t\telse if(_.options.allowSynchronous)\n    // \t\t{\n    // \t\t\tdeferImmediate(()=>\n    // \t\t\t{\n    // \t\t\t\t_.data[_.data.length] = cb(data);\n    // \t\t\t\tdone();\n    // \t\t\t});\n    // \t\t}\n    // \t\telse\n    // \t\t{\n    // \t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\n    // \t\t}\n    // \t}\n    //\n    //\n    //\n    //\n    // \treduce<N>(cb:(data:N[]) => N, env?:any):Parallel<T>\n    // \t{\n    // \t\tenv = extend(this.options.env, env || {});\n    //\n    // \t\tvar runningWorkers = 0;\n    // \t\tconst _ = this;\n    //\n    //\n    // \t\t_._operation = new Promise<any>((resolve, reject)=>\n    // \t\t{\n    //\n    // \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\n    // \t\t\t{\n    // \t\t\t\t--runningWorkers;\n    // \t\t\t\tif(err)\n    // \t\t\t\t{\n    // \t\t\t\t\treject(err);\n    // \t\t\t\t}\n    // \t\t\t\telse if(_.data.length===1 && runningWorkers===0)\n    // \t\t\t\t{\n    // \t\t\t\t\tresolve(_.data = _.data[0]);\n    // \t\t\t\t\tif(wrk) wrk.terminate();\n    // \t\t\t\t}\n    // \t\t\t\telse if(_.data.length>1)\n    // \t\t\t\t{\n    // \t\t\t\t\t++runningWorkers;\n    // \t\t\t\t\t_._spawnReduceWorker([_.data[0], _.data[1]], cb, done, env, wrk);\n    // \t\t\t\t\t_.data.splice(0, 2);\n    // \t\t\t\t}\n    // \t\t\t\telse\n    // \t\t\t\t{\n    // \t\t\t\t\tif(wrk) wrk.terminate();\n    // \t\t\t\t}\n    // \t\t\t};\n    //\n    // \t\t\tif(_.data.length===1)\n    // \t\t\t{\n    // \t\t\t\tresolve(_.data[0]);\n    // \t\t\t}\n    // \t\t\telse\n    // \t\t\t{\n    // \t\t\t\tfor(var i = 0; i<_.options.maxConcurrency && i<Math.floor(_.data.length/2); ++i)\n    // \t\t\t\t{\n    // \t\t\t\t\t++runningWorkers;\n    // \t\t\t\t\t_._spawnReduceWorker([_.data[i*2], _.data[i*2 + 1]], cb, done, env);\n    // \t\t\t\t}\n    //\n    // \t\t\t\t_.data.splice(0, i*2);\n    // \t\t\t}\n    // \t\t}, true);\n    // \t\treturn this;\n    //\n    // \t}\n    exports.default = Parallel;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * Originally based upon Parallel.js: https://github.com/adambom/parallel.js/blob/master/lib/parallel.js\r\n */\r\n\r\nimport {ArrayPromise, TSDNPromise, PromiseBase, PromiseCollection} from \"../../Promises/Promise\";\r\nimport {Type} from \"../../Types\";\r\nimport Worker from \"../Worker\";\r\nimport {WorkerLike} from \"../WorkerType\";\r\nimport {deferImmediate} from \"../deferImmediate\";\r\nimport {isNodeJS} from \"../../Environment\";\r\nimport {ObjectPool} from \"../../Disposable/ObjectPool\";\r\nimport {IMap} from \"../../../IMap\";\r\nimport __extendsImport from \"../../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\ndeclare const navigator:any;\r\ndeclare const __dirname:string;\r\n\r\n//noinspection JSUnusedAssignment\r\nconst\r\n\tMAX_WORKERS:number = 16,\r\n\tVOID0:undefined    = void 0,\r\n\tURL                = typeof self!==Type.UNDEFINED\r\n\t\t? (self.URL ? self.URL : (<any>self).webkitURL)\r\n\t\t: null,\r\n\t_supports          = isNodeJS || !!(<any>self).Worker; // node always supports parallel\r\n\r\nexport interface ParallelOptions\r\n{\r\n\t/**\r\n\t * This is the path to the file eval.js.  This is required when running in node, and required for some browsers (IE 10) in order to work around cross-domain restrictions for web workers.  Defaults to the same location as parallel.js in node environments, and null in the browser.\r\n\t **/\r\n\tevalPath?:string;\r\n\r\n\t/**\r\n\t * The maximum number of permitted worker threads.  This will default to 4, or the number of CPUs on your computer if you're running node.\r\n\t **/\r\n\tmaxConcurrency?:number;\r\n\r\n\t/**\r\n\t * If WebWorkers are not available, whether or not to fall back to synchronous processing using setTimeout.  Defaults to true.\r\n\t **/\r\n\tallowSynchronous?:boolean;\r\n\r\n\tenv?:any\r\n\tenvNamespace?:string\r\n}\r\n\r\n//noinspection JSUnusedAssignment\r\nconst defaults:ParallelOptions = {\r\n\tevalPath: isNodeJS ? __dirname + '/eval.js' : VOID0,\r\n\tmaxConcurrency: isNodeJS\r\n\t\t? (<any>require)('os').cpus().length\r\n\t\t: (navigator.hardwareConcurrency || 4),\r\n\tallowSynchronous: true,\r\n\tenv: {},\r\n\tenvNamespace: 'env'\r\n};\r\n\r\nfunction extend<TFrom extends any,TTo extends any>(from:TFrom, to:TTo):TFrom & TTo\r\n{\r\n\tif(!to) to = <any>{};\r\n\tfor(let i of Object.keys(from))\r\n\t{\r\n\t\tif(to[i]===VOID0) to[i] = from[i];\r\n\t}\r\n\treturn <any>to;\r\n}\r\n\r\nfunction interact(\r\n\tw:WorkerLike,\r\n\tonMessage:(msg:{data:any})=>void,\r\n\tonError:(e:any)=>void,\r\n\tmessage?:any):void\r\n{\r\n\tif(onMessage) w.onmessage = onMessage;\r\n\tif(onError) w.onerror = onError;\r\n\tif(message!==VOID0) w.postMessage(message);\r\n}\r\n\r\nclass WorkerPromise<T> extends TSDNPromise<T>\r\n{\r\n\tconstructor(worker:WorkerLike, data:any)\r\n\t{\r\n\t\tsuper((resolve, reject) =>\r\n\t\t{\r\n\t\t\tinteract(\r\n\t\t\t\tworker,\r\n\t\t\t\t(response:{data:any}) =>\r\n\t\t\t\t{\r\n\t\t\t\t\tresolve(response.data);\r\n\t\t\t\t},\r\n\t\t\t\t(e:any) =>\r\n\t\t\t\t{\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t},\r\n\t\t\t\tdata)\r\n\t\t}, true);\r\n\t}\r\n}\r\n\r\nexport type RequireType = string | Function | {name?:string,fn:Function};\r\n\r\nmodule workers\r\n{\r\n\r\n\t/*\r\n\t * Note:\r\n\t * Currently there is nothing preventing excessive numbers of workers from being generated.\r\n\t * Eventually there will be a master pool count which will regulate these workers.\r\n\t */\r\n\r\n\tfunction getPool(key:string):ObjectPool<WorkerLike>\r\n\t{\r\n\t\tlet pool = workerPools[key];\r\n\t\tif(!pool)\r\n\t\t{\r\n\t\t\tworkerPools[key] = pool = new ObjectPool<WorkerLike>(8);\r\n\t\t\tpool.autoClearTimeout = 3000; // Fast cleanup... 1s.\r\n\t\t}\r\n\t\treturn pool;\r\n\t}\r\n\r\n\tconst workerPools:IMap<ObjectPool<WorkerLike>> = {};\r\n\r\n\texport function recycle(w:WorkerLike|null|undefined):null\r\n\t{ // always returns null.\r\n\t\tif(w)\r\n\t\t{\r\n\t\t\tw.onerror = <any>null;\r\n\t\t\tw.onmessage = <any>null;\r\n\t\t\tconst k = (<any>w).__key;\r\n\t\t\tif(k)\r\n\t\t\t{\r\n\t\t\t\tgetPool(k).add(w);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tdeferImmediate(() => w.terminate());\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn null;\r\n\t}\r\n\r\n\texport function tryGet(key:string):WorkerLike|undefined\r\n\t{\r\n\t\treturn getPool(key).tryTake();\r\n\t}\r\n\r\n\texport function getNew(key:string, url:string):WorkerLike\r\n\t{\r\n\t\tconst worker:any = new Worker(url);\r\n\t\tworker.__key = key;\r\n\t\tif(!worker.dispose)\r\n\t\t{\r\n\t\t\tworker.dispose = () =>\r\n\t\t\t{\r\n\t\t\t\tworker.onmessage = null;\r\n\t\t\t\tworker.onerror = null;\r\n\t\t\t\tworker.dispose = null;\r\n\t\t\t\tworker.terminate();\r\n\t\t\t};\r\n\t\t}\r\n\t\treturn worker;\r\n\t}\r\n}\r\n\r\n\r\nexport class Parallel\r\n{\r\n\r\n\toptions:ParallelOptions;\r\n\t_requiredScripts:string[];\r\n\t_requiredFunctions:{name?:string,fn:Function}[];\r\n\r\n\tconstructor(options?:ParallelOptions)\r\n\t{\r\n\t\tthis.options = extend(defaults, options);\r\n\t\tthis._requiredScripts = [];\r\n\t\tthis._requiredFunctions = [];\r\n\r\n\t\tthis.ensureClampedMaxConcurrency();\r\n\t}\r\n\r\n\tstatic maxConcurrency(max:number):Parallel\r\n\t{\r\n\t\treturn new Parallel({maxConcurrency: max});\r\n\t}\r\n\r\n\tprotected _getWorkerSource(task:Function|string, env?:any):string\r\n\t{\r\n\t\tconst scripts = this._requiredScripts, functions = this._requiredFunctions;\r\n\t\tlet preStr = '';\r\n\r\n\t\tif(!isNodeJS && scripts.length)\r\n\t\t{\r\n\t\t\tpreStr += 'importScripts(\"' + scripts.join('\",\"') + '\");\\r\\n';\r\n\t\t}\r\n\r\n\t\tfor(let {name, fn} of functions)\r\n\t\t{\r\n\t\t\tconst source = fn.toString();\r\n\t\t\tpreStr += name\r\n\t\t\t\t? `var ${name} = ${source};`\r\n\t\t\t\t: source;\r\n\t\t}\r\n\r\n\r\n\t\tenv = JSON.stringify(env || {});\r\n\r\n\t\tconst ns = this.options.envNamespace;\r\n\r\n\t\treturn preStr + (\r\n\t\t\t\tisNodeJS\r\n\t\t\t\t\t? `process.on(\"message\", function(e) {global.${ns} = ${env};process.send(JSON.stringify((${task.toString()})(JSON.parse(e).data)))})`\r\n\t\t\t\t\t: `self.onmessage = function(e) {var global = {}; global.${ns} = ${env};self.postMessage((${task.toString()})(e.data))}`\r\n\t\t\t);\r\n\t}\r\n\r\n\trequire(...required:RequireType[]):this\r\n\t{\r\n\t\treturn this.requireThese(required);\r\n\t}\r\n\r\n\trequireThese(required:RequireType[]):this\r\n\t{\r\n\t\tfor(let a of required)\r\n\t\t{\r\n\t\t\tswitch(typeof a)\r\n\t\t\t{\r\n\t\t\t\tcase Type.STRING:\r\n\t\t\t\t\tthis._requiredScripts.push(<string>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.FUNCTION:\r\n\t\t\t\t\tthis._requiredFunctions.push({fn: <Function>a});\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase Type.OBJECT:\r\n\t\t\t\t\tthis._requiredFunctions.push(<{name?:string,fn:Function}>a);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tdefault:\r\n\t\t\t\t\tthrow new TypeError(\"Invalid type.\");\r\n\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _spawnWorker(task:Function|string, env?:any):WorkerLike|undefined\r\n\t{\r\n\t\tconst src = this._getWorkerSource(task, env);\r\n\r\n\t\tif(Worker===VOID0) return VOID0;\r\n\t\tlet worker = workers.tryGet(src);\r\n\t\tif(worker) return worker;\r\n\r\n\t\tconst scripts = this._requiredScripts;\r\n\t\tlet evalPath = this.options.evalPath;\r\n\r\n\t\tif(!evalPath)\r\n\t\t{\r\n\t\t\tif(isNodeJS)\r\n\t\t\t\tthrow new Error(\"Can't use NodeJS without eval.js!\");\r\n\t\t\tif(scripts.length)\r\n\t\t\t\tthrow new Error(\"Can't use required scripts without eval.js!\");\r\n\t\t\tif(!URL)\r\n\t\t\t\tthrow new Error(\"Can't create a blob URL in this browser!\");\r\n\t\t}\r\n\r\n\t\tif(isNodeJS || scripts.length || !URL)\r\n\t\t{\r\n\t\t\tworker = workers.getNew(src, <string>evalPath);\r\n\t\t\tworker.postMessage(src);\r\n\t\t}\r\n\t\telse if(URL)\r\n\t\t{\r\n\t\t\tconst blob = new Blob([src], {type: 'text/javascript'});\r\n\t\t\tconst url = URL.createObjectURL(blob);\r\n\r\n\t\t\tworker = workers.getNew(src, url);\r\n\t\t}\r\n\r\n\t\treturn worker;\r\n\t}\r\n\r\n\t/**\r\n\t * Schedules the task to be run in the worker pool.\r\n\t * @param data\r\n\t * @param task\r\n\t * @param env\r\n\t * @returns {TSDNPromise<U>|TSDNPromise}\r\n\t */\r\n\tstartNew<T,U>(data:T, task:(data:T) => U, env?:any):TSDNPromise<U>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst maxConcurrency = this.ensureClampedMaxConcurrency();\r\n\r\n\t\tconst worker = maxConcurrency ? _._spawnWorker(task, extend(_.options.env, env || {})) : null;\r\n\t\tif(worker)\r\n\t\t{\r\n\t\t\treturn new WorkerPromise<U>(worker, data)\r\n\t\t\t\t.finallyThis(() => workers.recycle(worker));\r\n\t\t}\r\n\r\n\t\tif(_.options.allowSynchronous)\r\n\t\t\treturn this.startLocal(data, task);\r\n\r\n\t\tthrow new Error(maxConcurrency\r\n\t\t\t?\"Workers do not exist and synchronous operation not allowed!\"\r\n\t\t\t:\"'maxConcurrency' set to 0 but 'allowSynchronous' is false.\");\r\n\t}\r\n\r\n\t/**\r\n\t * Runs the task within the local thread/process.\r\n\t * Is good for use with testing.\r\n\t * @param data\r\n\t * @param task\r\n\t * @returns {TSDNPromise<U>|TSDNPromise}\r\n\t */\r\n\tstartLocal<T,U>(data:T, task:(data:T) => U):TSDNPromise<U>\r\n\t{\r\n\t\treturn new TSDNPromise<U>(\r\n\t\t\t(resolve, reject) =>\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tresolve(task(data));\r\n\t\t\t\t}\r\n\t\t\t\tcatch(e)\r\n\t\t\t\t{\r\n\t\t\t\t\treject(e);\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns an array of promises that each resolve after their task completes.\r\n\t * Provides a potential performance benefit by not waiting for all promises to resolve before proceeding to next step.\r\n\t * @param data\r\n\t * @param task\r\n\t * @param env\r\n\t * @returns {PromiseCollection}\r\n\t */\r\n\tpipe<T,U>(data:T[], task:(data:T) => U, env?:any):PromiseCollection<U>\r\n\t{\r\n\r\n\t\t// The resultant promise collection will make an internal copy...\r\n\t\tlet result:TSDNPromise<U>[]|undefined;\r\n\r\n\t\tif(data && data.length)\r\n\t\t{\r\n\t\t\tconst len = data.length;\r\n\t\t\tconst taskString = task.toString();\r\n\t\t\tconst maxConcurrency = this.ensureClampedMaxConcurrency();\r\n\t\t\tlet error:any;\r\n\t\t\tlet i = 0;\r\n\t\t\tfor(let w = 0; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker:WorkerLike|null|undefined = maxConcurrency ? this._spawnWorker(taskString, env) : null;\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error(maxConcurrency\r\n\t\t\t\t\t\t\t?\"Workers do not exist and synchronous operation not allowed!\"\r\n\t\t\t\t\t\t\t:\"'maxConcurrency' set to 0 but 'allowSynchronous' is false.\");\r\n\r\n\t\t\t\t\t// Concurrency doesn't matter in a single thread... Just queue it all up.\r\n\t\t\t\t\treturn TSDNPromise.map(data, task);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif(!result)\r\n\t\t\t\t{\r\n\t\t\t\t\t// There is a small risk that the consumer could call .resolve() which would result in a double resolution.\r\n\t\t\t\t\t// But it's important to minimize the number of objects created.\r\n\t\t\t\t\tresult = data.map(d => new TSDNPromise<U>());\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = () =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t//noinspection JSReferencingMutableVariableFromClosure\r\n\t\t\t\t\t\t\tlet ii = i++, p = result![ii];\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise<U>(worker, data[ii]);\r\n\t\t\t\t\t\t\t//noinspection JSIgnoredPromiseFromCall\r\n\t\t\t\t\t\t\twp.thenSynchronous(\r\n\t\t\t\t\t\t\t\tr =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t//noinspection JSIgnoredPromiseFromCall\r\n\t\t\t\t\t\t\t\t\tp.resolve(r);\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\te =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\t//noinspection JSIgnoredPromiseFromCall\r\n\t\t\t\t\t\t\t\t\t\tp.reject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(() =>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\treturn new PromiseCollection<U>(result);\r\n\t}\r\n\r\n\tprivate ensureClampedMaxConcurrency():number\r\n\t{\r\n\t\tlet {maxConcurrency} = this.options;\r\n\t\tif(maxConcurrency && maxConcurrency>MAX_WORKERS)\r\n\t\t{\r\n\t\t\tthis.options.maxConcurrency = maxConcurrency = MAX_WORKERS;\r\n\t\t\tconsole.warn(`More than ${MAX_WORKERS} workers can reach worker limits and cause unexpected results.  maxConcurrency reduced to ${MAX_WORKERS}.`);\r\n\t\t}\r\n\t\treturn (maxConcurrency || maxConcurrency===0) ? maxConcurrency : MAX_WORKERS;\r\n\t}\r\n\r\n\t/**\r\n\t * Waits for all tasks to resolve and returns a promise with the results.\r\n\t * @param data\r\n\t * @param task\r\n\t * @param env\r\n\t * @returns {ArrayPromise}\r\n\t */\r\n\tmap<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\tif(!data || !data.length)\r\n\t\t\treturn ArrayPromise.fulfilled(data && []);\r\n\r\n\t\t// Would return the same result, but has extra overhead.\r\n\t\t// return this.pipe(data,task).all();\r\n\r\n\t\tdata = data.slice(); // Never use the original.\r\n\t\treturn new ArrayPromise<U>((resolve, reject) =>\r\n\t\t{\r\n\t\t\tconst result:U[] = [], len = data.length;\r\n\t\t\tresult.length = len;\r\n\r\n\t\t\tconst taskString = task.toString();\r\n\t\t\tlet maxConcurrency = this.ensureClampedMaxConcurrency(), error:any;\r\n\t\t\tlet i = 0, resolved = 0;\r\n\t\t\tfor(let w = 0; !error && i<Math.min(len, maxConcurrency); w++)\r\n\t\t\t{\r\n\t\t\t\tlet worker:WorkerLike|null|undefined = this._spawnWorker(taskString, env);\r\n\r\n\t\t\t\tif(!worker)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!this.options.allowSynchronous)\r\n\t\t\t\t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n\r\n\t\t\t\t\t// Concurrency doesn't matter in a single thread... Just queue it all up.\r\n\t\t\t\t\tresolve(TSDNPromise.map(data, task).all());\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet next = () =>\r\n\t\t\t\t{\r\n\t\t\t\t\tif(error)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tif(worker)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif(i<len)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet ii = i++;\r\n\t\t\t\t\t\t\tlet wp = new WorkerPromise<U>(worker, data[ii]);\r\n\t\t\t\t\t\t\t//noinspection JSIgnoredPromiseFromCall\r\n\t\t\t\t\t\t\twp.thenSynchronous(\r\n\t\t\t\t\t\t\t\tr =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresult[ii] = <any>r;\r\n\t\t\t\t\t\t\t\t\tnext();\r\n\t\t\t\t\t\t\t\t},\r\n\t\t\t\t\t\t\t\te =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tif(!error)\r\n\t\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\t\terror = e;\r\n\t\t\t\t\t\t\t\t\t\treject(e);\r\n\t\t\t\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.thenThis(() =>\r\n\t\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\t\tresolved++;\r\n\t\t\t\t\t\t\t\t\tif(resolved>len) throw Error(\"Resolved count exceeds data length.\");\r\n\t\t\t\t\t\t\t\t\tif(resolved===len) resolve(result);\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t\t.finallyThis(() =>\r\n\t\t\t\t\t\t\t\t\twp.dispose());\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tworker = workers.recycle(worker);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t};\r\n\t\t\t\tnext();\r\n\t\t\t}\r\n\r\n\t\t});\r\n\r\n\t}\r\n\r\n\tstatic get isSupported() { return _supports; }\r\n\r\n\tstatic options(options?:ParallelOptions):Parallel\r\n\t{\r\n\t\treturn new Parallel(options);\r\n\t}\r\n\r\n\tstatic require(...required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic requireThese(required:RequireType[]):Parallel\r\n\t{\r\n\t\treturn (new Parallel()).requireThese(required)\r\n\t}\r\n\r\n\tstatic startNew<T,U>(data:T, task:(data:T) => U, env?:any):PromiseBase<U>\r\n\t{\r\n\t\treturn (new Parallel()).startNew(data, task, env);\r\n\t}\r\n\r\n\t//\r\n\t// forEach<T>(data:T[], task:(data:T) => void, env?:any):PromiseBase<void>\r\n\t// {}\r\n\r\n\tstatic map<T,U>(data:T[], task:(data:T) => U, env?:any):ArrayPromise<U>\r\n\t{\r\n\t\treturn (new Parallel()).map(data, task, env);\r\n\t}\r\n}\r\n\r\n//\r\n//\r\n// \tprivate _spawnReduceWorker<N>(\r\n// \t\tdata:any,\r\n// \t\tcb:(data:N) => N,\r\n// \t\tdone:(err?:any, wrk?:WorkerLike)=>void,\r\n// \t\tenv?:any,\r\n// \t\twrk?:WorkerLike)\r\n// \t{\r\n// \t\tconst _ = this;\r\n// \t\tif(!wrk) wrk = _._spawnWorker(cb, env);\r\n//\r\n// \t\tif(wrk!==VOID0)\r\n// \t\t{\r\n// \t\t\tinteract(wrk,\r\n// \t\t\t\tmsg=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\t_.data[_.data.length] = msg.data;\r\n// \t\t\t\t\tdone(null, wrk);\r\n// \t\t\t\t},\r\n// \t\t\t\te=>\r\n// \t\t\t\t{\r\n// \t\t\t\t\twrk.terminate();\r\n// \t\t\t\t\tdone(e, null);\r\n// \t\t\t\t},\r\n// \t\t\t\tdata);\r\n// \t\t}\r\n// \t\telse if(_.options.allowSynchronous)\r\n// \t\t{\r\n// \t\t\tdeferImmediate(()=>\r\n// \t\t\t{\r\n// \t\t\t\t_.data[_.data.length] = cb(data);\r\n// \t\t\t\tdone();\r\n// \t\t\t});\r\n// \t\t}\r\n// \t\telse\r\n// \t\t{\r\n// \t\t\tthrow new Error('Workers do not exist and synchronous operation not allowed!');\r\n// \t\t}\r\n// \t}\r\n//\r\n//\r\n//\r\n//\r\n// \treduce<N>(cb:(data:N[]) => N, env?:any):Parallel<T>\r\n// \t{\r\n// \t\tenv = extend(this.options.env, env || {});\r\n//\r\n// \t\tvar runningWorkers = 0;\r\n// \t\tconst _ = this;\r\n//\r\n//\r\n// \t\t_._operation = new Promise<any>((resolve, reject)=>\r\n// \t\t{\r\n//\r\n// \t\t\tconst done = (err?:any, wrk?:WorkerLike)=>\r\n// \t\t\t{\r\n// \t\t\t\t--runningWorkers;\r\n// \t\t\t\tif(err)\r\n// \t\t\t\t{\r\n// \t\t\t\t\treject(err);\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length===1 && runningWorkers===0)\r\n// \t\t\t\t{\r\n// \t\t\t\t\tresolve(_.data = _.data[0]);\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t\telse if(_.data.length>1)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[0], _.data[1]], cb, done, env, wrk);\r\n// \t\t\t\t\t_.data.splice(0, 2);\r\n// \t\t\t\t}\r\n// \t\t\t\telse\r\n// \t\t\t\t{\r\n// \t\t\t\t\tif(wrk) wrk.terminate();\r\n// \t\t\t\t}\r\n// \t\t\t};\r\n//\r\n// \t\t\tif(_.data.length===1)\r\n// \t\t\t{\r\n// \t\t\t\tresolve(_.data[0]);\r\n// \t\t\t}\r\n// \t\t\telse\r\n// \t\t\t{\r\n// \t\t\t\tfor(var i = 0; i<_.options.maxConcurrency && i<Math.floor(_.data.length/2); ++i)\r\n// \t\t\t\t{\r\n// \t\t\t\t\t++runningWorkers;\r\n// \t\t\t\t\t_._spawnReduceWorker([_.data[i*2], _.data[i*2 + 1]], cb, done, env);\r\n// \t\t\t\t}\r\n//\r\n// \t\t\t\t_.data.splice(0, i*2);\r\n// \t\t\t}\r\n// \t\t}, true);\r\n// \t\treturn this;\r\n//\r\n// \t}\r\n\r\n\r\nexport default Parallel;\r\n"]}