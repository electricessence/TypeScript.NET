{"version":3,"sources":["System/Uri/QueryBuilder.js","System/Uri/QueryBuilder.ts"],"names":["dependencies","factory","module","exports","v","require","undefined","define","amd","Types_1","OrderedStringKeyDictionary_1","Enumerator_1","QueryParams_1","extends_1","__extends","QueryBuilder","_super","query","decodeValues","_this","call","this","importQuery","init","prototype","Type","isString","importFromString","isEnumerableOrArrayLike","importEntries","importMap","values","deserialize","_","parse","key","value","containsKey","prev","getValue","push","setValue","encode","prefixIfNotEmpty","toString","OrderedStringKeyDictionary","Object","defineProperty"],"mappings":"CAAA,SAAWA,EAAcC,GACrB,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,OAAOP,EAAcC,KAEzB,UAAW,UAAW,WAAY,yDAA0D,wCAAyC,gBAAiB,iBAAkB,SAAUI,EAASF,GAC3L;;;;ACJJ,GAAAM,GAAAJ,EAAA,YACAK,EAAAL,EAAA,0DACAM,EAAAN,EAAA,yCAGAO,EAAAP,EAAA,iBACAQ,EAAAR,EAAA,iBAEMS,EAAYD,EAAAA,WAQlBE,EAAA,SAAAC,GAGC,QAAAD,GACCE,EACAC,GAAA,SAAAA,IAAAA,GAAA,EAFD,IAAAC,GAICH,EAAAI,KAAAC,OAAOA,IDIG,OCFVF,GAAKG,YAAYL,EAAOC,GDEPC,EC4EnB,MAvFkCL,GAAAC,EAAAC,GAa1BD,EAAAQ,KAAP,SACCN,EACAC,GAEA,MAFA,UAAAA,IAAAA,GAAA,GAEO,GAAIH,GAAaE,EAAOC,IAGhCH,EAAAS,UAAAF,YAAA,SACCL,EACAC,GAgBA,MAhBA,UAAAA,IAAAA,GAAA,GAGGT,EAAAgB,KAAKC,SAAST,GAEhBI,KAAKM,iBAAyBV,EAAOC,GAE9BP,EAAAiB,wBAAwBX,GAE/BI,KAAKQ,cAAcZ,GAInBI,KAAKS,UAA4Bb,GAG3BI,MAURN,EAAAS,UAAAG,iBAAA,SACCI,EACAC,EACAd,GADA,SAAAc,IAAAA,GAAA,GACA,SAAAd,IAAAA,GAAA,EAEA,IAAMe,GAAIZ,IAkBV,OAjBAT,GAAAsB,MAAMH,EACL,SAACI,EAAKC,GAEL,GAAGH,EAAEI,YAAYF,GACjB,CACC,GAAMG,GAAOL,EAAEM,SAASJ,EACrB,aAAgB,OAClBG,EAAKE,KAAKJ,GAEVH,EAAEQ,SAASN,GAA0BG,EAAMF,QAG5CH,GAAEQ,SAASN,EAAKC,IAElBJ,EACAd,GAEMG,MAORN,EAAAS,UAAAkB,OAAA,SAAOC,GAEN,MAAO/B,GAAA8B,OAAOrB,KAAMsB,IAGrB5B,EAAAS,UAAAoB,SAAA,WAEC,MAAOvB,MAAKqB,UAEd3B,GAvFkCL,EAAAmC,2BAAlC1C,GAAAY,aAAAA,EDkEI+B,OAAOC,eAAe5C,EAAS,cAAgBiC,OAAO,ICuB1DjC,EAAAA,WAAeY","file":"QueryBuilder.js","sourcesContent":["(function (dependencies, factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define(dependencies, factory);\n    }\n})([\"require\", \"exports\", \"../Types\", \"../Collections/Dictionaries/OrderedStringKeyDictionary\", \"../Collections/Enumeration/Enumerator\", \"./QueryParams\", \"../../extends\"], function (require, exports) {\n    \"use strict\";\n    /*!\n     * @author electricessence / https://github.com/electricessence/\n     * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n     */\n    var Types_1 = require(\"../Types\");\n    var OrderedStringKeyDictionary_1 = require(\"../Collections/Dictionaries/OrderedStringKeyDictionary\");\n    var Enumerator_1 = require(\"../Collections/Enumeration/Enumerator\");\n    var QueryParams_1 = require(\"./QueryParams\");\n    var extends_1 = require(\"../../extends\");\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    /**\n     * Provides a means for parsing and building a set of parameters.\n     *\n     * In other languages, dictionaries are not reliable for retaining the order of stored values. So for certainty and flexibility we use an ordered dictionary as a base class.\n     */\n    var QueryBuilder = (function (_super) {\n        __extends(QueryBuilder, _super);\n        function QueryBuilder(query, decodeValues) {\n            if (decodeValues === void 0) { decodeValues = true; }\n            var _this = _super.call(this) || this;\n            _this.importQuery(query, decodeValues);\n            return _this;\n        }\n        QueryBuilder.init = function (query, decodeValues) {\n            if (decodeValues === void 0) { decodeValues = true; }\n            return new QueryBuilder(query, decodeValues);\n        };\n        QueryBuilder.prototype.importQuery = function (query, decodeValues) {\n            if (decodeValues === void 0) { decodeValues = true; }\n            if (Types_1.Type.isString(query)) {\n                this.importFromString(query, decodeValues);\n            }\n            else if (Enumerator_1.isEnumerableOrArrayLike(query)) {\n                this.importEntries(query);\n            }\n            else {\n                this.importMap(query);\n            }\n            return this;\n        };\n        /**\n         * Property parses the components of an URI into their values or array of values.\n         * @param values\n         * @param deserialize\n         * @param decodeValues\n         * @returns {QueryBuilder}\n         */\n        QueryBuilder.prototype.importFromString = function (values, deserialize, decodeValues) {\n            if (deserialize === void 0) { deserialize = true; }\n            if (decodeValues === void 0) { decodeValues = true; }\n            var _ = this;\n            QueryParams_1.parse(values, function (key, value) {\n                if (_.containsKey(key)) {\n                    var prev = _.getValue(key);\n                    if ((prev) instanceof (Array))\n                        prev.push(value);\n                    else\n                        _.setValue(key, [prev, value]);\n                }\n                else\n                    _.setValue(key, value);\n            }, deserialize, decodeValues);\n            return this;\n        };\n        /**\n         * Returns the encoded URI string\n         */\n        QueryBuilder.prototype.encode = function (prefixIfNotEmpty) {\n            return QueryParams_1.encode(this, prefixIfNotEmpty);\n        };\n        QueryBuilder.prototype.toString = function () {\n            return this.encode();\n        };\n        return QueryBuilder;\n    }(OrderedStringKeyDictionary_1.OrderedStringKeyDictionary));\n    exports.QueryBuilder = QueryBuilder;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = QueryBuilder;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\nimport {Type} from \"../Types\";\r\nimport {OrderedStringKeyDictionary} from \"../Collections/Dictionaries/OrderedStringKeyDictionary\";\r\nimport {isEnumerableOrArrayLike} from \"../Collections/Enumeration/Enumerator\";\r\nimport {UriComponent} from \"./UriComponent\";\r\nimport {QueryParam} from \"./QueryParam\";\r\nimport {parse, encode} from \"./QueryParams\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\n/**\r\n * Provides a means for parsing and building a set of parameters.\r\n *\r\n * In other languages, dictionaries are not reliable for retaining the order of stored values. So for certainty and flexibility we use an ordered dictionary as a base class.\r\n */\r\nexport class QueryBuilder extends OrderedStringKeyDictionary<UriComponent.Value|UriComponent.Value[]>\r\n{\r\n\r\n\tconstructor(\r\n\t\tquery:QueryParam.Convertible,\r\n\t\tdecodeValues:boolean = true)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tthis.importQuery(query, decodeValues);\r\n\t}\r\n\r\n\r\n\tstatic init(\r\n\t\tquery:QueryParam.Convertible,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\treturn new QueryBuilder(query, decodeValues);\r\n\t}\r\n\r\n\timportQuery(\r\n\t\tquery:QueryParam.Convertible,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\r\n\t\tif(Type.isString(query))\r\n\t\t{\r\n\t\t\tthis.importFromString(<string>query, decodeValues);\r\n\t\t}\r\n\t\telse if(isEnumerableOrArrayLike(query))\r\n\t\t{\r\n\t\t\tthis.importEntries(query);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis.importMap(<UriComponent.Map>query);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Property parses the components of an URI into their values or array of values.\r\n\t * @param values\r\n\t * @param deserialize\r\n\t * @param decodeValues\r\n\t * @returns {QueryBuilder}\r\n\t */\r\n\timportFromString(\r\n\t\tvalues:string,\r\n\t\tdeserialize:boolean = true,\r\n\t\tdecodeValues:boolean = true):QueryBuilder\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tparse(values,\r\n\t\t\t(key, value)=>\r\n\t\t\t{\r\n\t\t\t\tif(_.containsKey(key))\r\n\t\t\t\t{\r\n\t\t\t\t\tconst prev = _.getValue(key);\r\n\t\t\t\t\tif((prev)instanceof(Array))\r\n\t\t\t\t\t\tprev.push(value);\r\n\t\t\t\t\telse\r\n\t\t\t\t\t\t_.setValue(key, [<UriComponent.Value>prev, value]);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t\t_.setValue(key, value);\r\n\t\t\t},\r\n\t\t\tdeserialize,\r\n\t\t\tdecodeValues);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Returns the encoded URI string\r\n\t */\r\n\tencode(prefixIfNotEmpty?:boolean):string\r\n\t{\r\n\t\treturn encode(this, prefixIfNotEmpty);\r\n\t}\r\n\r\n\ttoString():string\r\n\t{\r\n\t\treturn this.encode();\r\n\t}\r\n}\r\n\r\nexport default QueryBuilder;\r\n"]}