{"version":3,"sources":["System/Collections/Array/Compare.js","System/Collections/Array/Compare.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","validateSize","a","b","len","length","areAllEqual","arrays","strict","equalityComparer","Values","areEqual","Error","first","i","l","Types_1","Type","isBoolean","sort","comparer","Array","areEquivalent","compare"],"mappings":";;;;CAIA,SAAWA,GACP,GAAsB,gBAAXC,SAAiD,gBAAnBA,QAAOC,QAAsB,CAClE,GAAIC,GAAIH,EAAQI,QAASF,QAAoBG,UAANF,IAAiBF,OAAOC,QAAUC,OAElD,kBAAXG,SAAyBA,OAAOC,KAC5CD,QAAQ,UAAW,UAAW,gBAAiB,eAAgBN,IAEpE,SAAUI,EAASF,GAClB,YCGJ,SAAAM,GAAsBC,EAAeC,GAGpC,GAAGD,GAAKC,GAAKD,IAAIC,IAAMD,IAAMC,EAC5B,OAAO,CAGR,KAAID,IAAMC,EACT,OAAO,CAER,IAAIC,GAAMF,EAAEG,MACZ,OAAGD,KAAMD,EAAEE,QACH,EAGC,IAAND,GACK,EAGDA,EAGR,QAAAE,GACCC,EACAC,EACAC,GAEA,GAFA,SAAAA,IAAAA,EAA2CC,EAAOC,WAE9CJ,EACH,KAAM,IAAIK,OAAM,kDACjB,IAAGL,EAAOF,OAAO,EAChB,KAAM,IAAIO,OAAM,8CAEjB,KAAI,GADAC,GAAQN,EAAO,GACXO,EAAI,EAAGC,EAAIR,EAAOF,OAAUU,EAAFD,EAAKA,IAEtC,IAAIH,EAASE,EAAON,EAAOO,GAAIN,EAAQC,GACtC,OAAO,CAET,QAAO,EAGR,QAAAE,GACCT,EAAaC,EACbK,EACAC,GAAA,SAAAA,IAAAA,EAAyCC,EAAOC,SAEhD,IAAIP,GAAMH,EAAaC,EAAGC,EAC1B,IAAGa,EAAAC,KAAKC,UAAUd,GAAM,MAAgBA,EAExC,KAAI,GAAIU,GAAI,EAAKV,EAAFU,EAAOA,IAErB,IAAIL,EAAiBP,EAAEY,GAAIX,EAAEW,GAAIN,GAChC,OAAO,CAGT,QAAO,EAIR,QAAAW,GAAiBjB,EAAakB,GAE7B,IAAIlB,GAAKA,EAAEG,OAAO,EAAG,MAAOH,EAE5B,IAAoBC,GAAhBC,EAAMF,EAAEG,MACTD,GAAI,MACND,EAAI,GAAIkB,OAAMjB,IAGdD,KACAA,EAAEE,OAASD,EAEZ,KAAI,GAAIU,GAAI,EAAKV,EAAFU,EAAOA,IAErBX,EAAEW,GAAKZ,EAAEY,EAIV,OADAX,GAAEgB,KAAKC,GACAjB,EAMR,QAAAmB,GACCpB,EAAaC,EACbiB,GAAA,SAAAA,IAAAA,EAAyBV,EAAOa,QAEhC,IAAInB,GAAMH,EAAaC,EAAGC,EAC1B,IAAGa,EAAAC,KAAKC,UAAUd,GAAM,MAAgBA,EAIxCF,GAAIiB,EAAKjB,EAAGkB,GACZjB,EAAIgB,EAAKhB,EAAGiB,EAEZ,KAAI,GAAIN,GAAI,EAAKV,EAAFU,EAAOA,IAErB,GAA0B,IAAvBM,EAASlB,EAAEY,GAAIX,EAAEW,IACnB,OAAO,CAGT,QAAO,EA9GR,GAAYJ,GAAMb,EAAM,iBACxBmB,EAAAnB,EAAmB,cA+BHF,GAAAW,YAAWA,EAkBXX,EAAAgB,SAAQA,EA0CRhB,EAAA2B,cAAaA","file":"System/Collections/Array/Compare.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"../../Compare\", \"../../Types\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Values = require(\"../../Compare\");\n    var Types_1 = require(\"../../Types\");\n    function validateSize(a, b) {\n        if (a && b && a === b || !a && !b)\n            return true;\n        if (!a || !b)\n            return false;\n        var len = a.length;\n        if (len !== b.length)\n            return false;\n        if (len === 0)\n            return true;\n        return len;\n    }\n    function areAllEqual(arrays, strict, equalityComparer) {\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n        if (!arrays)\n            throw new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\n        if (arrays.length < 2)\n            throw new Error(\"Cannot compare a set of arrays less than 2.\");\n        var first = arrays[0];\n        for (var i = 0, l = arrays.length; i < l; i++) {\n            if (!areEqual(first, arrays[i], strict, equalityComparer))\n                return false;\n        }\n        return true;\n    }\n    exports.areAllEqual = areAllEqual;\n    function areEqual(a, b, strict, equalityComparer) {\n        if (equalityComparer === void 0) { equalityComparer = Values.areEqual; }\n        var len = validateSize(a, b);\n        if (Types_1.Type.isBoolean(len))\n            return len;\n        for (var i = 0; i < len; i++) {\n            if (!equalityComparer(a[i], b[i], strict))\n                return false;\n        }\n        return true;\n    }\n    exports.areEqual = areEqual;\n    function sort(a, comparer) {\n        if (!a || a.length < 2)\n            return a;\n        var len = a.length, b;\n        if (len > 65536)\n            b = new Array(len);\n        else {\n            b = [];\n            b.length = len;\n        }\n        for (var i = 0; i < len; i++) {\n            b[i] = a[i];\n        }\n        b.sort(comparer);\n        return b;\n    }\n    function areEquivalent(a, b, comparer) {\n        if (comparer === void 0) { comparer = Values.compare; }\n        var len = validateSize(a, b);\n        if (Types_1.Type.isBoolean(len))\n            return len;\n        a = sort(a, comparer);\n        b = sort(b, comparer);\n        for (var i = 0; i < len; i++) {\n            if (comparer(a[i], b[i]) !== 0)\n                return false;\n        }\n        return true;\n    }\n    exports.areEquivalent = areEquivalent;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport * as Values from \"../../Compare\";\r\nimport {Type} from \"../../Types\";\r\nimport {Primitive} from \"../../Primitive\";\r\nimport {EqualityComparison, Comparison} from \"../../FunctionTypes\";\r\nimport {IArray} from \"./IArray\";\r\nimport {IComparable} from \"../../IComparable\";\r\n\r\n/*  validateSize: Utility for quick validation/invalidation of array equality.\r\n\tWhy this way?  Why not pass a closure for the last return?\r\n\tReason: Performance and avoiding the creation of new functions/closures. */\r\nfunction validateSize(a:IArray<any>, b:IArray<any>):any\r\n{\r\n\t// Both valid and are same object, or both are null/undefined.\r\n\tif(a && b && a===b || !a && !b)\r\n\t\treturn true;\r\n\r\n\t// At this point, at least one has to be non-null.\r\n\tif(!a || !b)\r\n\t\treturn false;\r\n\r\n\tvar len = a.length;\r\n\tif(len!==b.length)\r\n\t\treturn false;\r\n\r\n\t// If both are arrays and have zero length, they are equal.\r\n\tif(len===0)\r\n\t\treturn true;\r\n\r\n\t// Return the length for downstream processing.\r\n\treturn len;\r\n}\r\n\r\nexport function areAllEqual(\r\n\tarrays:any[][],\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<any> = Values.areEqual):boolean\r\n{\r\n\tif(!arrays)\r\n\t\tthrow new Error(\"ArgumentNullException: 'arrays' cannot be null.\");\r\n\tif(arrays.length<2)\r\n\t\tthrow new Error(\"Cannot compare a set of arrays less than 2.\");\r\n\tvar first = arrays[0];\r\n\tfor(let i = 0, l = arrays.length; i<l; i++)\r\n\t{\r\n\t\tif(!areEqual(first, arrays[i], strict, equalityComparer))\r\n\t\t\treturn false;\r\n\t}\r\n\treturn true;\r\n}\r\n\r\nexport function areEqual<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tstrict?:boolean,\r\n\tequalityComparer:EqualityComparison<T> = Values.areEqual):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(!equalityComparer(a[i], b[i], strict))\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n\r\nfunction sort<T>(a:IArray<T>, comparer:Comparison<T>):IArray<T>\r\n{\r\n\tif(!a || a.length<2) return a;\r\n\r\n\tvar len = a.length, b:T[];\r\n\tif(len>65536)\r\n\t\tb = new Array(len);\r\n\telse\r\n\t{\r\n\t\tb = [];\r\n\t\tb.length = len;\r\n\t}\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tb[i] = a[i];\r\n\t}\r\n\r\n\tb.sort(comparer);\r\n\treturn b;\r\n}\r\n\r\nexport function areEquivalent<T extends Primitive>(a:IArray<T>, b:IArray<T>):boolean;\r\nexport function areEquivalent<T>(a:IArray<IComparable<T>>, b:IArray<IComparable<T>>):boolean;\r\nexport function areEquivalent<T>(a:IArray<T>, b:IArray<T>, comparer:Comparison<T>):boolean;\r\nexport function areEquivalent<T>(\r\n\ta:IArray<T>, b:IArray<T>,\r\n\tcomparer:Comparison<T> = Values.compare):boolean\r\n{\r\n\tvar len = validateSize(a, b);\r\n\tif(Type.isBoolean(len)) return <boolean>len;\r\n\r\n\t// There might be a better more performant way to do this, but for the moment, this\r\n\t// works quite well.\r\n\ta = sort(a, comparer);\r\n\tb = sort(b, comparer);\r\n\r\n\tfor(let i = 0; i<len; i++)\r\n\t{\r\n\t\tif(comparer(a[i], b[i])!==0)\r\n\t\t\treturn false;\r\n\t}\r\n\r\n\treturn true;\r\n\r\n}\r\n"]}