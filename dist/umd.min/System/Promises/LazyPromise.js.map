{"version":3,"sources":["System/Promises/LazyPromise.js","System/Promises/LazyPromise.ts"],"names":["factory","module","exports","v","require","undefined","define","amd","Promise_1","defer_1","ArgumentNullException_1","extends_1","__extends","VOID0","LazyPromise","_super","_resolver","call","this","ArgumentNullException","_resolvedCalled","prototype","_onDispose","_onThen","r","resolveUsing","thenSynchronous","onFulfilled","onRejected","thenThis","delayFromNow","milliseconds","_this","throwIfDisposed","isSettled","pass","timedOut","timeout","defer","resolve","reject","e","dispose","delayAfterResolve","finalize","detector","isPending","Promise","Object","defineProperty","value"],"mappings":"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","file":"System/Promises/LazyPromise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n(function (factory) {\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        var v = factory(require, exports); if (v !== undefined) module.exports = v;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        define([\"require\", \"exports\", \"./Promise\", \"../Threading/defer\", \"../Exceptions/ArgumentNullException\", \"../../extends\"], factory);\n    }\n})(function (require, exports) {\n    \"use strict\";\n    var Promise_1 = require(\"./Promise\");\n    var defer_1 = require(\"../Threading/defer\");\n    var ArgumentNullException_1 = require(\"../Exceptions/ArgumentNullException\");\n    var extends_1 = require(\"../../extends\");\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    var LazyPromise = (function (_super) {\n        __extends(LazyPromise, _super);\n        function LazyPromise(_resolver) {\n            _super.call(this);\n            this._resolver = _resolver;\n            if (!_resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            this._resolvedCalled = true;\n        }\n        LazyPromise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolver = VOID0;\n        };\n        LazyPromise.prototype._onThen = function () {\n            var r = this._resolver;\n            if (r) {\n                this._resolver = VOID0;\n                this._resolvedCalled = false;\n                this.resolveUsing(r);\n            }\n        };\n        LazyPromise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this._onThen();\n            return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n        };\n        LazyPromise.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayFromNow.call(this, milliseconds);\n            var pass;\n            var timedOut = false;\n            var timeout = defer_1.defer(function () {\n                timedOut = true;\n                if (pass)\n                    pass();\n            }, milliseconds);\n            return new LazyPromise(function (resolve, reject) {\n                pass = function () {\n                    _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    timeout.dispose();\n                    timeout = null;\n                    pass = null;\n                };\n                if (timedOut)\n                    pass();\n            });\n        };\n        LazyPromise.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (!this._resolver || this.isSettled)\n                return _super.prototype.delayAfterResolve.call(this, milliseconds);\n            var pass;\n            var timeout;\n            var finalize = function () {\n                if (timeout) {\n                    timeout.dispose();\n                    timeout = null;\n                }\n                if (pass)\n                    pass();\n                finalize = null;\n            };\n            {\n                var detector = function () {\n                    if (finalize)\n                        timeout = defer_1.defer(finalize, milliseconds);\n                };\n                _super.prototype.thenThis.call(this, detector, detector);\n                detector = null;\n            }\n            return new LazyPromise(function (resolve, reject) {\n                if (_this.isPending) {\n                    _this.thenThis(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n                    finalize();\n                }\n                else {\n                    pass = function () {\n                        _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                    };\n                    if (!finalize)\n                        pass();\n                }\n            });\n        };\n        return LazyPromise;\n    }(Promise_1.Promise));\n    exports.LazyPromise = LazyPromise;\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = LazyPromise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n\r\nimport {Promise, PromiseBase} from \"./Promise\";\r\nimport {Closure} from \"../FunctionTypes\";\r\nimport {ICancellable} from \"../Threading/ICancellable\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport __extendsImport from \"../../extends\";\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void 0;\r\n\r\n/**\r\n * A promise that waits for the first then to trigger the resolver.\r\n */\r\nexport class LazyPromise<T> extends Promise<T>\r\n{\r\n\r\n\tconstructor(private _resolver:Promise.Executor<T>)\r\n\t{\r\n\t\tsuper();\r\n\t\tif(!_resolver) throw new ArgumentNullException(\"resolver\");\r\n\t\tthis._resolvedCalled = true;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolver = VOID0;\r\n\t}\r\n\r\n\tprivate _onThen():void\r\n\t{\r\n\t\tvar r = this._resolver;\r\n\t\tif(r)\r\n\t\t{\r\n\t\t\tthis._resolver = VOID0;\r\n\t\t\tthis._resolvedCalled = false;\r\n\t\t\tthis.resolveUsing(r);\r\n\t\t}\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T, TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenSynchronous(onFulfilled, onRejected);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):PromiseBase<T>\r\n\t{\r\n\t\tthis._onThen();\r\n\t\treturn super.thenThis(onFulfilled, onRejected);\r\n\t}\r\n\r\n\t// NOTE: For a LazyPromise we need to be careful not to trigger the resolve for delay.\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a minimum delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayFromNow(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\t\tvar timedOut:boolean = false;\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout = defer(()=>\r\n\t\t\t{\r\n\t\t\t\ttimedOut = true;\r\n\t\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(pass)\r\n\t\t\t\t\tpass();\r\n\t\t\t},\r\n\t\t\tmilliseconds);\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// A lazy promise only enters here if something called for a resolution.\r\n\t\t\t\tpass = ()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\ttimeout.dispose();\r\n\t\t\t\t\ttimeout = null;\r\n\t\t\t\t\tpass = null;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// If the timeout completed already go ahead and pass the request on to the parent.\r\n\t\t\t\tif(timedOut)\r\n\t\t\t\t\tpass();\r\n\t\t\t\t// Otherwise wait for the timeout to do it.\r\n\t\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// If this is already guaranteed to resolve, the go ahead and pass to the super.\r\n\t\tif(!this._resolver || this.isSettled)\r\n\t\t\treturn super.delayAfterResolve(milliseconds);\r\n\r\n\t\t/*\r\n\t\t * If not triggered yet, then we create a special promise\r\n\t\t * that only requests the resolution from the parent promise\r\n\t\t * if a 'then' is called to ensure the lazy pattern.\r\n\t\t */\r\n\t\tvar pass:Closure;\r\n\r\n\r\n\t\t// Setup the timer.\r\n\t\tvar timeout:ICancellable;\r\n\r\n\t\tvar finalize = ()=>\r\n\t\t{\r\n\t\t\tif(timeout)\r\n\t\t\t{\r\n\t\t\t\ttimeout.dispose();\r\n\t\t\t\ttimeout = null;\r\n\t\t\t}\r\n\t\t\t// If the promise was requested already go ahead and pass the request on to the parent.\r\n\t\t\tif(pass)\r\n\t\t\t\tpass();\r\n\r\n\t\t\tfinalize = null;\r\n\t\t};\r\n\r\n\t\t{\r\n\t\t\tlet detector = ()=>\r\n\t\t\t{\r\n\t\t\t\tif(finalize) // We may already be wrapped up so never mind!\r\n\t\t\t\t\ttimeout = defer(finalize, milliseconds);\r\n\t\t\t};\r\n\r\n\t\t\t// Calling super.thenThis does not trigger resolution.\r\n\t\t\t// This simply waits for resolution to happen.\r\n\t\t\t// Is effectively the timer by when resolution has occurred.\r\n\t\t\tsuper.thenThis(detector, detector);\r\n\t\t\tdetector = null;\r\n\t\t}\r\n\r\n\t\treturn new LazyPromise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\t// Because of the lazy nature of this promise, this could enter here at any time.\r\n\t\t\t\tif(this.isPending)\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\t\te=> defer(()=>reject(e), milliseconds)\r\n\t\t\t\t\t);\r\n\t\t\t\t\tfinalize();\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\t// We don't know when this resolved and could have happened anytime after calling this delay method.\r\n\t\t\t\t\tpass = ()=>\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\t\te=> reject(e)\r\n\t\t\t\t\t\t);\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// Already finalized (aka resolved after a timeout)? Go now!\r\n\t\t\t\t\tif(!finalize)\r\n\t\t\t\t\t\tpass();\r\n\t\t\t\t}\r\n\r\n\t\t\t});\r\n\r\n\t}\r\n}\r\n\r\nexport default LazyPromise;"]}