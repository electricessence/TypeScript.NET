{"version":3,"sources":["System/Collections/MapUtility.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAIH;;;;;GAKG;AACH,MAAM,gBACL,MAAQ,EACR,MAAQ;IAER,MAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,GAAG,CAAA,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;QACA,EAAE,CAAA,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC9B,CAAC;YACA,MAAM,CAAC,GAAG,CAAC,GAAS,MAAO,CAAC,GAAG,CAAC,CAAC;QAClC,CAAC;IACF,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAED;;;;;GAKG;AACH,MAAM,iBACL,MAAQ,EACR,QAAU;IAEV,MAAM,MAAM,GAAO,MAAM,IAAI,EAAE,CAAC;IAChC,GAAG,CAAA,CAAC,MAAM,GAAG,IAAI,QAAQ,CAAC,CAC1B,CAAC;QACA,EAAE,CAAA,CAAC,QAAQ,CAAC,cAAc,CAAC,GAAG,CAAC,IAAI,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/D,CAAC;YACA,MAAM,CAAC,GAAG,CAAC,GAAS,QAAS,CAAC,GAAG,CAAC,CAAC;QACpC,CAAC;IACF,CAAC;IACD,MAAM,CAAC,MAAM,CAAC;AACf,CAAC;AAED;;;;GAIG;AACH,MAAM,eAAoC,MAAQ;IAEjD,MAAM,CAAC,KAAK,CAAC,EAAE,EAAE,MAAM,CAAC,CAAC;AAC1B,CAAC;AAGD;;;;;GAKG;AACH,MAAM,gBACL,CAAG,EACH,CAAG;IAEH,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC;AAC1B,CAAC;AAED;;;;GAIG;AACH,MAAM,eAA0C,MAAgB,EAAE,MAAc;IAE/E,GAAG,CAAA,CAAC,MAAM,GAAG,IAAI,MAAM,CAAC,CACxB,CAAC;QACA,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC,cAAc,CAAC,GAAG,CAAC,CAAC,CAC/B,CAAC;YACA,OAAO,MAAM,CAAC,GAAG,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;IACD,qBAAqB;AACtB,CAAC;AAED,MAAM,eAAe,GAAa,EAAE,QAAe,CAAC;IAEnD,EAAE,CAAA,CAAC,GAAG,IAAI,KAAK,CAAC,CAChB,CAAC;QACA,GAAG,CAAA,CAAC,IAAI,GAAG,IAAI,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAChC,CAAC;YACA,MAAM,CAAC,GAAG,GAAG,CAAC,GAAG,CAAC,CAAC;YACnB,OAAO,GAAG,CAAC,GAAG,CAAC,CAAC;YAChB,IAAI,CAAC,CAAC,EAAE,KAAK,GAAG,CAAC,CAAC,CAAC;QACpB,CAAC;IACF,CAAC;AACF,CAAC","file":"MapUtility.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {IMap} from \"../../IMap\";\r\n\r\n/**\r\n * Takes a target object and applies all source values to it.\r\n * @param target\r\n * @param source\r\n * @returns {any}\r\n */\r\nexport function apply<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tsource:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in source)\r\n\t{\r\n\t\tif(source.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>source)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Takes a target object and ensures values exist.\r\n * @param target\r\n * @param defaults\r\n * @returns {any}\r\n */\r\nexport function ensure<T extends IMap<any>, U extends IMap<any>>(\r\n\ttarget:T,\r\n\tdefaults:U):T & U\r\n{\r\n\tconst result:any = target || {};\r\n\tfor(const key in defaults)\r\n\t{\r\n\t\tif(defaults.hasOwnProperty(key) && !result.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tresult[key] = (<any>defaults)[key];\r\n\t\t}\r\n\t}\r\n\treturn result;\r\n}\r\n\r\n/**\r\n * Make a copy of the source object.\r\n * @param source\r\n * @returns {Object}\r\n */\r\nexport function copy<T extends IMap<any>>(source:T):T\r\n{\r\n\treturn apply({}, source);\r\n}\r\n\r\n\r\n/**\r\n * Takes two objects and creates another with the values of both.\r\n * B overwrites A.\r\n * @param a\r\n * @param b\r\n */\r\nexport function merge<A extends IMap<any>, B extends IMap<any>>(\r\n\ta:A,\r\n\tb:B):A & B\r\n{\r\n\treturn apply(copy(a), b);\r\n}\r\n\r\n/**\r\n * Removes any keys that don't exist on the keyMap.\r\n * @param target\r\n * @param keyMap\r\n */\r\nexport function trim<TResult extends IMap<any>>(target:IMap<any>, keyMap:TResult):void //Partial<TResult>\r\n{\r\n\tfor(const key in target)\r\n\t{\r\n\t\tif(!keyMap.hasOwnProperty(key))\r\n\t\t{\r\n\t\t\tdelete target[key];\r\n\t\t}\r\n\t}\r\n\t//return <any>target;\r\n}\r\n\r\nexport function wipe(map:IMap<any>, depth:number = 1):void\r\n{\r\n\tif(map && depth)\r\n\t{\r\n\t\tfor(let key of Object.keys(map))\r\n\t\t{\r\n\t\t\tconst v = map[key];\r\n\t\t\tdelete map[key];\r\n\t\t\twipe(v, depth - 1);\r\n\t\t}\r\n\t}\r\n}"]}