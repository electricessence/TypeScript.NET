{"version":3,"sources":["System/Collections/Array/copy.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAC,UAAU,EAAC,MAAM,cAAc,CAAC;AAExC,OAAO,EAAC,qBAAqB,EAAC,MAAM,wCAAwC,CAAC;AAC7E,OAAO,EAAC,2BAA2B,EAAC,MAAM,8CAA8C,CAAC;AACzF;;;;;;GAMG;AACH,MAAM,eACL,MAAmB,EACnB,cAAqB,CAAC,EACtB,SAAgB,QAAQ;IAExB,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC;QAAC,MAAM,CAAM,MAAM,CAAC,CAAC,4CAA4C;IAC5E,MAAM,CAAC,MAAM,CACZ,MAAM,EACN,UAAU,CAAI,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,WAAW,EAAE,CAAC,CAAC,CAAC,CAAC,EACzE,WAAW,EAAE,CAAC,EAAE,MAAM,CAAC,CAAC;AAC1B,CAAC;AAED,MACC,GAAG,GAAI,iBAAiB,EACxB,IAAI,GAAG,2BAA2B,CAAC;AAEpC;;;;;;;;GAQG;AACH,MAAM,iBACL,MAAmB,EACnB,WAAwB,EACxB,cAAqB,CAAC,EACtB,mBAA0B,CAAC,EAC3B,SAAgB,QAAQ;IAExB,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC;QACV,MAAM,IAAI,qBAAqB,CAAC,QAAQ,EAAE,GAAG,CAAC,CAAC;IAEhD,EAAE,CAAA,CAAC,CAAC,WAAW,CAAC;QACf,MAAM,IAAI,qBAAqB,CAAC,aAAa,EAAE,GAAG,CAAC,CAAC;IAErD,EAAE,CAAA,CAAC,WAAW,GAAC,CAAC,CAAC;QAChB,MAAM,IAAI,2BAA2B,CAAC,aAAa,EAAE,WAAW,EAAE,IAAI,CAAC,CAAC;IAEzE,IAAI,YAAY,GAAG,MAAM,CAAC,MAAM,CAAC;IACjC,EAAE,CAAA,CAAC,CAAC,YAAY,CAAC;QAChB,MAAM,CAAC,WAAW,CAAC;IACpB,EAAE,CAAA,CAAC,WAAW,IAAE,YAAY,CAAC;QAC5B,MAAM,IAAI,2BAA2B,CAAC,aAAa,EAAE,WAAW,EAAE,mDAAmD,CAAC,CAAC;IAExH,EAAE,CAAA,CAAC,WAAW,CAAC,MAAM,GAAC,CAAC,CAAC;QACvB,MAAM,IAAI,2BAA2B,CAAC,kBAAkB,EAAE,gBAAgB,EAAE,IAAI,CAAC,CAAC;IAEnF,MAAM,SAAS,GAAG,MAAM,CAAC,MAAM,GAAG,WAAW,CAAC;IAC9C,EAAE,CAAA,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,MAAM,GAAC,SAAS,CAAC;QACvC,MAAM,IAAI,2BAA2B,CAAC,aAAa,EAAE,WAAW,EAAE,qEAAqE,CAAC,CAAC;IAE1I,MAAM,GAAG,IAAI,CAAC,GAAG,CAAC,MAAM,EAAE,SAAS,CAAC,CAAC;IACrC,MAAM,SAAS,GAAG,gBAAgB,GAAG,MAAM,CAAC;IAC5C,EAAE,CAAA,CAAC,SAAS,GAAC,WAAW,CAAC,MAAM,CAAC;QAAC,WAAW,CAAC,MAAM,GAAG,SAAS,CAAC;IAEhE,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAC,MAAM,EAAE,CAAC,EAAE,EAC5B,CAAC;QACA,WAAW,CAAC,gBAAgB,GAAG,CAAC,CAAC,GAAG,MAAM,CAAC,WAAW,GAAG,CAAC,CAAC,CAAC;IAC7D,CAAC;IAED,MAAM,CAAC,WAAW,CAAC;AACpB,CAAC","file":"copy.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {initialize} from \"./initialize\";\r\nimport {ArrayLikeWritable} from \"./ArrayLikeWritable\";\r\nimport {ArgumentNullException} from \"../../Exceptions/ArgumentNullException\";\r\nimport {ArgumentOutOfRangeException} from \"../../Exceptions/ArgumentOutOfRangeException\";\r\n/**\r\n *\r\n * @param source\r\n * @param sourceIndex\r\n * @param length\r\n * @returns {any}\r\n */\r\nexport function copy<T>(\r\n\tsource:ArrayLike<T>,\r\n\tsourceIndex:number = 0,\r\n\tlength:number = Infinity):T[]\r\n{\r\n\tif(!source) return <any>source; // may have passed zero? undefined? or null?\r\n\treturn copyTo(\r\n\t\tsource,\r\n\t\tinitialize<T>(Math.min(length, Math.max(source.length - sourceIndex, 0))),\r\n\t\tsourceIndex, 0, length);\r\n}\r\n\r\nconst\r\n\tCBN  = 'Cannot be null.',\r\n\tCBL0 = 'Cannot be less than zero.';\r\n\r\n/**\r\n * Copies one array to another.\r\n * @param source\r\n * @param destination\r\n * @param sourceIndex\r\n * @param destinationIndex\r\n * @param length An optional limit to stop copying.\r\n * @returns The destination array.\r\n */\r\nexport function copyTo<T,TDestination extends ArrayLikeWritable<T>>(\r\n\tsource:ArrayLike<T>,\r\n\tdestination:TDestination,\r\n\tsourceIndex:number = 0,\r\n\tdestinationIndex:number = 0,\r\n\tlength:number = Infinity):TDestination\r\n{\r\n\tif(!source)\r\n\t\tthrow new ArgumentNullException('source', CBN);\r\n\r\n\tif(!destination)\r\n\t\tthrow new ArgumentNullException('destination', CBN);\r\n\r\n\tif(sourceIndex<0)\r\n\t\tthrow new ArgumentOutOfRangeException('sourceIndex', sourceIndex, CBL0);\r\n\r\n\tlet sourceLength = source.length;\r\n\tif(!sourceLength)\r\n\t\treturn destination;\r\n\tif(sourceIndex>=sourceLength)\r\n\t\tthrow new ArgumentOutOfRangeException('sourceIndex', sourceIndex, 'Must be less than the length of the source array.');\r\n\r\n\tif(destination.length<0)\r\n\t\tthrow new ArgumentOutOfRangeException('destinationIndex', destinationIndex, CBL0);\r\n\r\n\tconst maxLength = source.length - sourceIndex;\r\n\tif(isFinite(length) && length>maxLength)\r\n\t\tthrow new ArgumentOutOfRangeException('sourceIndex', sourceIndex, 'Source index + length cannot exceed the length of the source array.');\r\n\r\n\tlength = Math.min(length, maxLength);\r\n\tconst newLength = destinationIndex + length;\r\n\tif(newLength>destination.length) destination.length = newLength;\r\n\r\n\tfor(let i = 0; i<length; i++)\r\n\t{\r\n\t\tdestination[destinationIndex + i] = source[sourceIndex + i];\r\n\t}\r\n\r\n\treturn destination;\r\n}\r\n"]}