{"version":3,"sources":["System/Collections/Array/Dispatch.ts"],"names":[],"mappings":"AAAA;;;GAGG;AAEH,OAAO,EAAC,IAAI,EAAC,MAAM,aAAa,CAAC;AACjC,OAAO,EAAC,IAAI,EAAC,MAAM,QAAQ,CAAC;AAG5B,MAAM,KAAK,GAAa,KAAK,CAAC,CAAC;AAO/B;;;;;;;GAOG;AACH,MAAM,mBACL,SAAoC,EACpC,OAAS,EAAE,IAAkC;IAE7C,QAAQ,CAAC,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,EAAE,OAAO,EAAE,IAAI,CAAC,CAAC;AACjD,CAAC;AAED,WAAc,QAAQ;IAErB;;;;;;;;;;;;;;;;;;;;OAoBG;IACH,gBACC,SAAoC,EACpC,OAAS,EAAE,IAAkC;QAE7C,EAAE,CAAA,CAAC,SAAS,IAAI,SAAS,CAAC,MAAM,CAAC,CACjC,CAAC;YACA,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,SAAS,CAAC,MAAM,EAAE,CAAC,GAAC,GAAG,EAAE,CAAC,EAAE,EACjD,CAAC;gBACA,IAAI,EAAE,GAAY,SAAS,CAAC,CAAC,CAAC,CAAC;gBAC/B,EAAE,CAAA,CAAC,CAAC,EAAE,CAAC;oBAAC,QAAQ,CAAC,CAAC,oBAAoB;gBACtC,IACA,CAAC;oBACA,EAAE,CAAC,OAAO,CAAC,CAAC;gBACb,CAAC;gBACD,KAAK,CAAA,CAAC,EAAE,CAAC,CACT,CAAC;oBACA,EAAE,CAAA,CAAC,CAAC,IAAI,CAAC;wBACR,MAAM,EAAE,CAAC;oBACV,IAAI,CAAC,EAAE,CAAA,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBAC7B,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBACd,CAAC;YACF,CAAC;QACF,CAAC;IACF,CAAC;IAvBe,eAAM,SAuBrB,CAAA;IAED;;;;;;;;OAQG;IACH,gBACC,SAAwC,EACxC,OAAS,EAAE,IAAkC;QAG7C,EAAE,CAAA,CAAC,CAAC,SAAS,CAAC;YAAC,MAAM,CAAM,SAAS,CAAC;QACrC,2CAA2C;QAC3C,MAAM,MAAM,GAAS,IAAI,CAAC,SAAS,CAAC,CAAC;QACrC,EAAE,CAAA,CAAC,SAAS,CAAC,MAAM,CAAC,CACpB,CAAC;YAEA,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAC,GAAG,EAAE,CAAC,EAAE,EAC9C,CAAC;gBACA,IAAI,EAAE,GAAY,MAAM,CAAC,CAAC,CAAC,CAAC;gBAC5B,IACA,CAAC;oBACA,MAAM,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,oBAAoB;0BAChC,EAAE,CAAC,OAAO,CAAC;0BACX,KAAK,CAAC;gBACV,CAAC;gBACD,KAAK,CAAA,CAAC,EAAE,CAAC,CACT,CAAC;oBACA,MAAM,CAAC,CAAC,CAAC,GAAG,KAAK,CAAC;oBAClB,EAAE,CAAA,CAAC,CAAC,IAAI,CAAC;wBACR,MAAM,EAAE,CAAC;oBACV,IAAI,CAAC,EAAE,CAAA,CAAC,IAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC;wBAC7B,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC;gBACd,CAAC;YACF,CAAC;QACF,CAAC;QAED,MAAM,CAAC,MAAM,CAAC;IAEf,CAAC;IAjCe,eAAM,SAiCrB,CAAA;AAEF,CAAC,EA5Fa,QAAQ,KAAR,QAAQ,QA4FrB;AAED,eAAe,QAAQ,CAAC","file":"Dispatch.js","sourcesContent":["/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {Type} from \"../../Types\";\r\nimport {copy} from \"./copy\";\r\nimport {Selector} from \"../../FunctionTypes\";\r\n\r\nconst VOID0:undefined = void 0;\r\n\r\nexport interface DispatchErrorHandler\r\n{\r\n\t(ex:any, index:number):void\r\n}\r\n\r\n/**\r\n * Simply takes a payload and passes it to all the listeners.\r\n * Makes a arrayCopy of the listeners before calling dispatchUnsafe.\r\n *\r\n * @param listeners\r\n * @param payload\r\n * @param trap\r\n */\r\nexport function dispatch<T>(\r\n\tlisteners:ArrayLike<Selector<T,any>>,\r\n\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n{\r\n\tdispatch.unsafe(copy(listeners), payload, trap);\r\n}\r\n\r\nexport module dispatch {\r\n\r\n\t/**\r\n\t * Simply takes a payload and passes it to all the listeners.\r\n\t *\r\n\t * While dispatching:\r\n\t * * This is an unsafe method if by chance any of the listeners modify the array.\r\n\t * * It cannot prevent changes to the payload.\r\n\t *\r\n\t * Improving safety:\r\n\t * * Only use a local array that isn't exposed to the listeners.\r\n\t * * Use the dispatch method instead as it makes a arrayCopy of the listeners array.\r\n\t * * Freeze the listeners array so it can't be modified.\r\n\t * * Freeze the payload.\r\n\t *\r\n\t * Specifying trap will catch any errors and pass them along if trap is a function.\r\n\t * A payload is used instead of arguments for easy typing.\r\n\t *\r\n\t *\r\n\t * @param listeners\r\n\t * @param payload\r\n\t * @param trap\r\n\t */\r\n\texport function unsafe<T>(\r\n\t\tlisteners:ArrayLike<Selector<T,any>>,\r\n\t\tpayload:T, trap?:boolean|DispatchErrorHandler):void\r\n\t{\r\n\t\tif(listeners && listeners.length)\r\n\t\t{\r\n\t\t\tfor(let i = 0, len = listeners.length; i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet fn:Function = listeners[i];\r\n\t\t\t\tif(!fn) continue; // Ignore null refs.\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tfn(payload);\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tif(!trap)\r\n\t\t\t\t\t\tthrow ex;\r\n\t\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\t\ttrap(ex, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Simply takes a payload and passes it to all the listeners.\r\n\t * Returns the results in an array that matches the indexes of the listeners.\r\n\t *\r\n\t * @param listeners\r\n\t * @param payload\r\n\t * @param trap\r\n\t * @returns {any}\r\n\t */\r\n\texport function mapped<T,TResult>(\r\n\t\tlisteners:ArrayLike<Selector<T,TResult>>,\r\n\t\tpayload:T, trap?:boolean|DispatchErrorHandler):TResult[]\r\n\t{\r\n\r\n\t\tif(!listeners) return <any>listeners;\r\n\t\t// Reuse the arrayCopy as the array result.\r\n\t\tconst result:any[] = copy(listeners);\r\n\t\tif(listeners.length)\r\n\t\t{\r\n\r\n\t\t\tfor(let i = 0, len = result.length; i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet fn:Function = result[i];\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = fn // Ignore null refs.\r\n\t\t\t\t\t\t? fn(payload)\r\n\t\t\t\t\t\t: VOID0;\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = VOID0;\r\n\t\t\t\t\tif(!trap)\r\n\t\t\t\t\t\tthrow ex;\r\n\t\t\t\t\telse if(Type.isFunction(trap))\r\n\t\t\t\t\t\ttrap(ex, i);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn result;\r\n\r\n\t}\r\n\r\n}\r\n\r\nexport default dispatch;"]}