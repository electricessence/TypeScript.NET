{"version":3,"sources":["System/Collections/Array/Sorting/mergeSort.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAGH,OAAO,EAAC,qBAAqB,EAAC,MAAM,2CAA2C,CAAC;AAChF,OAAO,EAAC,UAAU,EAAC,MAAM,YAAY,CAAC;AAGtC;;;;;GAKG;AACH,MAAM,oBAA8E,MAAa;IAEhG,EAAE,CAAA,CAAC,CAAC,MAAM,CAAC;QAAC,MAAM,IAAI,qBAAqB,CAAC,QAAQ,CAAC,CAAC;IACtD,MAAM,GAAG,GAAG,MAAM,CAAC,MAAM,CAAC;IAC1B,MAAM,CAAC,GAAG,GAAC,CAAC,GAAG,MAAM,GAAG,IAAI,CAAC,MAAM,EAAE,CAAC,EAAE,GAAG,EAAE,UAAU,CAAI,GAAG,CAAC,CAAC,CAAC;AAClE,CAAC;AAED,cACC,MAAa,EACb,KAAY,EACZ,GAAU,EACV,IAAyB;IAEzB,EAAE,CAAA,CAAC,GAAG,GAAG,KAAK,GAAC,CAAC,CAAC,CACjB,CAAC;QACA,yCAAyC;QACzC,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,KAAK,GAAG,GAAG,CAAC,GAAC,CAAC,CAAC,CAAC;QAC3C,IAAI,CAAC,MAAM,EAAE,KAAK,EAAE,MAAM,EAAE,IAAI,CAAC,CAAC;QAClC,IAAI,CAAC,MAAM,EAAE,MAAM,EAAE,GAAG,EAAE,IAAI,CAAC,CAAC;QAEhC,kCAAkC;QAClC,GAAG,CAAA,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,GAAG,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,GAAC,GAAG,EAAE,CAAC,EAAE,EAC9C,CAAC;YACA,IAAI,CAAC,CAAC,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;QACrB,CAAC;QAED,uCAAuC;QACvC,IAAI,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,KAAK,EAAE,CAAC,GAAG,MAAM,CAAC;QAErC,gEAAgE;QAChE,OAAM,CAAC,GAAC,MAAM,IAAI,CAAC,GAAC,GAAG,EACvB,CAAC;YACA,MAAM,CAAC,CAAC,EAAE,CAAC;kBACR,IAAI,CAAC,CAAC,CAAC,GAAC,IAAI,CAAC,CAAC,CAAC;sBACf,IAAI,CAAC,CAAC,EAAE,CAAC;sBACT,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;QACd,CAAC;QAED,sEAAsE;QACtE,OAAM,CAAC,GAAC,MAAM,EACd,CAAC;YACA,MAAM,CAAC,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,CAAC,EAAE,CAAC,CAAC;QACzB,CAAC;IAEF,CAAC;IAED,MAAM,CAAC,MAAM,CAAA;AACd,CAAC","file":"mergeSort.js","sourcesContent":["/*!\r\n * @author Sebastian Belmar / https://github.com/sebabelmar/\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n * https://en.wikipedia.org/wiki/Merge_sort\r\n */\r\n\r\nimport {Primitive} from \"../../../Primitive\";\r\nimport {ArgumentNullException} from \"../../../Exceptions/ArgumentNullException\";\r\nimport {initialize} from \"../Utility\";\r\nimport {ArrayLikeWritable} from \"../ArrayLikeWritable\";\r\n\r\n/**\r\n * Merge internalSort O(n log (n))\r\n * Warning: Uses recursion.\r\n * @param target\r\n * @returns {number[]}\r\n */\r\nexport function mergeSort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(target:TArray):TArray\r\n{\r\n\tif(!target) throw new ArgumentNullException(\"target\");\r\n\tconst len = target.length;\r\n\treturn len<2 ? target : sort(target, 0, len, initialize<T>(len));\r\n}\r\n\r\nfunction sort<T extends Primitive, TArray extends ArrayLikeWritable<T>>(\r\n\ttarget:TArray,\r\n\tstart:number,\r\n\tend:number,\r\n\ttemp:ArrayLikeWritable<T>):TArray\r\n{\r\n\tif(end - start>1)\r\n\t{\r\n\t\t// Step 1: Sort the left and right parts.\r\n\t\tconst middle = Math.floor((start + end)/2);\r\n\t\tsort(target, start, middle, temp);\r\n\t\tsort(target, middle, end, temp);\r\n\r\n\t\t// Step 2: Copy the original array\r\n\t\tfor(let i = 0, len = target.length; i<len; i++)\r\n\t\t{\r\n\t\t\ttemp[i] = target[i];\r\n\t\t}\r\n\r\n\t\t// Step 3: Create variables to traverse\r\n\t\tlet k = start, i = start, j = middle;\r\n\r\n\t\t// Step 4: Merge: Move from the temp to target integers in order\r\n\t\twhile(i<middle && j<end)\r\n\t\t{\r\n\t\t\ttarget[k++]\r\n\t\t\t\t= temp[i]>temp[j]\r\n\t\t\t\t? temp[j++]\r\n\t\t\t\t: temp[i++];\r\n\t\t}\r\n\r\n\t\t// Step 5: Finalize merging in case right side of the array is bigger.\r\n\t\twhile(i<middle)\r\n\t\t{\r\n\t\t\ttarget[k++] = temp[i++];\r\n\t\t}\r\n\r\n\t}\r\n\r\n\treturn target\r\n}\r\n"]}