{"version":3,"sources":["System/Promises/Promise.js","System/Promises/Promise.ts"],"names":["define","require","exports","Types_1","deferImmediate_1","DisposableBase_1","InvalidOperationException_1","ArgumentException_1","ArgumentNullException_1","ObjectPool_1","Set_1","defer_1","ObjectDisposedException_1","extends_1","isPromise","value","hasMemberOfType","THEN","FUNCTION","resolve","resolver","promiseFactory","nextValue","Promise","wrap","handleResolution","p","v","ex","reject","handleResolutionMethods","targetFulfill","targetReject","handleDispatch","onFulfilled","onRejected","PromiseBase","thenThis","then","handleSyncIfPossible","thenSynchronous","newODE","ObjectDisposedException","__extends","VOID0","NULL","PROMISE","PROMISE_STATE","TARGET","PromiseState","_super","_state","_result","_error","call","this","_disposableObjectName","prototype","_onDispose","getState","Object","defineProperty","get","enumerable","configurable","State","Pending","Fulfilled","Rejected","getResult","throwIfDisposed","getError","DisposableBase","_this","result","error","thenAllowFatal","done","defer","delayFromNow","milliseconds","e","delayAfterResolve","isSettled","catchAllowFatal","fin","finallyAllowFatal","finallyThis","synchronous","f","deferImmediate","Resolvable","apply","arguments","state","Error","Resolved","PromiseWrapper","_target","ArgumentNullException","ArgumentException","t","forceSynchronous","resolveUsing","_waiting","push","pools","PromiseCallbacks","init","_resolvedCalled","throwIfSettled","InvalidOperationException","rejectHandler","reason","console","warn","fulfillHandler","_emitDisposalRejection","d","wasDisposed","_rejectInternal","_resolveInternal","r","o","_i","o_1","length","c","promise","recycle","o_2","ArrayPromise","map","transform","reduce","reduction","initialValue","fulfilled","PromiseCollection","source","_source","slice","all","race","waitAll","pipe","previous","current","i","array","getPool","pool","ObjectPool","factory","take","add","group","first","rest","Array","isArray","concat","promises","every","len","remaining","Set","cleanup","dispose","checkIfShouldResolve","count","onFulfill","remove","onReject","_loop_1","onResolved","_loop_2","filter","onResolve","promises_1","p_1","using","resolveAll","j","target","createFrom","freeze"],"mappings":"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","file":"System/Promises/Promise.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n * Although most of the following code is written from scratch, it is\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\n */\ndefine([\"require\", \"exports\", \"../Types\", \"../Threading/deferImmediate\", \"../Disposable/DisposableBase\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentException\", \"../Exceptions/ArgumentNullException\", \"../Disposable/ObjectPool\", \"../Collections/Set\", \"../Threading/defer\", \"../Disposable/ObjectDisposedException\", \"../../extends\"], function (require, exports, Types_1, deferImmediate_1, DisposableBase_1, InvalidOperationException_1, ArgumentException_1, ArgumentNullException_1, ObjectPool_1, Set_1, defer_1, ObjectDisposedException_1, extends_1) {\n    \"use strict\";\n    var __extends = extends_1.default;\n    var VOID0 = void 0, NULL = null, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\n    function isPromise(value) {\n        return Types_1.default.hasMemberOfType(value, THEN, Types_1.default.FUNCTION);\n    }\n    function resolve(value, resolver, promiseFactory) {\n        var nextValue = resolver\n            ? resolver(value)\n            : value;\n        return nextValue && isPromise(nextValue)\n            ? Promise.wrap(nextValue)\n            : promiseFactory(nextValue);\n    }\n    function handleResolution(p, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (p)\n                p.resolve(v);\n            return null;\n        }\n        catch (ex) {\n            if (p)\n                p.reject(ex);\n            return ex;\n        }\n    }\n    function handleResolutionMethods(targetFulfill, targetReject, value, resolver) {\n        try {\n            var v = resolver ? resolver(value) : value;\n            if (targetFulfill)\n                targetFulfill(v);\n        }\n        catch (ex) {\n            if (targetReject)\n                targetReject(ex);\n        }\n    }\n    function handleDispatch(p, onFulfilled, onRejected) {\n        if (p instanceof PromiseBase)\n            p.thenThis(onFulfilled, onRejected);\n        else\n            p.then(onFulfilled, onRejected);\n    }\n    function handleSyncIfPossible(p, onFulfilled, onRejected) {\n        if (p instanceof PromiseBase)\n            return p.thenSynchronous(onFulfilled, onRejected);\n        else\n            return p.then(onFulfilled, onRejected);\n    }\n    function newODE() {\n        return new ObjectDisposedException_1.ObjectDisposedException(\"Promise\", \"An underlying promise-result was disposed.\");\n    }\n    var PromiseState = (function (_super) {\n        __extends(PromiseState, _super);\n        function PromiseState(_state, _result, _error) {\n            _super.call(this);\n            this._state = _state;\n            this._result = _result;\n            this._error = _error;\n            this._disposableObjectName = PROMISE_STATE;\n        }\n        PromiseState.prototype._onDispose = function () {\n            this._state = VOID0;\n            this._result = VOID0;\n            this._error = VOID0;\n        };\n        PromiseState.prototype.getState = function () {\n            return this._state;\n        };\n        Object.defineProperty(PromiseState.prototype, \"state\", {\n            get: function () {\n                return this._state;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isPending\", {\n            get: function () {\n                return this.getState() === Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isSettled\", {\n            get: function () {\n                return this.getState() != Promise.State.Pending;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isFulfilled\", {\n            get: function () {\n                return this.getState() === Promise.State.Fulfilled;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        Object.defineProperty(PromiseState.prototype, \"isRejected\", {\n            get: function () {\n                return this.getState() === Promise.State.Rejected;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getResult = function () {\n            return this._result;\n        };\n        Object.defineProperty(PromiseState.prototype, \"result\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getResult();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseState.prototype.getError = function () {\n            return this._error;\n        };\n        Object.defineProperty(PromiseState.prototype, \"error\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this.getError();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        return PromiseState;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseState = PromiseState;\n    var PromiseBase = (function (_super) {\n        __extends(PromiseBase, _super);\n        function PromiseBase() {\n            _super.call(this, Promise.State.Pending);\n            this._disposableObjectName = PROMISE;\n        }\n        PromiseBase.prototype.then = function (onFulfilled, onRejected) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new Promise(function (resolve, reject) {\n                _this.thenThis(function (result) {\n                    return handleResolutionMethods(resolve, reject, result, onFulfilled);\n                }, function (error) {\n                    return onRejected\n                        ? handleResolutionMethods(resolve, reject, error, onRejected)\n                        : reject(error);\n                });\n            });\n        };\n        PromiseBase.prototype.thenAllowFatal = function (onFulfilled, onRejected) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new Promise(function (resolve, reject) {\n                _this.thenThis(function (result) {\n                    return resolve((onFulfilled ? onFulfilled(result) : result));\n                }, function (error) {\n                    return reject(onRejected ? onRejected(error) : error);\n                });\n            });\n        };\n        PromiseBase.prototype.done = function (onFulfilled, onRejected) {\n            var _this = this;\n            defer_1.defer(function () {\n                return _this.thenThis(onFulfilled, onRejected);\n            });\n        };\n        PromiseBase.prototype.delayFromNow = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            return new Promise(function (resolve, reject) {\n                defer_1.defer(function () {\n                    _this.thenThis(function (v) { return resolve(v); }, function (e) { return reject(e); });\n                }, milliseconds);\n            }, true);\n        };\n        PromiseBase.prototype.delayAfterResolve = function (milliseconds) {\n            var _this = this;\n            if (milliseconds === void 0) { milliseconds = 0; }\n            this.throwIfDisposed();\n            if (this.isSettled)\n                return this.delayFromNow(milliseconds);\n            return new Promise(function (resolve, reject) {\n                _this.thenThis(function (v) { return defer_1.defer(function () { return resolve(v); }, milliseconds); }, function (e) { return defer_1.defer(function () { return reject(e); }, milliseconds); });\n            }, true);\n        };\n        PromiseBase.prototype['catch'] = function (onRejected) {\n            return this.then(VOID0, onRejected);\n        };\n        PromiseBase.prototype.catchAllowFatal = function (onRejected) {\n            return this.thenAllowFatal(VOID0, onRejected);\n        };\n        PromiseBase.prototype['finally'] = function (fin) {\n            return this.then(fin, fin);\n        };\n        PromiseBase.prototype.finallyAllowFatal = function (fin) {\n            return this.thenAllowFatal(fin, fin);\n        };\n        PromiseBase.prototype.finallyThis = function (fin, synchronous) {\n            this.throwIfDisposed();\n            var f = synchronous ? fin : function () { return deferImmediate_1.deferImmediate(fin); };\n            this.thenThis(f, f);\n            return this;\n        };\n        return PromiseBase;\n    }(PromiseState));\n    exports.PromiseBase = PromiseBase;\n    var Resolvable = (function (_super) {\n        __extends(Resolvable, _super);\n        function Resolvable() {\n            _super.apply(this, arguments);\n        }\n        Resolvable.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            try {\n                switch (this.state) {\n                    case Promise.State.Fulfilled:\n                        return onFulfilled\n                            ? resolve(this._result, onFulfilled, Promise.resolve)\n                            : this;\n                    case Promise.State.Rejected:\n                        return onRejected\n                            ? resolve(this._error, onRejected, Promise.resolve)\n                            : this;\n                }\n            }\n            catch (ex) {\n                return new Rejected(ex);\n            }\n            throw new Error(\"Invalid state for a resolved promise.\");\n        };\n        Resolvable.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            switch (this.state) {\n                case Promise.State.Fulfilled:\n                    if (onFulfilled)\n                        onFulfilled(this._result);\n                    break;\n                case Promise.State.Rejected:\n                    if (onRejected)\n                        onRejected(this._error);\n                    break;\n            }\n            return this;\n        };\n        return Resolvable;\n    }(PromiseBase));\n    exports.Resolvable = Resolvable;\n    var Resolved = (function (_super) {\n        __extends(Resolved, _super);\n        function Resolved(state, result, error) {\n            _super.call(this);\n            this._result = result;\n            this._error = error;\n            this._state = state;\n        }\n        return Resolved;\n    }(Resolvable));\n    exports.Resolved = Resolved;\n    var Fulfilled = (function (_super) {\n        __extends(Fulfilled, _super);\n        function Fulfilled(value) {\n            _super.call(this, Promise.State.Fulfilled, value);\n        }\n        return Fulfilled;\n    }(Resolved));\n    exports.Fulfilled = Fulfilled;\n    var Rejected = (function (_super) {\n        __extends(Rejected, _super);\n        function Rejected(error) {\n            _super.call(this, Promise.State.Rejected, VOID0, error);\n        }\n        return Rejected;\n    }(Resolved));\n    exports.Rejected = Rejected;\n    var PromiseWrapper = (function (_super) {\n        __extends(PromiseWrapper, _super);\n        function PromiseWrapper(_target) {\n            var _this = this;\n            _super.call(this);\n            this._target = _target;\n            if (!_target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            if (!isPromise(_target))\n                throw new ArgumentException_1.ArgumentException(TARGET, \"Must be a promise-like object.\");\n            _target.then(function (v) {\n                _this._state = Promise.State.Fulfilled;\n                _this._result = v;\n                _this._error = VOID0;\n                _this._target = VOID0;\n            }, function (e) {\n                _this._state = Promise.State.Rejected;\n                _this._error = e;\n                _this._target = VOID0;\n            });\n        }\n        PromiseWrapper.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            return new Promise(function (resolve, reject) {\n                handleDispatch(t, function (result) { return handleResolutionMethods(resolve, reject, result, onFulfilled); }, function (error) { return onRejected\n                    ? handleResolutionMethods(resolve, null, error, onRejected)\n                    : reject(error); });\n            }, true);\n        };\n        PromiseWrapper.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            var t = this._target;\n            if (!t)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            handleDispatch(t, onFulfilled, onRejected);\n            return this;\n        };\n        PromiseWrapper.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._target = VOID0;\n        };\n        return PromiseWrapper;\n    }(Resolvable));\n    var Promise = (function (_super) {\n        __extends(Promise, _super);\n        function Promise(resolver, forceSynchronous) {\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            _super.call(this);\n            if (resolver)\n                this.resolveUsing(resolver, forceSynchronous);\n        }\n        Promise.prototype.thenSynchronous = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.thenSynchronous.call(this, onFulfilled, onRejected);\n            var p = new Promise();\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\n            return p;\n        };\n        Promise.prototype.thenThis = function (onFulfilled, onRejected) {\n            this.throwIfDisposed();\n            if (this._state)\n                return _super.prototype.thenThis.call(this, onFulfilled, onRejected);\n            (this._waiting || (this._waiting = []))\n                .push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\n            return this;\n        };\n        Promise.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._resolvedCalled = VOID0;\n        };\n        Promise.prototype.resolveUsing = function (resolver, forceSynchronous, throwIfSettled) {\n            var _this = this;\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            if (!resolver)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolver\");\n            if (this._resolvedCalled)\n                throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n            if (this.state)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\n            this._resolvedCalled = true;\n            var state = 0;\n            var rejectHandler = function (reason) {\n                if (state) {\n                    console.warn(state == -1\n                        ? \"Rejection called multiple times\"\n                        : \"Rejection called after fulfilled.\");\n                }\n                else {\n                    state = -1;\n                    _this._resolvedCalled = false;\n                    _this.reject(reason);\n                }\n            };\n            var fulfillHandler = function (v) {\n                if (state) {\n                    console.warn(state == 1\n                        ? \"Fulfill called multiple times\"\n                        : \"Fulfill called after rejection.\");\n                }\n                else {\n                    state = 1;\n                    _this._resolvedCalled = false;\n                    _this.resolve(v);\n                }\n            };\n            if (forceSynchronous)\n                resolver(fulfillHandler, rejectHandler);\n            else\n                deferImmediate_1.deferImmediate(function () { return resolver(fulfillHandler, rejectHandler); });\n        };\n        Promise.prototype._emitDisposalRejection = function (p) {\n            var d = p.wasDisposed;\n            if (d)\n                this._rejectInternal(newODE());\n            return d;\n        };\n        Promise.prototype._resolveInternal = function (result) {\n            var _this = this;\n            if (this.wasDisposed)\n                return;\n            while (result instanceof PromiseBase) {\n                var r = result;\n                if (this._emitDisposalRejection(r))\n                    return;\n                switch (r.state) {\n                    case Promise.State.Pending:\n                        r.thenSynchronous(function (v) { return _this._resolveInternal(v); }, function (e) { return _this._rejectInternal(e); });\n                        return;\n                    case Promise.State.Rejected:\n                        this._rejectInternal(r.error);\n                        return;\n                    case Promise.State.Fulfilled:\n                        result = r.result;\n                        break;\n                }\n            }\n            if (isPromise(result)) {\n                result.then(function (v) { return _this._resolveInternal(v); }, function (e) { return _this._rejectInternal(e); });\n            }\n            else {\n                this._state = Promise.State.Fulfilled;\n                this._result = result;\n                this._error = VOID0;\n                var o = this._waiting;\n                if (o) {\n                    this._waiting = VOID0;\n                    for (var _i = 0, o_1 = o; _i < o_1.length; _i++) {\n                        var c = o_1[_i];\n                        var onFulfilled = c.onFulfilled, promise = c.promise;\n                        pools.PromiseCallbacks.recycle(c);\n                        handleResolution(promise, result, onFulfilled);\n                    }\n                    o.length = 0;\n                }\n            }\n        };\n        Promise.prototype._rejectInternal = function (error) {\n            if (this.wasDisposed)\n                return;\n            this._state = Promise.State.Rejected;\n            this._error = error;\n            var o = this._waiting;\n            if (o) {\n                this._waiting = null;\n                for (var _i = 0, o_2 = o; _i < o_2.length; _i++) {\n                    var c = o_2[_i];\n                    var onRejected = c.onRejected, promise = c.promise;\n                    pools.PromiseCallbacks.recycle(c);\n                    if (onRejected) {\n                        handleResolution(promise, error, onRejected);\n                    }\n                    else if (promise)\n                        promise.reject(error);\n                }\n                o.length = 0;\n            }\n        };\n        Promise.prototype.resolve = function (result, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (result == this)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot resolve a promise as itself.\");\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Fulfilled && this._result === result)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._resolveInternal(result);\n        };\n        Promise.prototype.reject = function (error, throwIfSettled) {\n            if (throwIfSettled === void 0) { throwIfSettled = false; }\n            this.throwIfDisposed();\n            if (this._state) {\n                if (!throwIfSettled || this._state == Promise.State.Rejected && this._error === error)\n                    return;\n                throw new InvalidOperationException_1.InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\n            }\n            if (this._resolvedCalled) {\n                if (throwIfSettled)\n                    throw new InvalidOperationException_1.InvalidOperationException(\".resolve() already called.\");\n                return;\n            }\n            this._rejectInternal(error);\n        };\n        return Promise;\n    }(Resolvable));\n    exports.Promise = Promise;\n    var ArrayPromise = (function (_super) {\n        __extends(ArrayPromise, _super);\n        function ArrayPromise() {\n            _super.apply(this, arguments);\n        }\n        ArrayPromise.prototype.map = function (transform) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new ArrayPromise(function (resolve) {\n                _this.thenThis(function (result) { return resolve(result.map(transform)); });\n            }, true);\n        };\n        ArrayPromise.prototype.reduce = function (reduction, initialValue) {\n            return this\n                .thenSynchronous(function (result) { return result.reduce(reduction, initialValue); });\n        };\n        ArrayPromise.fulfilled = function (value) {\n            return new ArrayPromise(function (resolve) { return value; }, true);\n        };\n        return ArrayPromise;\n    }(Promise));\n    exports.ArrayPromise = ArrayPromise;\n    var PromiseCollection = (function (_super) {\n        __extends(PromiseCollection, _super);\n        function PromiseCollection(source) {\n            _super.call(this);\n            this._source = source && source.slice() || [];\n        }\n        PromiseCollection.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            this._source.length = 0;\n            this._source = null;\n        };\n        Object.defineProperty(PromiseCollection.prototype, \"promises\", {\n            get: function () {\n                this.throwIfDisposed();\n                return this._source.slice();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        PromiseCollection.prototype.all = function () {\n            this.throwIfDisposed();\n            return Promise.all(this._source);\n        };\n        PromiseCollection.prototype.race = function () {\n            this.throwIfDisposed();\n            return Promise.race(this._source);\n        };\n        PromiseCollection.prototype.waitAll = function () {\n            this.throwIfDisposed();\n            return Promise.waitAll(this._source);\n        };\n        PromiseCollection.prototype.map = function (transform) {\n            var _this = this;\n            this.throwIfDisposed();\n            return new ArrayPromise(function (resolve) {\n                _this.all()\n                    .thenThis(function (result) { return resolve(result.map(transform)); });\n            }, true);\n        };\n        PromiseCollection.prototype.pipe = function (transform) {\n            this.throwIfDisposed();\n            return new PromiseCollection(this._source.map(function (p) { return handleSyncIfPossible(p, transform); }));\n        };\n        PromiseCollection.prototype.reduce = function (reduction, initialValue) {\n            this.throwIfDisposed();\n            return Promise.wrap(this._source\n                .reduce(function (previous, current, i, array) {\n                return handleSyncIfPossible(previous, function (p) { return handleSyncIfPossible(current, function (c) { return reduction(p, c, i, array); }); });\n            }, isPromise(initialValue)\n                ? initialValue\n                : new Fulfilled(initialValue)));\n        };\n        return PromiseCollection;\n    }(DisposableBase_1.DisposableBase));\n    exports.PromiseCollection = PromiseCollection;\n    var pools;\n    (function (pools) {\n        var PromiseCallbacks;\n        (function (PromiseCallbacks) {\n            var pool;\n            function getPool() {\n                return pool\n                    || (pool = new ObjectPool_1.ObjectPool(40, factory, function (c) {\n                        c.onFulfilled = NULL;\n                        c.onRejected = NULL;\n                        c.promise = NULL;\n                    }));\n            }\n            function factory() {\n                return {\n                    onFulfilled: NULL,\n                    onRejected: NULL,\n                    promise: NULL\n                };\n            }\n            function init(onFulfilled, onRejected, promise) {\n                var c = getPool().take();\n                c.onFulfilled = onFulfilled;\n                c.onRejected = onRejected;\n                c.promise = promise;\n                return c;\n            }\n            PromiseCallbacks.init = init;\n            function recycle(c) {\n                getPool().add(c);\n            }\n            PromiseCallbacks.recycle = recycle;\n        })(PromiseCallbacks = pools.PromiseCallbacks || (pools.PromiseCallbacks = {}));\n    })(pools || (pools = {}));\n    var Promise;\n    (function (Promise) {\n        (function (State) {\n            State[State[\"Pending\"] = 0] = \"Pending\";\n            State[State[\"Fulfilled\"] = 1] = \"Fulfilled\";\n            State[State[\"Rejected\"] = -1] = \"Rejected\";\n        })(Promise.State || (Promise.State = {}));\n        var State = Promise.State;\n        Object.freeze(State);\n        function factory(e) {\n            return new Promise(e);\n        }\n        Promise.factory = factory;\n        function group(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            return new PromiseCollection((Array.isArray(first) ? first : [first])\n                .concat(rest));\n        }\n        Promise.group = group;\n        function all(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new ArrayPromise(function (r) { return r(promises); }, true);\n            return new ArrayPromise(function (resolve, reject) {\n                var result = [];\n                var len = promises.length;\n                result.length = len;\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; }));\n                var cleanup = function () {\n                    reject = VOID0;\n                    resolve = VOID0;\n                    promises.length = 0;\n                    promises = VOID0;\n                    remaining.dispose();\n                    remaining = VOID0;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(result);\n                    }\n                };\n                var onFulfill = function (v, i) {\n                    if (resolve) {\n                        result[i] = v;\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var onReject = function (e) {\n                    var r = reject;\n                    if (r) {\n                        cleanup();\n                        r(e);\n                    }\n                };\n                var _loop_1 = function(i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onFulfill(v, i); }, onReject);\n                    else\n                        remaining.remove(i);\n                    checkIfShouldResolve();\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_1(i);\n                }\n            });\n        }\n        Promise.all = all;\n        function waitAll(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"promises\");\n            var promises = (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises.length || promises.every(function (v) { return !v; }))\n                return new ArrayPromise(function (r) { return r(promises); }, true);\n            return new ArrayPromise(function (resolve, reject) {\n                var len = promises.length;\n                var remaining = new Set_1.Set(promises.map(function (v, i) { return i; }));\n                var cleanup = function () {\n                    reject = NULL;\n                    resolve = NULL;\n                    remaining.dispose();\n                    remaining = NULL;\n                };\n                var checkIfShouldResolve = function () {\n                    var r = resolve;\n                    if (r && !remaining.count) {\n                        cleanup();\n                        r(promises);\n                    }\n                };\n                var onResolved = function (i) {\n                    if (remaining) {\n                        remaining.remove(i);\n                        checkIfShouldResolve();\n                    }\n                };\n                var _loop_2 = function(i) {\n                    var p = promises[i];\n                    if (p)\n                        p.then(function (v) { return onResolved(i); }, function (e) { return onResolved(i); });\n                    else\n                        onResolved(i);\n                };\n                for (var i = 0; remaining && i < len; i++) {\n                    _loop_2(i);\n                }\n            });\n        }\n        Promise.waitAll = waitAll;\n        function race(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            var promises = first && (Array.isArray(first) ? first : [first]).concat(rest);\n            if (!promises || !promises.length || !(promises = promises.filter(function (v) { return v != null; })).length)\n                throw new ArgumentException_1.ArgumentException(\"Nothing to wait for.\");\n            var len = promises.length;\n            if (len == 1)\n                return wrap(promises[0]);\n            for (var i = 0; i < len; i++) {\n                var p = promises[i];\n                if (p instanceof PromiseBase && p.isSettled)\n                    return p;\n            }\n            return new Promise(function (resolve, reject) {\n                var cleanup = function () {\n                    reject = NULL;\n                    resolve = NULL;\n                    promises.length = 0;\n                    promises = NULL;\n                };\n                var onResolve = function (r, v) {\n                    if (r) {\n                        cleanup();\n                        r(v);\n                    }\n                };\n                var onFulfill = function (v) { return onResolve(resolve, v); };\n                var onReject = function (e) { return onResolve(reject, e); };\n                for (var _i = 0, promises_1 = promises; _i < promises_1.length; _i++) {\n                    var p_1 = promises_1[_i];\n                    if (!resolve)\n                        break;\n                    p_1.then(onFulfill, onReject);\n                }\n            });\n        }\n        Promise.race = race;\n        function resolve(value) {\n            return isPromise(value) ? wrap(value) : new Fulfilled(value);\n        }\n        Promise.resolve = resolve;\n        function using(resolver, forceSynchronous) {\n            if (forceSynchronous === void 0) { forceSynchronous = false; }\n            return new Promise(resolver, forceSynchronous);\n        }\n        Promise.using = using;\n        function resolveAll(first) {\n            var rest = [];\n            for (var _i = 1; _i < arguments.length; _i++) {\n                rest[_i - 1] = arguments[_i];\n            }\n            if (!first && !rest.length)\n                throw new ArgumentNullException_1.ArgumentNullException(\"resolutions\");\n            return new PromiseCollection((Array.isArray(first) ? first : [first])\n                .concat(rest)\n                .map(function (v) { return resolve(v); }));\n        }\n        Promise.resolveAll = resolveAll;\n        function map(source, transform) {\n            return new PromiseCollection(source.map(function (d) { return new Promise(function (r, j) {\n                try {\n                    r(transform(d));\n                }\n                catch (ex) {\n                    j(ex);\n                }\n            }); }));\n        }\n        Promise.map = map;\n        function reject(reason) {\n            return new Rejected(reason);\n        }\n        Promise.reject = reject;\n        function wrap(target) {\n            if (!target)\n                throw new ArgumentNullException_1.ArgumentNullException(TARGET);\n            return isPromise(target)\n                ? (target instanceof PromiseBase ? target : new PromiseWrapper(target))\n                : new Fulfilled(target);\n        }\n        Promise.wrap = wrap;\n        function createFrom(then) {\n            if (!then)\n                throw new ArgumentNullException_1.ArgumentNullException(THEN);\n            return new PromiseWrapper({ then: then });\n        }\n        Promise.createFrom = createFrom;\n    })(Promise = exports.Promise || (exports.Promise = {}));\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    exports.default = Promise;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n * Although most of the following code is written from scratch, it is\r\n * heavily influenced by Q (https://github.com/kriskowal/q) and uses some of Q's spec.\r\n */\r\n\r\n/*\r\n * Resources:\r\n * https://promisesaplus.com/\r\n * https://github.com/kriskowal/q\r\n */\r\n\r\nimport Type from \"../Types\";\r\nimport {deferImmediate} from \"../Threading/deferImmediate\";\r\nimport {DisposableBase} from \"../Disposable/DisposableBase\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentException} from \"../Exceptions/ArgumentException\";\r\nimport {ArgumentNullException} from \"../Exceptions/ArgumentNullException\";\r\nimport {ObjectPool} from \"../Disposable/ObjectPool\";\r\nimport {Set} from \"../Collections/Set\";\r\nimport {defer} from \"../Threading/defer\";\r\nimport {ObjectDisposedException} from \"../Disposable/ObjectDisposedException\";\r\nimport __extendsImport from \"../../extends\";\r\n//noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:any = void 0, NULL:any = null, PROMISE = \"Promise\", PROMISE_STATE = PROMISE + \"State\", THEN = \"then\", TARGET = \"target\";\r\n\r\nfunction isPromise<T>(value:any):value is PromiseLike<T>\r\n{\r\n\treturn Type.hasMemberOfType(value, THEN, Type.FUNCTION);\r\n}\r\n\r\nfunction resolve<T>(\r\n\tvalue:Promise.Resolution<T>, resolver:(v:Promise.Resolution<T>)=>any,\r\n\tpromiseFactory:(v:any)=>PromiseBase<any>):PromiseBase<any>\r\n{\r\n\tlet nextValue = resolver\r\n\t\t? resolver(value)\r\n\t\t: value;\r\n\r\n\treturn nextValue && isPromise(nextValue)\r\n\t\t? Promise.wrap(nextValue)\r\n\t\t: promiseFactory(nextValue);\r\n}\r\n\r\nfunction handleResolution(\r\n\tp:Promise<any>|null|undefined,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):any\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(p) p.resolve(v);\r\n\t\treturn null;\r\n\t}\r\n\tcatch(ex)\r\n\t{\r\n\t\tif(p) p.reject(ex);\r\n\t\treturn ex;\r\n\t}\r\n}\r\n\r\nfunction handleResolutionMethods(\r\n\ttargetFulfill:Promise.Fulfill<any,any>|null|undefined,\r\n\ttargetReject:Promise.Reject<any>|null|undefined,\r\n\tvalue:Promise.Resolution<any>,\r\n\tresolver?:(v:Promise.Resolution<any>)=>any):void\r\n{\r\n\ttry\r\n\t{\r\n\t\tlet v = resolver ? resolver(value) : value;\r\n\t\tif(targetFulfill) targetFulfill(v);\r\n\t}\r\n\tcatch(ex)\r\n\t{ if(targetReject) targetReject(ex); }\r\n}\r\n\r\nfunction handleDispatch<T,TResult>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\tonRejected?:Promise.Reject<TResult>):void\r\n{\r\n\tif(p instanceof PromiseBase)\r\n\t\tp.thenThis(onFulfilled, onRejected);\r\n\telse\r\n\t\tp.then(<any>onFulfilled, onRejected);\r\n}\r\n\r\nfunction handleSyncIfPossible<T,TResult>(\r\n\tp:PromiseLike<T>,\r\n\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\tonRejected?:Promise.Reject<TResult>):PromiseLike<TResult>\r\n{\r\n\tif(p instanceof PromiseBase)\r\n\t\treturn p.thenSynchronous(onFulfilled, onRejected);\r\n\telse\r\n\t\treturn p.then(<any>onFulfilled, onRejected);\r\n}\r\n\r\nfunction newODE()\r\n{\r\n\treturn new ObjectDisposedException(\"Promise\", \"An underlying promise-result was disposed.\");\r\n}\r\n\r\nexport class PromiseState<T>\r\nextends DisposableBase\r\n{\r\n\r\n\tconstructor(\r\n\t\tprotected _state:Promise.State,\r\n\t\tprotected _result?:T,\r\n\t\tprotected _error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._disposableObjectName = PROMISE_STATE;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._state = VOID0;\r\n\t\tthis._result = VOID0;\r\n\t\tthis._error = VOID0;\r\n\t}\r\n\r\n\tprotected getState():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget state():Promise.State\r\n\t{\r\n\t\treturn this._state;\r\n\t}\r\n\r\n\tget isPending():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Pending;\r\n\t}\r\n\r\n\tget isSettled():boolean\r\n\t{\r\n\t\treturn this.getState()!=Promise.State.Pending; // Will also include undefined==0 aka disposed!=resolved.\r\n\t}\r\n\r\n\tget isFulfilled():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Fulfilled;\r\n\t}\r\n\r\n\tget isRejected():boolean\r\n\t{\r\n\t\treturn this.getState()===Promise.State.Rejected;\r\n\t}\r\n\r\n\t/*\r\n\t * Providing overrides allows for special defer or lazy sub classes.\r\n\t */\r\n\tprotected getResult():T|undefined\r\n\t{\r\n\t\treturn this._result;\r\n\t}\r\n\r\n\tget result():T|undefined\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getResult();\r\n\t}\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class PromiseBase<T>\r\nextends PromiseState<T> implements PromiseLike<T>\r\n{\r\n\tconstructor()\r\n\t{\r\n\t\tsuper(Promise.State.Pending);\r\n\t\tthis._disposableObjectName = PROMISE;\r\n\t}\r\n\r\n\t/**\r\n\t * Calls the respective handlers once the promise is resolved.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>;\r\n\r\n\t/**\r\n\t * Same as 'thenSynchronous' but does not return the result.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tabstract thenThis(\r\n\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\tonRejected?:Promise.Reject<any>):this;\r\n\r\n\tabstract thenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):this;\r\n\r\n\r\n\t/**\r\n\t * Standard .then method that defers execution until resolved.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t * @returns {Promise}\r\n\t */\r\n\tthen<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new Promise<TResult>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tthis.thenThis(\r\n\t\t\t\tresult=>\r\n\t\t\t\t\thandleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror=>\r\n\t\t\t\t\tonRejected\r\n\t\t\t\t\t\t? handleResolutionMethods(resolve, reject, error, onRejected)\r\n\t\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Same as .then but doesn't trap errors.  Exceptions may end up being fatal.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t * @returns {Promise}\r\n\t */\r\n\tthenAllowFatal<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new Promise<TResult>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tthis.thenThis(\r\n\t\t\t\tresult=>\r\n\t\t\t\t\tresolve(<any>(onFulfilled ? onFulfilled(result) : result)),\r\n\t\t\t\terror=>\r\n\t\t\t\t\treject(onRejected ? onRejected(error) : error)\r\n\t\t\t);\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * .done is provided as a non-standard means that maps to similar functionality in other promise libraries.\r\n\t * As stated by promisejs.org: 'then' is to 'done' as 'map' is to 'forEach'.\r\n\t * @param onFulfilled\r\n\t * @param onRejected\r\n\t */\r\n\tdone(\r\n\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\tonRejected?:Promise.Reject<any>):void\r\n\t{\r\n\t\tdefer(()=>\r\n\t\t\tthis.thenThis(onFulfilled, onRejected));\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from the time called before continuing.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayFromNow(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\treturn new Promise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\tdefer(()=>\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.thenThis(\r\n\t\t\t\t\t\tv=> resolve(v),\r\n\t\t\t\t\t\te=> reject(e));\r\n\t\t\t\t}, milliseconds)\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Will yield for a number of milliseconds from after this promise resolves.\r\n\t * If the promise is already resolved, the delay will start from now.\r\n\t * @param milliseconds\r\n\t * @returns A promise that yields to the current execution and executes after a delay.\r\n\t */\r\n\tdelayAfterResolve(milliseconds:number = 0):PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tif(this.isSettled) return this.delayFromNow(milliseconds);\r\n\r\n\t\treturn new Promise<T>(\r\n\t\t\t(resolve, reject)=>\r\n\t\t\t{\r\n\t\t\t\tthis.thenThis(\r\n\t\t\t\t\tv=>defer(()=>resolve(v), milliseconds),\r\n\t\t\t\t\te=>defer(()=>reject(e), milliseconds))\r\n\t\t\t},\r\n\t\t\ttrue // Since the resolve/reject is deferred.\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for trapping a rejection.\r\n\t * @param onRejected\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\t'catch'<TResult>(onRejected:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.then(VOID0, onRejected)\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut for trapping a rejection but will allow exceptions to propagate within the onRejected handler.\r\n\t * @param onRejected\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\tcatchAllowFatal<TResult>(onRejected:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.thenAllowFatal(VOID0, onRejected)\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject.\r\n\t * @param fin\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\t'finally'<TResult>(fin:()=>Promise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.then(fin, fin);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject but will allow exceptions to propagate within the handler.\r\n\t * @param fin\r\n\t * @returns {PromiseBase<TResult>}\r\n\t */\r\n\tfinallyAllowFatal<TResult>(fin:()=>Promise.Resolution<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\treturn this.thenAllowFatal(fin, fin);\r\n\t}\r\n\r\n\t/**\r\n\t * Shortcut to for handling either resolve or reject.  Returns the current promise instead.\r\n\t * You may not need an additional promise result, and this will not create a new one.\r\n\t * @param fin\r\n\t * @param synchronous\r\n\t * @returns {PromiseBase}\r\n\t */\r\n\tfinallyThis(fin:()=>void, synchronous?:boolean):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tvar f:()=>void = synchronous ? fin : ()=>deferImmediate(fin);\r\n\t\tthis.thenThis(f, f);\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\nexport abstract class Resolvable<T> extends PromiseBase<T>\r\n{\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\ttry\r\n\t\t{\r\n\t\t\tswitch(this.state)\r\n\t\t\t{\r\n\t\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\t\treturn onFulfilled\r\n\t\t\t\t\t\t? resolve(this._result, onFulfilled, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this; // Provided for catch cases.\r\n\t\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\t\treturn onRejected\r\n\t\t\t\t\t\t? resolve(this._error, onRejected, Promise.resolve)\r\n\t\t\t\t\t\t: <any>this;\r\n\t\t\t}\r\n\t\t}\r\n\t\tcatch(ex)\r\n\t\t{\r\n\t\t\treturn new Rejected<any>(ex);\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Invalid state for a resolved promise.\");\r\n\t}\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tswitch(this.state)\r\n\t\t{\r\n\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\tif(onFulfilled) onFulfilled(this._result);\r\n\t\t\t\tbreak;\r\n\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\tif(onRejected) onRejected(this._error);\r\n\t\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * The simplest usable version of a promise which returns synchronously the resolved state provided.\r\n */\r\nexport abstract class Resolved<T> extends Resolvable<T>\r\n{\r\n\tconstructor(state:Promise.State, result:T, error?:any)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._result = result;\r\n\t\tthis._error = error;\r\n\t\tthis._state = state;\r\n\t}\r\n\r\n\r\n}\r\n\r\n/**\r\n * A fulfilled Resolved<T>.  Provided for readability.\r\n */\r\nexport class Fulfilled<T> extends Resolved<T>\r\n{\r\n\tconstructor(value:T)\r\n\t{\r\n\t\tsuper(Promise.State.Fulfilled, value);\r\n\t}\r\n}\r\n\r\n/**\r\n * A rejected Resolved<T>.  Provided for readability.\r\n */\r\nexport class Rejected<T> extends Resolved<T>\r\n{\r\n\tconstructor(error:any)\r\n\t{\r\n\t\tsuper(Promise.State.Rejected, VOID0, error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * Provided as a means for extending the interface of other PromiseLike<T> objects.\r\n */\r\nclass PromiseWrapper<T> extends Resolvable<T>\r\n{\r\n\tconstructor(private _target:PromiseLike<T>)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(!_target)\r\n\t\t\tthrow new ArgumentNullException(TARGET);\r\n\r\n\t\tif(!isPromise(_target))\r\n\t\t\tthrow new ArgumentException(TARGET, \"Must be a promise-like object.\");\r\n\r\n\t\t_target.then(\r\n\t\t\t(v:T)=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Fulfilled;\r\n\t\t\t\tthis._result = v;\r\n\t\t\t\tthis._error = VOID0;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t},\r\n\t\t\te=>\r\n\t\t\t{\r\n\t\t\t\tthis._state = Promise.State.Rejected;\r\n\t\t\t\tthis._error = e;\r\n\t\t\t\tthis._target = VOID0;\r\n\t\t\t})\r\n\t}\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\treturn new Promise<TResult>((resolve, reject)=>\r\n\t\t{\r\n\t\t\thandleDispatch(t,\r\n\t\t\t\tresult=>handleResolutionMethods(resolve, reject, result, onFulfilled),\r\n\t\t\t\terror=>onRejected\r\n\t\t\t\t\t? handleResolutionMethods(resolve, null, error, onRejected)\r\n\t\t\t\t\t: reject(error)\r\n\t\t\t);\r\n\t\t}, true);\r\n\t}\r\n\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\tvar t = this._target;\r\n\t\tif(!t) return <any>super.thenThis(onFulfilled, onRejected);\r\n\t\thandleDispatch(t, onFulfilled, onRejected);\r\n\t\treturn this;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._target = VOID0;\r\n\t}\r\n\r\n}\r\n\r\n\r\n/**\r\n * This promise class that facilitates pending resolution.\r\n */\r\nexport class Promise<T> extends Resolvable<T>\r\n{\r\n\r\n\tprivate _waiting:IPromiseCallbacks<any>[]|null|undefined;\r\n\r\n\t/*\r\n\t * A note about deferring:\r\n\t * The caller can set resolveImmediate to true if they intend to initialize code that will end up being deferred itself.\r\n\t * This eliminates the extra defer that will occur internally.\r\n\t * But for the most part, resolveImmediate = false (the default) will ensure the constructor will not block.\r\n\t *\r\n\t * resolveUsing allows for the same ability but does not defer by default: allowing the caller to take on the work load.\r\n\t * If calling resolve or reject and a deferred response is desired, then use deferImmediate with a closure to do so.\r\n\t */\r\n\r\n\tconstructor(\r\n\t\tresolver?:Promise.Executor<T>, forceSynchronous:boolean = false)\r\n\t{\r\n\t\tsuper();\r\n\r\n\t\tif(resolver) this.resolveUsing(resolver, forceSynchronous);\r\n\t}\r\n\r\n\r\n\tthenSynchronous<TResult>(\r\n\t\tonFulfilled:Promise.Fulfill<T,TResult>,\r\n\t\tonRejected?:Promise.Reject<TResult>):PromiseBase<TResult>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state) return super.thenSynchronous(onFulfilled, onRejected);\r\n\r\n\t\tvar p = new Promise<TResult>();\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected, p));\r\n\t\treturn p;\r\n\t}\r\n\r\n\tthenThis(\r\n\t\tonFulfilled:(v?:T)=>any,\r\n\t\tonRejected?:(v?:any)=>any):this\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\r\n\t\t// Already fulfilled?\r\n\t\tif(this._state)\r\n\t\t\treturn <any>super.thenThis(onFulfilled, onRejected);\r\n\r\n\t\t(this._waiting || (this._waiting = []))\r\n\t\t\t.push(pools.PromiseCallbacks.init(onFulfilled, onRejected));\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._resolvedCalled = VOID0;\r\n\t}\r\n\r\n\t// Protects against double calling.\r\n\tprotected _resolvedCalled:boolean;\r\n\r\n\tresolveUsing(\r\n\t\tresolver:Promise.Executor<T>,\r\n\t\tforceSynchronous:boolean = false,\r\n\t\tthrowIfSettled:boolean = false)\r\n\t{\r\n\t\tif(!resolver)\r\n\t\t\tthrow new ArgumentNullException(\"resolver\");\r\n\t\tif(this._resolvedCalled)\r\n\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\tif(this.state)\r\n\t\t\tthrow new InvalidOperationException(\"Already resolved: \" + Promise.State[this.state]);\r\n\r\n\t\tthis._resolvedCalled = true;\r\n\r\n\t\tvar state = 0;\r\n\t\tvar rejectHandler = (reason:any)=>\r\n\t\t{\r\n\t\t\tif(state)\r\n\t\t\t{\r\n\t\t\t\t// Someone else's promise handling down stream could double call this. :\\\r\n\t\t\t\tconsole.warn(state== -1\r\n\t\t\t\t\t? \"Rejection called multiple times\"\r\n\t\t\t\t\t: \"Rejection called after fulfilled.\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate = -1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.reject(reason);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tvar fulfillHandler = (v:any)=>\r\n\t\t{\r\n\t\t\tif(state)\r\n\t\t\t{\r\n\t\t\t\t// Someone else's promise handling down stream could double call this. :\\\r\n\t\t\t\tconsole.warn(state==1\r\n\t\t\t\t\t? \"Fulfill called multiple times\"\r\n\t\t\t\t\t: \"Fulfill called after rejection.\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tstate = 1;\r\n\t\t\t\tthis._resolvedCalled = false;\r\n\t\t\t\tthis.resolve(v);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t// There are some performance edge cases where there caller is not blocking upstream and does not need to defer.\r\n\t\tif(forceSynchronous)\r\n\t\t\tresolver(fulfillHandler, rejectHandler);\r\n\t\telse\r\n\t\t\tdeferImmediate(()=>resolver(fulfillHandler, rejectHandler));\r\n\r\n\t}\r\n\r\n\r\n\tprivate _emitDisposalRejection(p:PromiseBase<any>):boolean\r\n\t{\r\n\t\tvar d = p.wasDisposed;\r\n\t\tif(d) this._rejectInternal(newODE());\r\n\t\treturn d;\r\n\t}\r\n\r\n\tprivate _resolveInternal(result?:T|PromiseLike<T>):void\r\n\t{\r\n\t\tif(this.wasDisposed) return;\r\n\r\n\t\t// Note: Avoid recursion if possible.\r\n\r\n\t\t// Check ahead of time for resolution and resolve appropriately\r\n\t\twhile(result instanceof PromiseBase)\r\n\t\t{\r\n\t\t\tlet r:PromiseBase<T> = <any>result;\r\n\t\t\tif(this._emitDisposalRejection(r)) return;\r\n\t\t\tswitch(r.state)\r\n\t\t\t{\r\n\t\t\t\tcase Promise.State.Pending:\r\n\t\t\t\t\tr.thenSynchronous(\r\n\t\t\t\t\t\tv=>this._resolveInternal(v),\r\n\t\t\t\t\t\te=>this._rejectInternal(e)\r\n\t\t\t\t\t);\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase Promise.State.Rejected:\r\n\t\t\t\t\tthis._rejectInternal(r.error);\r\n\t\t\t\t\treturn;\r\n\t\t\t\tcase Promise.State.Fulfilled:\r\n\t\t\t\t\tresult = r.result;\r\n\t\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif(isPromise(result))\r\n\t\t{\r\n\t\t\tresult.then(\r\n\t\t\t\tv=>this._resolveInternal(v),\r\n\t\t\t\te=>this._rejectInternal(e)\r\n\t\t\t);\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tthis._state = Promise.State.Fulfilled;\r\n\r\n\t\t\tthis._result = result;\r\n\t\t\tthis._error = VOID0;\r\n\t\t\tvar o = this._waiting;\r\n\t\t\tif(o)\r\n\t\t\t{\r\n\t\t\t\tthis._waiting = VOID0;\r\n\t\t\t\tfor(let c of o)\r\n\t\t\t\t{\r\n\t\t\t\t\tlet {onFulfilled, promise} = c;\r\n\t\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\t\t//let ex =\r\n\t\t\t\t\thandleResolution(<any>promise, result, onFulfilled);\r\n\t\t\t\t\t//if(!p && ex) console.error(\"Unhandled exception in onFulfilled:\",ex);\r\n\t\t\t\t}\r\n\t\t\t\to.length = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tprivate _rejectInternal(error:any):void\r\n\t{\r\n\r\n\t\tif(this.wasDisposed) return;\r\n\r\n\t\tthis._state = Promise.State.Rejected;\r\n\r\n\t\tthis._error = error;\r\n\t\tvar o = this._waiting;\r\n\t\tif(o)\r\n\t\t{\r\n\t\t\tthis._waiting = null; // null = finished. undefined = hasn't started.\r\n\t\t\tfor(let c of o)\r\n\t\t\t{\r\n\t\t\t\tlet {onRejected, promise} = c;\r\n\t\t\t\tpools.PromiseCallbacks.recycle(c);\r\n\t\t\t\tif(onRejected)\r\n\t\t\t\t{\r\n\t\t\t\t\t//let ex =\r\n\t\t\t\t\thandleResolution(promise, error, onRejected);\r\n\t\t\t\t\t//if(!p && ex) console.error(\"Unhandled exception in onRejected:\",ex);\r\n\t\t\t\t}\r\n\t\t\t\telse if(promise) promise.reject(error);\r\n\t\t\t}\r\n\t\t\to.length = 0;\r\n\t\t}\r\n\t}\r\n\r\n\tresolve(result?:T | PromiseLike<T>, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(<any>result==this)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot resolve a promise as itself.\");\r\n\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Fulfilled && this._result===result) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the fulfilled state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._resolveInternal(result);\r\n\t}\r\n\r\n\r\n\treject(error:any, throwIfSettled:boolean = false):void\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\tif(this._state)\r\n\t\t{\r\n\t\t\t// Same value? Ignore...\r\n\t\t\tif(!throwIfSettled || this._state==Promise.State.Rejected && this._error===error) return;\r\n\t\t\tthrow new InvalidOperationException(\"Changing the rejected state/value of a promise is not supported.\");\r\n\t\t}\r\n\r\n\t\tif(this._resolvedCalled)\r\n\t\t{\r\n\t\t\tif(throwIfSettled)\r\n\t\t\t\tthrow new InvalidOperationException(\".resolve() already called.\");\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\tthis._rejectInternal(error);\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * By providing an ArrayPromise we expose useful methods/shortcuts for dealing with array results.\r\n */\r\nexport class ArrayPromise<T> extends Promise<T[]>\r\n{\r\n\r\n\t/**\r\n\t * Simplifies the use of a map function on an array of results when the source is assured to be an array.\r\n\t * @param transform\r\n\t * @returns {PromiseBase<Array<any>>}\r\n\t */\r\n\tmap<U>(transform:(value:T)=>U):ArrayPromise<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new ArrayPromise<U>(resolve=>\r\n\t\t{\r\n\t\t\tthis.thenThis((result:T[])=>resolve(result.map(transform)));\r\n\t\t}, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Simplifies the use of a reduce function on an array of results when the source is assured to be an array.\r\n\t * @param reduction\r\n\t * @param initialValue\r\n\t * @returns {PromiseBase<any>}\r\n\t */\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:T[]) => U,\r\n\t\tinitialValue?:U):PromiseBase<U>\r\n\t{\r\n\r\n\t\treturn this\r\n\t\t\t.thenSynchronous((result:T[])=>result.reduce(reduction, initialValue));\r\n\t}\r\n\r\n\tstatic fulfilled<T>(value:T[]):ArrayPromise<T>\r\n\t{\r\n\t\treturn new ArrayPromise<T>(resolve=>value, true);\r\n\t}\r\n}\r\n\r\n/**\r\n * A Promise collection exposes useful methods for handling a collection of promises and their results.\r\n */\r\nexport class PromiseCollection<T> extends DisposableBase\r\n{\r\n\tprivate _source:PromiseLike<T>[];\r\n\r\n\tconstructor(source:PromiseLike<T>[]|null|undefined)\r\n\t{\r\n\t\tsuper();\r\n\t\tthis._source = source && source.slice() || [];\r\n\t}\r\n\r\n\tprotected _onDispose()\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tthis._source.length = 0;\r\n\t\t(<any>this)._source = null;\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a copy of the source promises.\r\n\t * @returns {PromiseLike<PromiseLike<any>>[]}\r\n\t */\r\n\tget promises():PromiseLike<T>[]\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn this._source.slice();\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t * @returns {PromiseBase<any>}\r\n\t */\r\n\tall():ArrayPromise<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn Promise.all(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t * or rejected.\r\n\t * @returns {PromiseBase<any>} A new Promise.\r\n\t */\r\n\trace():PromiseBase<T>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn Promise.race(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\r\n\t * Unlike .all this method waits for all rejections as well as fulfillment.\r\n\t * @returns {PromiseBase<PromiseLike<any>[]>}\r\n\t */\r\n\twaitAll():ArrayPromise<PromiseLike<T>>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn Promise.waitAll(this._source);\r\n\t}\r\n\r\n\t/**\r\n\t * Waits for all the values to resolve and then applies a transform.\r\n\t * @param transform\r\n\t * @returns {PromiseBase<Array<any>>}\r\n\t */\r\n\tmap<U>(transform:(value:T)=>U):ArrayPromise<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new ArrayPromise<U>(resolve=>\r\n\t\t{\r\n\t\t\tthis.all()\r\n\t\t\t\t.thenThis((result:T[])=>resolve(result.map(transform)));\r\n\t\t}, true);\r\n\t}\r\n\r\n\t/**\r\n\t * Applies a transform to each promise and defers the result.\r\n\t * Unlike map, this doesn't wait for all promises to resolve, ultimately improving the async nature of the request.\r\n\t * @param transform\r\n\t * @returns {PromiseCollection<U>}\r\n\t */\r\n\r\n\tpipe<U>(transform:(value:T)=>U|PromiseLike<U>):PromiseCollection<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn new PromiseCollection<U>(this._source.map(p=>handleSyncIfPossible(p, transform)));\r\n\t}\r\n\r\n\t/**\r\n\t * Behaves like array reduce.\r\n\t * Creates the promise chain necessary to produce the desired result.\r\n\t * @param reduction\r\n\t * @param initialValue\r\n\t * @returns {PromiseBase<PromiseLike<any>>}\r\n\t */\r\n\treduce<U>(\r\n\t\treduction:(previousValue:U, currentValue:T, i?:number, array?:PromiseLike<T>[]) => U,\r\n\t\tinitialValue?:U|PromiseLike<U>):PromiseBase<U>\r\n\t{\r\n\t\tthis.throwIfDisposed();\r\n\t\treturn Promise.wrap(this._source\r\n\t\t\t.reduce(\r\n\t\t\t\t(\r\n\t\t\t\t\tprevious:PromiseLike<U>,\r\n\t\t\t\t\tcurrent:PromiseLike<T>,\r\n\t\t\t\t\ti:number,\r\n\t\t\t\t\tarray:PromiseLike<T>[]) =>\r\n\t\t\t\t\thandleSyncIfPossible(previous,\r\n\t\t\t\t\t\t(p:U)=>handleSyncIfPossible(current, (c:T)=>reduction(p, c, i, array))),\r\n\r\n\t\t\t\tisPromise(initialValue)\r\n\t\t\t\t\t? initialValue\r\n\t\t\t\t\t: new Fulfilled(initialValue)\r\n\t\t\t)\r\n\t\t);\r\n\t}\r\n}\r\n\r\nmodule pools\r\n{\r\n\r\n\t// export module pending\r\n\t// {\r\n\t//\r\n\t//\r\n\t// \tvar pool:ObjectPool<Promise<any>>;\r\n\t//\r\n\t// \tfunction getPool()\r\n\t// \t{\r\n\t// \t\treturn pool || (pool = new ObjectPool<Promise<any>>(40, factory, c=>c.dispose()));\r\n\t// \t}\r\n\t//\r\n\t// \tfunction factory():Promise<any>\r\n\t// \t{\r\n\t// \t\treturn new Promise();\r\n\t// \t}\r\n\t//\r\n\t// \texport function get():Promise<any>\r\n\t// \t{\r\n\t// \t\tvar p:any = getPool().take();\r\n\t// \t\tp.__wasDisposed = false;\r\n\t// \t\tp._state = Promise.State.Pending;\r\n\t// \t\treturn p;\r\n\t// \t}\r\n\t//\r\n\t// \texport function recycle<T>(c:Promise<T>):void\r\n\t// \t{\r\n\t// \t\tif(c) getPool().add(c);\r\n\t// \t}\r\n\t//\r\n\t// }\r\n\t//\r\n\t// export function recycle<T>(c:PromiseBase<T>):void\r\n\t// {\r\n\t// \tif(!c) return;\r\n\t// \tif(c instanceof Promise && c.constructor==Promise) pending.recycle(c);\r\n\t// \telse c.dispose();\r\n\t// }\r\n\r\n\r\n\texport module PromiseCallbacks\r\n\t{\r\n\r\n\t\tvar pool:ObjectPool<IPromiseCallbacks<any>>;\r\n\r\n\t\tfunction getPool()\r\n\t\t{\r\n\t\t\treturn pool\r\n\t\t\t\t|| (pool = new ObjectPool<IPromiseCallbacks<any>>(40, factory, c=>\r\n\t\t\t\t{\r\n\t\t\t\t\tc.onFulfilled = NULL;\r\n\t\t\t\t\tc.onRejected = NULL;\r\n\t\t\t\t\tc.promise = NULL;\r\n\t\t\t\t}));\r\n\t\t}\r\n\r\n\t\tfunction factory():IPromiseCallbacks<any>\r\n\t\t{\r\n\t\t\treturn {\r\n\t\t\t\tonFulfilled: NULL,\r\n\t\t\t\tonRejected: NULL,\r\n\t\t\t\tpromise: NULL\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\texport function init<T>(\r\n\t\t\tonFulfilled:Promise.Fulfill<T,any>,\r\n\t\t\tonRejected?:Promise.Reject<any>,\r\n\t\t\tpromise?:Promise<any>):IPromiseCallbacks<T>\r\n\t\t{\r\n\r\n\t\t\tvar c = getPool().take();\r\n\t\t\tc.onFulfilled = onFulfilled;\r\n\t\t\tc.onRejected = onRejected;\r\n\t\t\tc.promise = promise;\r\n\t\t\treturn c;\r\n\t\t}\r\n\r\n\t\texport function recycle<T>(c:IPromiseCallbacks<T>):void\r\n\t\t{\r\n\t\t\tgetPool().add(c);\r\n\t\t}\r\n\t}\r\n\r\n\r\n}\r\n\r\n\r\nexport module Promise\r\n{\r\n\r\n\t/**\r\n\t * The state of a promise.\r\n\t * https://github.com/domenic/promises-unwrapping/blob/master/docs/states-and-fates.md\r\n\t * If a promise is disposed the value will be undefined which will also evaluate (promise.state)==false.\r\n\t */\r\n\texport enum State {\r\n\t\tPending   = 0,\r\n\t\tFulfilled = 1,\r\n\t\tRejected  = -1\r\n\t}\r\n\tObject.freeze(State);\r\n\r\n\texport type Resolution<TResult> = PromiseLike<TResult>|TResult|void;\r\n\r\n\texport interface Fulfill<T, TResult>\r\n\t{\r\n\t\t(value:T):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Reject<TResult>\r\n\t{\r\n\t\t(err?:any):Resolution<TResult>\r\n\t}\r\n\r\n\texport interface Then<T,TResult>\r\n\t{\r\n\t\t(\r\n\t\t\tonFulfilled:Fulfill<T,TResult>,\r\n\t\t\tonRejected?:Reject<TResult>):PromiseLike<TResult>\r\n\t}\r\n\r\n\texport interface Executor<T>\r\n\t{\r\n\t\t(\r\n\t\t\tresolve:(value?:T | PromiseLike<T>) => void,\r\n\t\t\treject:(reason?:any) => void):void;\r\n\t}\r\n\r\n\t//noinspection JSUnusedGlobalSymbols\r\n\texport interface Factory\r\n\t{\r\n\t\t<T>(executor:Executor<T>):PromiseLike<T>;\r\n\t}\r\n\r\n\texport function factory<T>(e:Executor<T>):Promise<T>\r\n\t{\r\n\t\treturn new Promise(e);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a set of promises and returns a PromiseCollection.\r\n\t * @param promises\r\n\t */\r\n\texport function group<T>(promises:PromiseLike<T>[]):PromiseCollection<T>\r\n\texport function group<T>(\r\n\t\tpromise:PromiseLike<T>,\r\n\t\t...rest:PromiseLike<T>[]):PromiseCollection<T>\r\n\texport function group(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseCollection<any>\r\n\t{\r\n\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\treturn new PromiseCollection(\r\n\t\t\t(Array.isArray(first) ? first : [first])\r\n\t\t\t\t.concat(rest)\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with an array containing the fulfillment value of each promise, or is rejected with the same rejection reason as the first promise to be rejected.\r\n\t */\r\n\texport function all<T>(promises:PromiseLike<T>[]):ArrayPromise<T>\r\n\texport function all<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):ArrayPromise<T>\r\n\texport function all(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):ArrayPromise<any>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new ArrayPromise<any>(\r\n\t\t\tr=>r(promises), true); // it's a new empty, reuse it. :|\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new ArrayPromise<any>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet result:any[] = [];\r\n\t\t\tlet len = promises.length;\r\n\t\t\tresult.length = len;\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = VOID0;\r\n\t\t\t\tresolve = VOID0;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = VOID0;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = VOID0;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(result);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any, i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(resolve)\r\n\t\t\t\t{\r\n\t\t\t\t\tresult[i] = v;\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onReject = (e?:any)=>\r\n\t\t\t{\r\n\t\t\t\tlet r = reject;\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(e);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onFulfill(v, i), onReject);\r\n\t\t\t\telse remaining.remove(i);\r\n\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a promise that is fulfilled with array of provided promises when all provided promises have resolved (fulfill or reject).\r\n\t * Unlike .all this method waits for all rejections as well as fulfillment.\r\n\t */\r\n\texport function waitAll<T>(promises:PromiseLike<T>[]):ArrayPromise<PromiseLike<T>>\r\n\texport function waitAll<T>(\r\n\t\tpromise:PromiseLike<T>,\r\n\t\t...rest:PromiseLike<T>[]):ArrayPromise<PromiseLike<T>>\r\n\texport function waitAll(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):ArrayPromise<PromiseLike<any>>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"promises\");\r\n\t\tvar promises = (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy!\r\n\t\tif(!promises.length || promises.every(v=>!v)) return new ArrayPromise<any>(\r\n\t\t\tr=>r(promises), true); // it's a new empty, reuse it. :|\r\n\r\n\r\n\t\t// Eliminate deferred and take the parent since all .then calls happen on next cycle anyway.\r\n\t\treturn new ArrayPromise<any>((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet len = promises.length;\r\n\r\n\t\t\t// Using a set instead of -- a number is more reliable if just in case one of the provided promises resolves twice.\r\n\t\t\tlet remaining = new Set(promises.map((v, i)=>i)); // get all the indexes...\r\n\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = NULL;\r\n\t\t\t\tresolve = NULL;\r\n\t\t\t\tremaining.dispose();\r\n\t\t\t\tremaining = NULL;\r\n\t\t\t};\r\n\r\n\t\t\tlet checkIfShouldResolve = ()=>\r\n\t\t\t{\r\n\t\t\t\tlet r = resolve;\r\n\t\t\t\tif(r && !remaining.count)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(promises);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolved = (i:number)=>\r\n\t\t\t{\r\n\t\t\t\tif(remaining)\r\n\t\t\t\t{\r\n\t\t\t\t\tremaining.remove(i);\r\n\t\t\t\t\tcheckIfShouldResolve();\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tfor(let i = 0; remaining && i<len; i++)\r\n\t\t\t{\r\n\t\t\t\tlet p = promises[i];\r\n\t\t\t\tif(p) p.then(v=>onResolved(i), e=>onResolved(i));\r\n\t\t\t\telse onResolved(i);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a Promise that is resolved or rejected when any of the provided Promises are resolved\r\n\t * or rejected.\r\n\t * @param promises An array of Promises.\r\n\t * @returns A new Promise.\r\n\t */\r\n\texport function race<T>(promises:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race<T>(promise:PromiseLike<T>, ...rest:PromiseLike<T>[]):PromiseBase<T>\r\n\texport function race(\r\n\t\tfirst:PromiseLike<any>|PromiseLike<any>[],\r\n\t\t...rest:PromiseLike<any>[]):PromiseBase<any>\r\n\t{\r\n\t\tvar promises = first && (Array.isArray(first) ? first : [first]).concat(rest); // yay a copy?\r\n\t\tif(!promises || !promises.length || !(promises = promises.filter(v=>v!=null)).length)\r\n\t\t\tthrow new ArgumentException(\"Nothing to wait for.\");\r\n\r\n\t\tvar len = promises.length;\r\n\r\n\t\t// Only one?  Nothing to race.\r\n\t\tif(len==1) return wrap(promises[0]);\r\n\r\n\t\t// Look for already resolved promises and the first one wins.\r\n\t\tfor(let i = 0; i<len; i++)\r\n\t\t{\r\n\t\t\tvar p:any = promises[i];\r\n\t\t\tif(p instanceof PromiseBase && p.isSettled) return p;\r\n\t\t}\r\n\r\n\t\treturn new Promise((resolve, reject)=>\r\n\t\t{\r\n\t\t\tlet cleanup = ()=>\r\n\t\t\t{\r\n\t\t\t\treject = NULL;\r\n\t\t\t\tresolve = NULL;\r\n\t\t\t\tpromises.length = 0;\r\n\t\t\t\tpromises = NULL;\r\n\t\t\t};\r\n\r\n\t\t\tlet onResolve = (r:(x:any)=>void, v:any)=>\r\n\t\t\t{\r\n\t\t\t\tif(r)\r\n\t\t\t\t{\r\n\t\t\t\t\tcleanup();\r\n\t\t\t\t\tr(v);\r\n\t\t\t\t}\r\n\t\t\t};\r\n\r\n\t\t\tlet onFulfill = (v:any)=> onResolve(resolve, v);\r\n\t\t\tlet onReject = (e?:any)=> onResolve(reject, e);\r\n\r\n\t\t\tfor(let p of promises)\r\n\t\t\t{\r\n\t\t\t\tif(!resolve) break;\r\n\t\t\t\tp.then(onFulfill, onReject);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t// // race<T>(values: Iterable<T | PromiseLike<T>>): Promise<T>;\r\n\r\n\t/**\r\n\t * Creates a new resolved promise .\r\n\t * @returns A resolved promise.\r\n\t */\r\n\texport function resolve():PromiseBase<void>\r\n\r\n\t/**\r\n\t * Creates a new resolved promise for the provided value.\r\n\t * @param value A value or promise.\r\n\t * @returns A promise whose internal state matches the provided promise.\r\n\t */\r\n\texport function resolve<T>(value:T | PromiseLike<T>):PromiseBase<T>;\r\n\texport function resolve(value?:any):PromiseBase<any>\r\n\t{\r\n\r\n\t\treturn isPromise(value) ? wrap(value) : new Fulfilled(value);\r\n\t}\r\n\r\n\t/**\r\n\t * Syntactic shortcut for avoiding 'new'.\r\n\t * @param resolver\r\n\t * @param forceSynchronous\r\n\t * @returns {Promise}\r\n\t */\r\n\texport function using<T>(\r\n\t\tresolver:Promise.Executor<T>,\r\n\t\tforceSynchronous:boolean = false):PromiseBase<T>\r\n\t{\r\n\t\treturn new Promise<T>(resolver, forceSynchronous);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes a set of values or promises and returns a PromiseCollection.\r\n\t * Similar to 'group' but calls resolve on each entry.\r\n\t * @param resolutions\r\n\t */\r\n\texport function resolveAll<T>(resolutions:Array<T | PromiseLike<T>>):PromiseCollection<T>;\r\n\texport function resolveAll<T>(\r\n\t\tpromise:T | PromiseLike<T>,\r\n\t\t...rest:Array<T | PromiseLike<T>>):PromiseCollection<T>\r\n\texport function resolveAll(\r\n\t\tfirst:any | PromiseLike<any>|Array<any | PromiseLike<any>>,\r\n\t\t...rest:Array<any | PromiseLike<any>>):PromiseCollection<any>\r\n\t{\r\n\t\tif(!first && !rest.length) throw new ArgumentNullException(\"resolutions\");\r\n\t\treturn new PromiseCollection(\r\n\t\t\t(Array.isArray(first) ? first : [first])\r\n\t\t\t\t.concat(rest)\r\n\t\t\t\t.map((v:any)=>resolve(v)));\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a PromiseCollection containing promises that will resolve on the next tick using the transform function.\r\n\t * This utility function does not chain promises together to create the result,\r\n\t * it only uses one promise per transform.\r\n\t * @param source\r\n\t * @param transform\r\n\t * @returns {PromiseCollection<T>}\r\n\t */\r\n\texport function map<T,U>(source:T[], transform:(value:T)=>U):PromiseCollection<U>\r\n\t{\r\n\t\treturn new PromiseCollection<U>(\r\n\t\t\tsource.map(d=>new Promise<U>((r, j)=>\r\n\t\t\t{\r\n\t\t\t\ttry\r\n\t\t\t\t{\r\n\t\t\t\t\tr(transform(d));\r\n\t\t\t\t}\r\n\t\t\t\tcatch(ex)\r\n\t\t\t\t{\r\n\t\t\t\t\tj(ex);\r\n\t\t\t\t}\r\n\t\t\t}))\r\n\t\t);\r\n\t}\r\n\r\n\t/**\r\n\t * Creates a new rejected promise for the provided reason.\r\n\t * @param reason The reason the promise was rejected.\r\n\t * @returns A new rejected Promise.\r\n\t */\r\n\texport function reject<T>(reason:T):PromiseBase<T>\r\n\t{\r\n\t\treturn new Rejected<T>(reason);\r\n\t}\r\n\r\n\t/**\r\n\t * Takes any Promise-Like object and ensures an extended version of it from this module.\r\n\t * @param target The Promise-Like object\r\n\t * @returns A new target that simply extends the target.\r\n\t */\r\n\texport function wrap<T>(target:T|PromiseLike<T>):PromiseBase<T>\r\n\t{\r\n\t\tif(!target) throw new ArgumentNullException(TARGET);\r\n\t\treturn isPromise(target)\r\n\t\t\t? (target instanceof PromiseBase ? target : new PromiseWrapper(target))\r\n\t\t\t: new Fulfilled<T>(target);\r\n\t}\r\n\r\n\t/**\r\n\t * A function that acts like a 'then' method (aka then-able) can be extended by providing a function that takes an onFulfill and onReject.\r\n\t * @param then\r\n\t * @returns {PromiseWrapper<T>}\r\n\t */\r\n\texport function createFrom<T,TResult>(then:Then<T,TResult>):PromiseBase<T>\r\n\t{\r\n\t\tif(!then) throw new ArgumentNullException(THEN);\r\n\t\treturn new PromiseWrapper({then: then});\r\n\t}\r\n\r\n}\r\n\r\n\r\ninterface IPromiseCallbacks<T>\r\n{\r\n\tonFulfilled:Promise.Fulfill<T,any>;\r\n\tonRejected?:Promise.Reject<any>;\r\n\tpromise?:Promise<any>;\r\n}\r\n\r\nexport default Promise;"]}