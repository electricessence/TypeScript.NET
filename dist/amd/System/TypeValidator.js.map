{"version":3,"sources":["System/TypeValidator.js","System/TypeValidator.ts"],"names":["define","require","exports","Types_1","Compare_1","extends_1","areInvalid","v","d","areEqual","memberType","TypeInfoHelper","contains","Object","defineProperty","value","__extends","_super","call","this","self","_value","prototype","descriptor","Function","isFunction","isObject","Array","isArray","String","isString","Number","isNumber","Boolean","isBoolean","type","isPrimitive","Type","isArrayLike","max","Math","min","length","i","targetKeys","keys","dKeys","_i","dKeys_1","key","indexOf","_a","dKeys_2","TypeInfo","TypeValidator","_typeDescriptor","freeze","isSubsetOf","o"],"mappings":";;;;AAkBAA,QAAQ,UAAW,UAAW,UAAW,YAAa,cAAe,SAAUC,EAASC,EAASC,EAASC,EAAWC,GACjH,YCuFJ,SAAAC,GAAoBC,EAAOC,GAE1B,IAAIJ,EAAAK,SAASF,EAAGC,GAChB,CACC,GAAIE,GAAa,GAAIC,GAAeJ,EACpC,KAAIG,EAAWE,SAASJ,GACvB,OAAO,EAET,OAAO,ED9FJK,OAAOC,eAAeZ,EAAS,cAAgBa,OAAO,GCG1D,IAAMC,GAAYX,EAAAA,WAGlBM,EAAA,SAAAM,GAKC,QAAAN,GAAYI,GDLD,MCOVE,GAAAC,KAAAC,KAAMJ,EAAO,SAAAK,GAAM,MAAAA,GAAKC,OAASN,KAAMI,KAuEzC,MA9EoCH,GAAAL,EAAAM,GAUnCN,EAAAW,UAAAV,SAAA,SAAsBW,GAGrB,GAAIR,GAAQI,KAAKE,MAEjB,IAAGN,IAAQQ,EACV,OAAO,CAER,QAAOA,GAEN,IAAKC,UACJ,MAAOL,MAAKM,UACb,KAAKZ,QACJ,MAAOM,MAAKO,QACb,KAAKC,OACJ,MAAOR,MAAKS,OACb,KAAKC,QACJ,MAAOV,MAAKW,QACb,KAAKC,QACJ,MAAOZ,MAAKa,QACb,KAAKC,SACJ,MAAOd,MAAKe,UAGd,GAAGf,KAAKgB,YAAcZ,IAAcJ,KAAKiB,cAAgBhC,EAAAK,SAASM,EAAOQ,GACxE,OAAO,CAGR,IAAGJ,KAAKS,SAAWzB,EAAAkC,KAAKC,YAAYf,GACpC,CAGC,IAAI,GAFAgB,GAAMC,KAAKC,IAAIlB,EAAWmB,OAAQ3B,EAAM2B,QAEpCC,EAAI,EAAGA,EAAEJ,EAAKI,IAErB,GAAGrC,EAAWS,EAAM4B,GAAIpB,EAAWoB,IAClC,OAAO,CAGT,QAAO,EAGR,GAAGxB,KAAKO,SACR,CACC,GAAIkB,GAAa/B,OAAOgC,KAAK9B,GACzB+B,EAAQjC,OAAOgC,KAAKtB,EAGxB,IAAGuB,EAAMJ,OAAOE,EAAWF,OAC1B,OAAO,CAGR,KAAe,GAAAK,GAAA,EAAAC,EAAAF,EAAAC,EAAAC,EAAAN,OAAAK,IAAK,CAAhB,GAAIE,GAAGD,EAAAD,EAEV,IAAGH,EAAWM,QAAQD,OACrB,OAAO,EAIT,IAAe,GAAAE,GAAA,EAAAC,EAAAN,EAAAK,EAAAC,EAAAV,OAAAS,IAAK,CAAhB,GAAIF,GAAGG,EAAAD,EAEV,IAAG7C,EAAWS,EAAMkC,GAAM1B,EAAW0B,IACpC,OAAO,GAIV,OAAO,GAGTtC,GA9EoCR,EAAAkD,SAAvBnD,GAAAS,eAAAA,CA2Fb,IAAA2C,GAAA,WAEC,QAAAA,GAA6BC,GAAApC,KAAAoC,gBAAAA,EAE5B1C,OAAO2C,OAAOrC,MAQhB,MALCmC,GAAAhC,UAAAmC,WAAA,SAAWC,GAEV,MAAO,IAAK/C,GAAe+C,GACzB9C,SAASO,KAAKoC,kBAElBD,IAZapD,GAAAoD,cAAAA,EAcbpD,EAAAA,WAAeoD","file":"TypeValidator.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT\n */\n/**\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\n *\n * var descriptor = {\n *      a : Object,\n *      b : String,\n *      c : {\n *          d : true ,\n *          e : Array,\n *          f : []\n *      },\n *      g : \"literal\"\n * }\n */\ndefine([\"require\", \"exports\", \"./Types\", \"./Compare\", \"../extends\"], function (require, exports, Types_1, Compare_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var TypeInfoHelper = (function (_super) {\n        __extends(TypeInfoHelper, _super);\n        function TypeInfoHelper(value) {\n            return _super.call(this, value, function (self) { return self._value = value; }) || this;\n        }\n        TypeInfoHelper.prototype.contains = function (descriptor) {\n            var value = this._value;\n            if (value === descriptor)\n                return true;\n            switch (descriptor) {\n                case Function:\n                    return this.isFunction;\n                case Object:\n                    return this.isObject;\n                case Array:\n                    return this.isArray;\n                case String:\n                    return this.isString;\n                case Number:\n                    return this.isNumber;\n                case Boolean:\n                    return this.isBoolean;\n            }\n            if (this.type != typeof descriptor || this.isPrimitive && !Compare_1.areEqual(value, descriptor))\n                return false;\n            // Check array contents and confirm intersections.\n            if (this.isArray && Types_1.Type.isArrayLike(descriptor)) {\n                var max = Math.min(descriptor.length, value.length);\n                for (var i = 0; i < max; i++) {\n                    if (areInvalid(value[i], descriptor[i]))\n                        return false;\n                }\n                return true;\n            }\n            if (this.isObject) {\n                var targetKeys = Object.keys(value);\n                var dKeys = Object.keys(descriptor);\n                // Quick check...\n                if (dKeys.length > targetKeys.length)\n                    return false;\n                // Quick check #2...\n                for (var _i = 0, dKeys_1 = dKeys; _i < dKeys_1.length; _i++) {\n                    var key = dKeys_1[_i];\n                    if (targetKeys.indexOf(key) == -1)\n                        return false;\n                }\n                // Final pass with recursive...\n                for (var _a = 0, dKeys_2 = dKeys; _a < dKeys_2.length; _a++) {\n                    var key = dKeys_2[_a];\n                    if (areInvalid(value[key], descriptor[key]))\n                        return false;\n                }\n            }\n            return true;\n        };\n        return TypeInfoHelper;\n    }(Types_1.TypeInfo));\n    exports.TypeInfoHelper = TypeInfoHelper;\n    function areInvalid(v, d) {\n        if (!Compare_1.areEqual(v, d)) {\n            var memberType = new TypeInfoHelper(v);\n            if (!memberType.contains(d))\n                return true;\n        }\n        return false;\n    }\n    var TypeValidator = (function () {\n        function TypeValidator(_typeDescriptor) {\n            this._typeDescriptor = _typeDescriptor;\n            Object.freeze(this);\n        }\n        TypeValidator.prototype.isSubsetOf = function (o) {\n            return (new TypeInfoHelper(o))\n                .contains(this._typeDescriptor);\n        };\n        return TypeValidator;\n    }());\n    exports.TypeValidator = TypeValidator;\n    exports.default = TypeValidator;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT\r\n */\r\n/**\r\n * A descriptor is simply a JSON tree that either has an actual value or a type that identifies what the expect type should be at that leaf in the tree.\r\n *\r\n * var descriptor = {\r\n *      a : Object,\r\n *      b : String,\r\n *      c : {\r\n *          d : true ,\r\n *          e : Array,\r\n *          f : []\r\n *      },\r\n *      g : \"literal\"\r\n * }\r\n */\r\n\r\nimport {Type, TypeInfo} from \"./Types\";\r\nimport {areEqual} from \"./Compare\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\n\r\nexport class TypeInfoHelper extends TypeInfo\r\n{\r\n\r\n\tprivate _value:any;\r\n\r\n\tconstructor(value:any)\r\n\t{\r\n\t\tsuper(value, self=>self._value = value);\r\n\t}\r\n\r\n\tcontains<TDescriptor>(descriptor:any):this is TDescriptor\r\n\t{\r\n\r\n\t\tlet value = this._value;\r\n\r\n\t\tif(value===descriptor)\r\n\t\t\treturn true;\r\n\r\n\t\tswitch(descriptor)\r\n\t\t{\r\n\t\t\tcase Function:\r\n\t\t\t\treturn this.isFunction;\r\n\t\t\tcase Object:\r\n\t\t\t\treturn this.isObject;\r\n\t\t\tcase Array:\r\n\t\t\t\treturn this.isArray;\r\n\t\t\tcase String:\r\n\t\t\t\treturn this.isString;\r\n\t\t\tcase Number:\r\n\t\t\t\treturn this.isNumber;\r\n\t\t\tcase Boolean:\r\n\t\t\t\treturn this.isBoolean;\r\n\t\t}\r\n\r\n\t\tif(this.type!= typeof descriptor || this.isPrimitive && !areEqual(value, descriptor))\r\n\t\t\treturn false;\r\n\r\n\t\t// Check array contents and confirm intersections.\r\n\t\tif(this.isArray && Type.isArrayLike(descriptor))\r\n\t\t{\r\n\t\t\tlet max = Math.min(descriptor.length, value.length);\r\n\r\n\t\t\tfor(let i = 0; i<max; i++)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[i], descriptor[i]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\tif(this.isObject)\r\n\t\t{\r\n\t\t\tlet targetKeys = Object.keys(value);\r\n\t\t\tlet dKeys = Object.keys(descriptor);\r\n\r\n\t\t\t// Quick check...\r\n\t\t\tif(dKeys.length>targetKeys.length)\r\n\t\t\t\treturn false;\r\n\r\n\t\t\t// Quick check #2...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(targetKeys.indexOf(key)== -1)\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\r\n\t\t\t// Final pass with recursive...\r\n\t\t\tfor(let key of dKeys)\r\n\t\t\t{\r\n\t\t\t\tif(areInvalid(value[key], descriptor[key]))\r\n\t\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\nfunction areInvalid(v:any, d:any)\r\n{\r\n\tif(!areEqual(v, d))\r\n\t{\r\n\t\tlet memberType = new TypeInfoHelper(v);\r\n\t\tif(!memberType.contains(d))\r\n\t\t\treturn true;\r\n\t}\r\n\treturn false;\r\n}\r\n\r\nexport class TypeValidator<T>\r\n{\r\n\tconstructor(private readonly _typeDescriptor:any)\r\n\t{\r\n\t\tObject.freeze(this);\r\n\t}\r\n\r\n\tisSubsetOf(o:any):o is T\r\n\t{\r\n\t\treturn (new TypeInfoHelper(o))\r\n\t\t\t.contains(this._typeDescriptor);\r\n\t}\r\n}\r\n\r\nexport default TypeValidator;\r\n\r\n"]}