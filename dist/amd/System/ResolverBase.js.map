{"version":3,"sources":["System/ResolverBase.js","System/ResolverBase.ts"],"names":["define","require","exports","DisposableBase_1","ArgumentNullException_1","extends_1","Object","defineProperty","value","__extends","NULL","NAME","ResolverBase","_super","_valueFactory","_trapExceptions","_allowReset","_this","call","this","ArgumentNullException","_isValueCreated","prototype","getError","_error","get","enumerable","configurable","getValue","_","throwIfDisposed","Error","c","v","_value","ex","_onDispose","tryReset","DisposableBase"],"mappings":";;;;AAIAA,QAAQ,UAAW,UAAW,8BAA+B,qCAAsC,cAAe,SAAUC,EAASC,EAASC,EAAkBC,EAAyBC,GACrL,YACAC,QAAOC,eAAeL,EAAS,cAAgBM,OAAO,GCI1D,IAAMC,GAAYJ,EAAAA,WACZK,EAAW,KACXC,EAAc,eAQpBC,EAAA,SAAAC,GAMC,QAAAD,GACWE,EACOC,EACAC,GAAA,SAAAA,IAAAA,GAAA,EAHlB,IAAAC,GAKCJ,EAAAK,KAAAC,KAAMR,IAAKQ,IACX,IALUF,EAAAH,cAAAA,EACOG,EAAAF,gBAAAA,EACAE,EAAAD,YAAAA,GAGbF,EAAe,KAAM,IAAIV,GAAAgB,sBAAsB,eDJzC,OCKVH,GAAKI,iBAAkB,EDLNJ,ECyFnB,MAjG8CR,GAAAG,EAAAC,GAkBnCD,EAAAU,UAAAC,SAAV,WAEC,MAAOJ,MAAKK,QAGblB,OAAAC,eAAIK,EAAAU,UAAA,SDTOG,ICSX,WAEC,MAAON,MAAKI,YDRFG,YAAY,EACZC,cAAc,ICUzBf,EAAAU,UAAAM,SAAA,WAGC,GAAMC,GAAIV,IAGV,IAFAU,EAAEC,kBAEqB,OAApBD,EAAER,gBACJ,KAAM,IAAIU,OAAM,sBAEjB,KAAIF,EAAER,iBAAmBQ,EAAEf,cAC3B,CACCe,EAAER,gBAAkB,IACpB,KAEC,GAAIW,GAAC,MACL,KAAIH,EAAER,kBAAoBW,EAAIH,EAAEf,eAChC,CACCe,EAAER,gBAAkB,KAChBF,KAAKH,cAAaG,KAAKL,cAAgBJ,EAC3C,IAAMuB,GAAID,GAGV,OAFAH,GAAEK,OAASD,EACXJ,EAAEL,OAAS,OACJS,GAGT,MAAME,GAGL,GADAN,EAAEL,OAASW,GACPN,EAAEd,gBAAiB,KAAMoB,GDZjB,QCgBZN,EAAER,iBAAkB,GAMtB,MAAOQ,GAAEK,QAIV5B,OAAAC,eAAIK,EAAAU,UAAA,YDnBOG,ICmBX,WAEC,MAAON,MAAKH,eAAiBG,KAAKL,eDlBxBY,YAAY,EACZC,cAAc,ICoBff,EAAAU,UAAAc,WAAV,WAECjB,KAAKL,cAAgBJ,EACrBS,KAAKe,OAASxB,EACdS,KAAKE,gBAAkBX,GAGxBE,EAAAU,UAAAe,SAAA,WAEC,GAAMR,GAAIV,IAEV,SAAIU,EAAEf,gBAILe,EAAER,iBAAkB,EACpBQ,EAAEK,OAASxB,EACXmB,EAAEL,OAAS,QACJ,IAIVZ,GAjG8CT,EAAAmC,eAAxBpC,GAAAU,aAAAA,EAmGtBV,EAAAA,WAAeU","file":"ResolverBase.js","sourcesContent":["/*!\n * @author electricessence / https://github.com/electricessence/\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n */\ndefine([\"require\", \"exports\", \"./Disposable/DisposableBase\", \"./Exceptions/ArgumentNullException\", \"../extends\"], function (require, exports, DisposableBase_1, ArgumentNullException_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var NULL = null;\n    var NAME = \"ResolverBase\";\n    /**\n     * The ResolverBase class handles resolving a factory method and detects recursion.\n     * Since JS does not have a synchronization mechanism (lock or otherwise)\n     * we have to prevent getValue from double triggering the value factory (optimistic concurrency)\n     * or returning return a value that is intermediate between resolving and resolved.\n     */\n    var ResolverBase = /** @class */ (function (_super) {\n        __extends(ResolverBase, _super);\n        function ResolverBase(_valueFactory, _trapExceptions, _allowReset) {\n            if (_allowReset === void 0) { _allowReset = false; }\n            var _this = _super.call(this, NAME) || this;\n            _this._valueFactory = _valueFactory;\n            _this._trapExceptions = _trapExceptions;\n            _this._allowReset = _allowReset;\n            if (!_valueFactory)\n                throw new ArgumentNullException_1.ArgumentNullException(\"valueFactory\");\n            _this._isValueCreated = false;\n            return _this;\n        }\n        ResolverBase.prototype.getError = function () {\n            return this._error;\n        };\n        Object.defineProperty(ResolverBase.prototype, \"error\", {\n            get: function () {\n                return this.getError();\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ResolverBase.prototype.getValue = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            if (_._isValueCreated === null)\n                throw new Error(\"Recursion detected.\");\n            if (!_._isValueCreated && _._valueFactory) {\n                _._isValueCreated = null; // Mark this as 'resolving'.\n                try {\n                    var c = void 0;\n                    if (!_._isValueCreated && (c = _._valueFactory)) {\n                        _._isValueCreated = null; // Mark this as 'resolving'.\n                        if (!this._allowReset)\n                            this._valueFactory = NULL;\n                        var v = c();\n                        _._value = v;\n                        _._error = void 0;\n                        return v;\n                    }\n                }\n                catch (ex) {\n                    _._error = ex;\n                    if (!_._trapExceptions)\n                        throw ex;\n                }\n                finally {\n                    _._isValueCreated = true;\n                }\n            }\n            return _._value;\n        };\n        Object.defineProperty(ResolverBase.prototype, \"canReset\", {\n            get: function () {\n                return this._allowReset && !!this._valueFactory;\n            },\n            enumerable: true,\n            configurable: true\n        });\n        ResolverBase.prototype._onDispose = function () {\n            this._valueFactory = NULL;\n            this._value = NULL;\n            this._isValueCreated = NULL;\n        };\n        ResolverBase.prototype.tryReset = function () {\n            var _ = this;\n            if (!_._valueFactory)\n                return false;\n            else {\n                _._isValueCreated = false;\n                _._value = NULL;\n                _._error = void 0;\n                return true;\n            }\n        };\n        return ResolverBase;\n    }(DisposableBase_1.DisposableBase));\n    exports.ResolverBase = ResolverBase;\n    exports.default = ResolverBase;\n});\n","/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {DisposableBase} from \"./Disposable/DisposableBase\";\r\nimport {Func} from \"./FunctionTypes\";\r\nimport {ArgumentNullException} from \"./Exceptions/ArgumentNullException\";\r\nimport __extendsImport from \"../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\nconst NULL:any = null;\r\nconst NAME:string = \"ResolverBase\";\r\n\r\n/**\r\n * The ResolverBase class handles resolving a factory method and detects recursion.\r\n * Since JS does not have a synchronization mechanism (lock or otherwise)\r\n * we have to prevent getValue from double triggering the value factory (optimistic concurrency)\r\n * or returning return a value that is intermediate between resolving and resolved.\r\n */\r\nexport abstract class ResolverBase<T> extends DisposableBase\r\n{\r\n\r\n\tprotected _isValueCreated:boolean|null; // null = 'creating'\r\n\tprotected _value:T|undefined;\r\n\r\n\tconstructor(\r\n\t\tprotected _valueFactory:Func<T>,\r\n\t\tprivate readonly _trapExceptions:boolean,\r\n\t\tprivate readonly _allowReset:boolean = false)\r\n\t{\r\n\t\tsuper(NAME);\r\n\t\tif(!_valueFactory) throw new ArgumentNullException(\"valueFactory\");\r\n\t\tthis._isValueCreated = false;\r\n\t}\r\n\r\n\tprotected _error:any;\r\n\r\n\tprotected getError():any\r\n\t{\r\n\t\treturn this._error;\r\n\t}\r\n\r\n\tget error():any\r\n\t{\r\n\t\treturn this.getError();\r\n\t}\r\n\r\n\tgetValue():T\r\n\t{\r\n\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tif(_._isValueCreated===null)\r\n\t\t\tthrow new Error(\"Recursion detected.\");\r\n\r\n\t\tif(!_._isValueCreated && _._valueFactory)\r\n\t\t{\r\n\t\t\t_._isValueCreated = null; // Mark this as 'resolving'.\r\n\t\t\ttry\r\n\t\t\t{\r\n\t\t\t\tlet c:Func<T>;\r\n\t\t\t\tif(!_._isValueCreated && (c = _._valueFactory))\r\n\t\t\t\t{\r\n\t\t\t\t\t_._isValueCreated = null; // Mark this as 'resolving'.\r\n\t\t\t\t\tif(!this._allowReset) this._valueFactory = NULL;\r\n\t\t\t\t\tconst v = c();\r\n\t\t\t\t\t_._value = v;\r\n\t\t\t\t\t_._error = void 0;\r\n\t\t\t\t\treturn v;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tcatch(ex)\r\n\t\t\t{\r\n\t\t\t\t_._error = ex;\r\n\t\t\t\tif(!_._trapExceptions) throw ex;\r\n\t\t\t}\r\n\t\t\tfinally\r\n\t\t\t{\r\n\t\t\t\t_._isValueCreated = true;\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\r\n\t\treturn _._value!;\r\n\r\n\t}\r\n\r\n\tget canReset():boolean\r\n\t{\r\n\t\treturn this._allowReset && !!this._valueFactory;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tthis._valueFactory = NULL;\r\n\t\tthis._value = NULL;\r\n\t\tthis._isValueCreated = NULL;\r\n\t}\r\n\r\n\ttryReset():boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\r\n\t\tif(!_._valueFactory)\r\n\t\t\treturn false;\r\n\t\telse\r\n\t\t{\r\n\t\t\t_._isValueCreated = false;\r\n\t\t\t_._value = NULL;\r\n\t\t\t_._error = void 0;\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\nexport default ResolverBase;"]}