{"version":3,"sources":["System/Collections/Queue.js","System/Collections/Queue.ts"],"names":["define","require","exports","Compare_1","AU","Types_1","Integer_1","EnumeratorBase_1","NotImplementedException_1","InvalidOperationException_1","ArgumentOutOfRangeException_1","CollectionBase_1","extends_1","assertZeroOrGreater","value","property","ArgumentOutOfRangeException","assertIntegerZeroOrGreater","Integer","assert","Object","defineProperty","__extends","VOID0","MINIMUM_GROW","SHRINK_THRESHOLD","GROW_FACTOR_HALF","DEFAULT_CAPACITY","emptyArray","freeze","Queue","_super","source","equalityComparer","areEqual","_this","call","this","_head","_tail","_size","Type","isNumber","capacity","_array","initialize","se","isArrayLike","length","_importEntries","_capacity","prototype","getCount","_addInternal","item","_","size","len","newCapacity","setCapacity","tail","_removeInternal","max","NotImplementedException","_clearInternal","array","head","clear","trimExcess","_onDispose","dump","Infinity","result","isFinite","_tryDequeueInternal","push","_signalModification","forEach","action","throwIfDisposed","_version","newArray","copyTo","enqueue","add","out","removed","_incrementModified","dequeue","throwIfEmpty","assertModifiable","tryDequeue","InvalidOperationException","_getElement","index","peek","threshold","Math","floor","isNaN","getEnumerator","version","EnumeratorBase","yielder","assertVersion","yieldBreak","yieldReturn","CollectionBase"],"mappings":"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","file":"Queue.js","sourcesContent":["/*!\n* @author electricessence / https://github.com/electricessence/\n* Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\n* Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\n*/\ndefine([\"require\", \"exports\", \"../Compare\", \"./Array/Utility\", \"../Types\", \"../Integer\", \"./Enumeration/EnumeratorBase\", \"../Exceptions/NotImplementedException\", \"../Exceptions/InvalidOperationException\", \"../Exceptions/ArgumentOutOfRangeException\", \"./CollectionBase\", \"../../extends\"], function (require, exports, Compare_1, AU, Types_1, Integer_1, EnumeratorBase_1, NotImplementedException_1, InvalidOperationException_1, ArgumentOutOfRangeException_1, CollectionBase_1, extends_1) {\n    \"use strict\";\n    Object.defineProperty(exports, \"__esModule\", { value: true });\n    // noinspection JSUnusedLocalSymbols\n    var __extends = extends_1.default;\n    var VOID0 = void 0;\n    var MINIMUM_GROW = 4;\n    var SHRINK_THRESHOLD = 32; // Unused?\n    // var GROW_FACTOR: number = 200;  // double each time\n    var GROW_FACTOR_HALF = 100;\n    var DEFAULT_CAPACITY = MINIMUM_GROW;\n    var emptyArray = Object.freeze([]);\n    var Queue = /** @class */ (function (_super) {\n        __extends(Queue, _super);\n        function Queue(source, equalityComparer) {\n            if (equalityComparer === void 0) { equalityComparer = Compare_1.areEqual; }\n            var _this = _super.call(this, VOID0, equalityComparer) || this;\n            _this._head = 0;\n            _this._tail = 0;\n            _this._size = 0;\n            if (!source)\n                _this._array = emptyArray;\n            else {\n                if (Types_1.Type.isNumber(source)) {\n                    var capacity = source;\n                    assertIntegerZeroOrGreater(capacity, \"capacity\");\n                    _this._array = capacity\n                        ? AU.initialize(capacity)\n                        : emptyArray;\n                }\n                else {\n                    var se = source;\n                    _this._array = AU.initialize(Types_1.Type.isArrayLike(se)\n                        ? se.length\n                        : DEFAULT_CAPACITY);\n                    _this._importEntries(se);\n                }\n            }\n            _this._capacity = _this._array.length;\n            return _this;\n        }\n        Queue.prototype.getCount = function () {\n            return this._size;\n        };\n        Queue.prototype._addInternal = function (item) {\n            var _ = this;\n            var size = _._size;\n            var len = _._capacity;\n            if (size == len) {\n                var newCapacity = len * GROW_FACTOR_HALF;\n                if (newCapacity < len + MINIMUM_GROW)\n                    newCapacity = len + MINIMUM_GROW;\n                _.setCapacity(newCapacity);\n                len = _._capacity;\n            }\n            var tail = _._tail;\n            _._array[tail] = item;\n            _._tail = (tail + 1) % len;\n            _._size = size + 1;\n            return true;\n        };\n        //noinspection JSUnusedLocalSymbols\n        Queue.prototype._removeInternal = function (item, max) {\n            //noinspection HtmlUnknownTag\n            throw new NotImplementedException_1.NotImplementedException(\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\n                \" since it would require destroying the underlying array to remove the item.\");\n        };\n        Queue.prototype._clearInternal = function () {\n            var _ = this;\n            var array = _._array, head = _._head, tail = _._tail, size = _._size;\n            if (head < tail)\n                AU.clear(array, head, tail);\n            else {\n                AU.clear(array, head);\n                AU.clear(array, 0, tail);\n            }\n            _._head = 0;\n            _._tail = 0;\n            _._size = 0;\n            _.trimExcess();\n            return size;\n        };\n        Queue.prototype._onDispose = function () {\n            _super.prototype._onDispose.call(this);\n            var _ = this;\n            if (_._array != emptyArray) {\n                _._array.length = _._capacity = 0;\n                _._array = emptyArray;\n            }\n        };\n        /**\n         * Dequeues entries into an array.\n         */\n        Queue.prototype.dump = function (max) {\n            if (max === void 0) { max = Infinity; }\n            var _ = this;\n            var result = [];\n            if (isFinite(max)) {\n                Integer_1.Integer.assertZeroOrGreater(max);\n                if (max !== 0) {\n                    while (max-- && _._tryDequeueInternal(function (value) {\n                        result.push(value);\n                    })) { }\n                }\n            }\n            else {\n                while (_._tryDequeueInternal(function (value) {\n                    result.push(value);\n                })) { }\n            }\n            _.trimExcess();\n            _._signalModification();\n            return result;\n        };\n        Queue.prototype.forEach = function (action) {\n            return _super.prototype.forEach.call(this, action, true);\n        };\n        Queue.prototype.setCapacity = function (capacity) {\n            var _ = this;\n            assertIntegerZeroOrGreater(capacity, \"capacity\");\n            var array = _._array, len = _._capacity;\n            if (capacity > len)\n                _.throwIfDisposed();\n            if (capacity == len)\n                return this;\n            var head = _._head, tail = _._tail, size = _._size;\n            // Special case where we can simply extend the length of the array. (JavaScript only)\n            if (array != emptyArray && capacity > len && head < tail) {\n                array.length = _._capacity = capacity;\n                _._version++;\n                return this;\n            }\n            // We create a new array because modifying an existing one could be slow.\n            var newArray = AU.initialize(capacity);\n            if (size > 0) {\n                if (head < tail) {\n                    AU.copyTo(array, newArray, head, 0, size);\n                }\n                else {\n                    AU.copyTo(array, newArray, head, 0, len - head);\n                    AU.copyTo(array, newArray, 0, len - head, tail);\n                }\n            }\n            _._array = newArray;\n            _._capacity = capacity;\n            _._head = 0;\n            _._tail = (size == capacity) ? 0 : size;\n            _._signalModification(true);\n            return this;\n        };\n        Queue.prototype.enqueue = function (item) {\n            return this.add(item);\n        };\n        Queue.prototype._tryDequeueInternal = function (out) {\n            var _ = this;\n            if (!_._size)\n                return false;\n            var array = _._array, head = _._head;\n            var removed = _._array[head];\n            array[head] = null;\n            _._head = (head + 1) % _._capacity;\n            _._size--;\n            _._incrementModified();\n            out(removed);\n            return true;\n        };\n        Queue.prototype.dequeue = function (throwIfEmpty) {\n            if (throwIfEmpty === void 0) { throwIfEmpty = false; }\n            var _ = this;\n            _.assertModifiable();\n            var result = VOID0;\n            if (!this.tryDequeue(function (value) { result = value; }) && throwIfEmpty)\n                throw new InvalidOperationException_1.InvalidOperationException(\"Cannot dequeue an empty queue.\");\n            return result;\n        };\n        /**\n         * Checks to see if the queue has entries an pulls an entry from the head of the queue and passes it to the out handler.\n         * @param out The 'out' handler that receives the value if it exists.\n         * @returns {boolean} True if a value was retrieved.  False if not.\n         */\n        Queue.prototype.tryDequeue = function (out) {\n            var _ = this;\n            if (!_._size)\n                return false;\n            _.assertModifiable();\n            // A single dequeue shouldn't need update recursion tracking...\n            if (this._tryDequeueInternal(out)) {\n                // This may preemptively trigger the _onModified.\n                if (_._size < _._capacity / 2)\n                    _.trimExcess(SHRINK_THRESHOLD);\n                _._signalModification();\n                return true;\n            }\n            return false;\n        };\n        Queue.prototype._getElement = function (index) {\n            assertIntegerZeroOrGreater(index, \"index\");\n            var _ = this;\n            return _._array[(_._head + index) % _._capacity];\n        };\n        Queue.prototype.peek = function (throwIfEmpty) {\n            if (throwIfEmpty === void 0) { throwIfEmpty = false; }\n            if (this._size == 0) {\n                if (throwIfEmpty)\n                    throw new InvalidOperationException_1.InvalidOperationException(\"Cannot call peek on an empty queue.\");\n                return VOID0;\n            }\n            return this._array[this._head];\n        };\n        Queue.prototype.trimExcess = function (threshold) {\n            var _ = this;\n            var size = _._size;\n            if (size < Math.floor(_._capacity * 0.9) && (!threshold && threshold !== 0 || isNaN(threshold) || threshold < size))\n                _.setCapacity(size);\n        };\n        Queue.prototype.getEnumerator = function () {\n            var _ = this;\n            _.throwIfDisposed();\n            var index, version, size;\n            return new EnumeratorBase_1.EnumeratorBase(function () {\n                version = _._version;\n                size = _._size;\n                index = 0;\n            }, function (yielder) {\n                _.throwIfDisposed();\n                _.assertVersion(version);\n                if (index == size)\n                    return yielder.yieldBreak();\n                return yielder.yieldReturn(_._getElement(index++));\n            });\n        };\n        return Queue;\n    }(CollectionBase_1.CollectionBase));\n    exports.Queue = Queue;\n    function assertZeroOrGreater(value, property) {\n        if (value < 0)\n            throw new ArgumentOutOfRangeException_1.ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\n        return true;\n    }\n    function assertIntegerZeroOrGreater(value, property) {\n        Integer_1.Integer.assert(value, property);\n        return assertZeroOrGreater(value, property);\n    }\n    exports.default = Queue;\n});\n","ï»¿/*!\r\n * @author electricessence / https://github.com/electricessence/\r\n * Based Upon: http://referencesource.microsoft.com/#System/CompMod/system/collections/generic/queue.cs\r\n * Licensing: MIT https://github.com/electricessence/TypeScript.NET/blob/master/LICENSE.md\r\n */\r\n\r\nimport {areEqual} from \"../Compare\";\r\nimport * as AU from \"./Array/Utility\";\r\nimport {Type} from \"../Types\";\r\nimport {Integer} from \"../Integer\";\r\nimport {EnumeratorBase} from \"./Enumeration/EnumeratorBase\";\r\nimport {NotImplementedException} from \"../Exceptions/NotImplementedException\";\r\nimport {InvalidOperationException} from \"../Exceptions/InvalidOperationException\";\r\nimport {ArgumentOutOfRangeException} from \"../Exceptions/ArgumentOutOfRangeException\";\r\nimport {CollectionBase} from \"./CollectionBase\";\r\nimport {Action, ActionWithIndex, EqualityComparison, PredicateWithIndex} from \"../FunctionTypes\";\r\nimport {IEnumerator} from \"./Enumeration/IEnumerator\";\r\nimport {IEnumerableOrArray} from \"./IEnumerableOrArray\";\r\nimport __extendsImport from \"../../extends\";\r\n// noinspection JSUnusedLocalSymbols\r\nconst __extends = __extendsImport;\r\n\r\nconst VOID0:undefined = void 0;\r\nconst MINIMUM_GROW:number = 4;\r\nconst SHRINK_THRESHOLD:number = 32; // Unused?\r\n// var GROW_FACTOR: number = 200;  // double each time\r\nconst GROW_FACTOR_HALF:number = 100;\r\nconst DEFAULT_CAPACITY:number = MINIMUM_GROW;\r\nconst emptyArray:any = Object.freeze([]);\r\n\r\nexport class Queue<T>\r\nextends CollectionBase<T>\r\n{\r\n\r\n\tprivate _array:T[];\r\n\tprivate _head:number;       // First valid element in the queue\r\n\tprivate _tail:number;       // Last valid element in the queue\r\n\tprivate _size:number;       // Number of elements.\r\n\tprivate _capacity:number;   // Maps to _array.length;\r\n\r\n\tconstructor(\r\n\t\tsource?:IEnumerableOrArray<T> | number,\r\n\t\tequalityComparer:EqualityComparison<T> = areEqual)\r\n\t{\r\n\t\tsuper(VOID0, equalityComparer);\r\n\t\tthis._head = 0;\r\n\t\tthis._tail = 0;\r\n\t\tthis._size = 0;\r\n\r\n\t\tif(!source)\r\n\t\t\tthis._array = emptyArray;\r\n\t\telse\r\n\t\t{\r\n\t\t\tif(Type.isNumber(source))\r\n\t\t\t{\r\n\t\t\t\tconst capacity = <number>source;\r\n\t\t\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\t\t\tthis._array = capacity\r\n\t\t\t\t\t? AU.initialize<T>(capacity)\r\n\t\t\t\t\t: emptyArray;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tconst se = <IEnumerableOrArray<T>> source;\r\n\t\t\t\tthis._array = AU.initialize<T>(\r\n\t\t\t\t\tType.isArrayLike(se)\r\n\t\t\t\t\t\t? se.length\r\n\t\t\t\t\t\t: DEFAULT_CAPACITY\r\n\t\t\t\t);\r\n\r\n\t\t\t\tthis._importEntries(se);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis._capacity = this._array.length;\r\n\t}\r\n\r\n\tprotected getCount():number\r\n\t{\r\n\t\treturn this._size;\r\n\t}\r\n\r\n\tprotected _addInternal(item:T):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst size = _._size;\r\n\t\tlet len = _._capacity;\r\n\t\tif(size==len)\r\n\t\t{\r\n\t\t\tlet newCapacity = len*GROW_FACTOR_HALF;\r\n\t\t\tif(newCapacity<len + MINIMUM_GROW)\r\n\t\t\t\tnewCapacity = len + MINIMUM_GROW;\r\n\r\n\t\t\t_.setCapacity(newCapacity);\r\n\t\t\tlen = _._capacity;\r\n\t\t}\r\n\r\n\t\tconst tail = _._tail;\r\n\t\t_._array[tail] = item;\r\n\t\t_._tail = (tail + 1)%len;\r\n\t\t_._size = size + 1;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t//noinspection JSUnusedLocalSymbols\r\n\tprotected _removeInternal(item:T, max?:number):number\r\n\t{\r\n\t\t//noinspection HtmlUnknownTag\r\n\t\tthrow new NotImplementedException(\r\n\t\t\t\"ICollection\\<T\\>.remove is not implemented in Queue\\<T\\>\" +\r\n\t\t\t\" since it would require destroying the underlying array to remove the item.\"\r\n\t\t);\r\n\t}\r\n\r\n\tprotected _clearInternal():number\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst array = _._array, head = _._head, tail = _._tail, size = _._size;\r\n\t\tif(head<tail)\r\n\t\t\tAU.clear(array, head, tail);\r\n\t\telse\r\n\t\t{\r\n\t\t\tAU.clear(array, head);\r\n\t\t\tAU.clear(array, 0, tail);\r\n\t\t}\r\n\r\n\t\t_._head = 0;\r\n\t\t_._tail = 0;\r\n\t\t_._size = 0;\r\n\r\n\t\t_.trimExcess();\r\n\r\n\t\treturn size;\r\n\t}\r\n\r\n\tprotected _onDispose():void\r\n\t{\r\n\t\tsuper._onDispose();\r\n\t\tconst _ = this;\r\n\t\tif(_._array!=emptyArray)\r\n\t\t{\r\n\t\t\t_._array.length = _._capacity = 0;\r\n\t\t\t_._array = emptyArray;\r\n\t\t}\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * Dequeues entries into an array.\r\n\t */\r\n\tdump(max:number = Infinity):T[]\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst result:T[] = [];\r\n\r\n\t\tif(isFinite(max))\r\n\t\t{\r\n\t\t\tInteger.assertZeroOrGreater(max);\r\n\t\t\tif(max!==0)\r\n\t\t\t{\r\n\t\t\t\twhile(max-- && _._tryDequeueInternal(value=>{\r\n\t\t\t\t\tresult.push(value);\r\n\t\t\t\t})) {}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\twhile( _._tryDequeueInternal(value=>{\r\n\t\t\t\tresult.push(value);\r\n\t\t\t})) { }\r\n\t\t}\r\n\r\n\t\t_.trimExcess();\r\n\t\t_._signalModification();\r\n\r\n\t\treturn result;\r\n\t}\r\n\r\n\tforEach(action:ActionWithIndex<T>):number\r\n\tforEach(action:PredicateWithIndex<T>):number\r\n\tforEach(action:ActionWithIndex<T> | PredicateWithIndex<T>):number\r\n\t{\r\n\t\treturn super.forEach(action, true);\r\n\t}\r\n\r\n\tsetCapacity(capacity:number):this\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tassertIntegerZeroOrGreater(capacity, \"capacity\");\r\n\r\n\t\tconst array = _._array, len = _._capacity;\r\n\t\tif(capacity>len) _.throwIfDisposed();\r\n\t\tif(capacity==len)\r\n\t\t\treturn this;\r\n\r\n\t\tconst head = _._head, tail = _._tail, size = _._size;\r\n\r\n\t\t// Special case where we can simply extend the length of the array. (JavaScript only)\r\n\t\tif(array!=emptyArray && capacity>len && head<tail)\r\n\t\t{\r\n\t\t\tarray.length = _._capacity = capacity;\r\n\t\t\t_._version++;\r\n\t\t\treturn this;\r\n\t\t}\r\n\r\n\t\t// We create a new array because modifying an existing one could be slow.\r\n\t\tconst newArray:T[] = AU.initialize<T>(capacity);\r\n\t\tif(size>0)\r\n\t\t{\r\n\t\t\tif(head<tail)\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, size);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tAU.copyTo(array, newArray, head, 0, len - head);\r\n\t\t\t\tAU.copyTo(array, newArray, 0, len - head, tail);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t_._array = newArray;\r\n\t\t_._capacity = capacity;\r\n\t\t_._head = 0;\r\n\t\t_._tail = (size==capacity) ? 0 : size;\r\n\r\n\t\t_._signalModification(true);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\tenqueue(item:T):this\r\n\t{\r\n\t\treturn this.add(item);\r\n\t}\r\n\r\n\tprotected _tryDequeueInternal(out:Action<T>):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(!_._size) return false;\r\n\r\n\t\tconst array = _._array, head = _._head;\r\n\r\n\t\tconst removed = _._array[head];\r\n\t\tarray[head] = <any>null;\r\n\t\t_._head = (head + 1)%_._capacity;\r\n\r\n\t\t_._size--;\r\n\r\n\t\t_._incrementModified();\r\n\r\n\t\tout(removed);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * Pulls an entry from the head of the queue and returns it.\r\n\t * Returns undefined if the queue is already empty.\r\n\t */\r\n\tdequeue():T|undefined\r\n\r\n\t/**\r\n\t * Pulls an entry from the head of the queue and returns it.\r\n\t * Returns undefined if the queue is already empty and throwIfEmpty is false.\r\n\t * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.\r\n\t * @param throwIfEmpty\r\n\t */\r\n\tdequeue(throwIfEmpty:true):T\r\n\r\n\t/**\r\n\t * Pulls an entry from the head of the queue and returns it.\r\n\t * Returns undefined if the queue is already empty and throwIfEmpty is false.\r\n\t * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.\r\n\t * @param throwIfEmpty\r\n\t */\r\n\tdequeue(throwIfEmpty:boolean):T|undefined\r\n\tdequeue(throwIfEmpty:boolean = false):T|undefined\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.assertModifiable();\r\n\r\n\t\tlet result:T|undefined = VOID0;\r\n\t\tif(!this.tryDequeue( value => { result = value; }) && throwIfEmpty)\r\n\t\t\tthrow new InvalidOperationException(\"Cannot dequeue an empty queue.\");\r\n\t\treturn result;\r\n\t}\r\n\r\n\t/**\r\n\t * Checks to see if the queue has entries an pulls an entry from the head of the queue and passes it to the out handler.\r\n\t * @param out The 'out' handler that receives the value if it exists.\r\n\t * @returns {boolean} True if a value was retrieved.  False if not.\r\n\t */\r\n\ttryDequeue(out:Action<T>):boolean\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tif(!_._size) return false;\r\n\t\t_.assertModifiable();\r\n\r\n\t\t// A single dequeue shouldn't need update recursion tracking...\r\n\t\tif(this._tryDequeueInternal(out)) {\r\n\t\t\t// This may preemptively trigger the _onModified.\r\n\t\t\tif(_._size<_._capacity/2)\r\n\t\t\t\t_.trimExcess(SHRINK_THRESHOLD);\r\n\r\n\t\t\t_._signalModification();\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\treturn false;\r\n\t}\r\n\r\n\tprivate _getElement(index:number):T\r\n\t{\r\n\t\tassertIntegerZeroOrGreater(index, \"index\");\r\n\r\n\t\tconst _ = this;\r\n\t\treturn _._array[(_._head + index)%_._capacity];\r\n\t}\r\n\r\n\t/**\r\n\t * Returns the entry at the head of the queue.\r\n\t * Returns undefined if the queue is already empty.\r\n\t */\r\n\tpeek():T|undefined\r\n\r\n\t/**\r\n\t * Returns the entry at the head of the queue.\r\n\t * Returns undefined if the queue is already empty and throwIfEmpty is false.\r\n\t * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.\r\n\t * @param throwIfEmpty\r\n\t */\r\n\tpeek(throwIfEmpty:true):T\r\n\r\n\t/**\r\n\t * Returns the entry at the head of the queue.\r\n\t * Returns undefined if the queue is already empty and throwIfEmpty is false.\r\n\t * Throws an InvalidOperationException if the queue is already empty and throwIfEmpty is true.\r\n\t * @param throwIfEmpty\r\n\t */\r\n\tpeek(throwIfEmpty:boolean):T|undefined\r\n\tpeek(throwIfEmpty:boolean = false):T|undefined\r\n\t{\r\n\t\tif(this._size==0) {\r\n\t\t\tif(throwIfEmpty)\r\n\t\t\t\tthrow new InvalidOperationException(\"Cannot call peek on an empty queue.\");\r\n\t\t\treturn VOID0;\r\n\t\t}\r\n\r\n\r\n\t\treturn this._array[this._head];\r\n\t}\r\n\r\n\ttrimExcess(threshold?:number):void\r\n\t{\r\n\t\tconst _ = this;\r\n\t\tconst size = _._size;\r\n\t\tif(size<Math.floor(_._capacity*0.9) && (!threshold && threshold!==0 || isNaN(threshold) || threshold<size))\r\n\t\t\t_.setCapacity(size);\r\n\t}\r\n\r\n\tgetEnumerator():IEnumerator<T>\r\n\t{\r\n\t\tconst _ = this;\r\n\t\t_.throwIfDisposed();\r\n\r\n\t\tlet index:number, version:number, size:number;\r\n\t\treturn new EnumeratorBase<T>(\r\n\t\t\t() =>\r\n\t\t\t{\r\n\t\t\t\tversion = _._version;\r\n\t\t\t\tsize = _._size;\r\n\t\t\t\tindex = 0;\r\n\t\t\t},\r\n\t\t\t(yielder) =>\r\n\t\t\t{\r\n\t\t\t\t_.throwIfDisposed();\r\n\t\t\t\t_.assertVersion(version);\r\n\r\n\t\t\t\tif(index==size)\r\n\t\t\t\t\treturn yielder.yieldBreak();\r\n\r\n\t\t\t\treturn yielder.yieldReturn(_._getElement(index++));\r\n\t\t\t}\r\n\t\t);\r\n\t}\r\n}\r\n\r\nfunction assertZeroOrGreater(value:number, property:string):true|never\r\n{\r\n\tif(value<0)\r\n\t\tthrow new ArgumentOutOfRangeException(property, value, \"Must be greater than zero\");\r\n\r\n\treturn true;\r\n}\r\n\r\nfunction assertIntegerZeroOrGreater(value:number, property:string):true|never\r\n{\r\n\tInteger.assert(value, property);\r\n\treturn assertZeroOrGreater(value, property);\r\n}\r\n\r\nexport default Queue;\r\n"]}